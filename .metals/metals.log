2022.06.01 16:49:37 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at c:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\lsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\lsp.trace.json
2022.06.01 16:49:37 INFO  logging to file C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\metals.log
2022.06.01 16:49:37 INFO  Started: Metals version 0.11.5 in workspace 'C:\Users\DenisYamunaque\Documents\ADENTIS\adentis' for client Visual Studio Code 1.67.2.
2022.06.01 16:49:39 INFO  time: initialize in 1.43s
2022.06.01 16:49:39 WARN  Flyway upgrade recommended: H2 2.1.212 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.1.210.
2022.06.01 16:49:39 WARN  Build server is not auto-connectable.
2022.06.01 16:50:04 INFO  running 'C:\Program Files\Java\jdk-11.0.14\bin\java -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\DENISY~1\AppData\Local\Temp\metals1565139414615177664\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2022.06.01 16:50:05 INFO  [info] welcome to sbt 1.6.2 (Oracle Corporation Java 11.0.14)
2022.06.01 16:50:07 INFO  [info] loading settings for project adentis-build-build from metals.sbt ...
2022.06.01 16:50:07 INFO  [info] loading project definition from C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\project\project
2022.06.01 16:50:09 INFO  [info] loading settings for project adentis-build from metals.sbt ...
2022.06.01 16:50:09 INFO  [info] loading project definition from C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\project
2022.06.01 16:50:10 INFO  [success] Generated .bloop\adentis-build.json
2022.06.01 16:50:10 INFO  [success] Total time: 1 s, completed 1 Jun 2022, 16:50:10
2022.06.01 16:50:10 INFO  [info] loading settings for project root from build.sbt ...
2022.06.01 16:50:10 INFO  [info] set current project to adentis (in build file:/C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/)
2022.06.01 16:50:11 INFO  [success] Generated .bloop\root-test.json
2022.06.01 16:50:11 INFO  [success] Generated .bloop\root.json
2022.06.01 16:50:11 INFO  [success] Total time: 0 s, completed 1 Jun 2022, 16:50:11
2022.06.01 16:50:12 INFO  time: ran 'sbt bloopInstall' in 7.07s
2022.06.01 16:50:12 INFO  Attempting to connect to the build server...
2022.06.01 16:50:12 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.01 16:50:12 INFO  Attempting to connect to the build server...
2022.06.01 16:50:12 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\project\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.01 16:50:12 INFO  time: Connected to build server in 0.16s
2022.06.01 16:50:12 INFO  Connected to Build server: Bloop v1.5.0
2022.06.01 16:50:15 INFO  time: indexed workspace in 3.4s
2022.06.01 16:50:37 INFO  compiling root (1 scala source)
2022.06.01 16:50:37 INFO  time: compiled root in 0.27s
Jun 01, 2022 11:50:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: 36 is not a valid line number, allowed [0..6]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:37)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:32)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionPositionLspInverse.toMeta(MtagsEnrichments.scala:179)
	at scala.meta.internal.parsing.Trees.$anonfun$findLastEnclosingAt$4(Trees.scala:76)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.Trees.findLastEnclosingAt(Trees.scala:75)
	at scala.meta.internal.metals.codeactions.PatternMatchRefactor.contribute(PatternMatchRefactor.scala:96)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:64)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:63)
	at scala.collection.immutable.List.collect(List.scala:275)
	at scala.meta.internal.metals.CodeActionProvider.codeActions(CodeActionProvider.scala:63)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeAction$1(MetalsLanguageServer.scala:1639)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLanguageServer.codeAction(MetalsLanguageServer.scala:1638)
	... 15 more

Jun 01, 2022 11:51:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: 36 is not a valid line number, allowed [0..6]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:37)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:32)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionPositionLspInverse.toMeta(MtagsEnrichments.scala:179)
	at scala.meta.internal.parsing.Trees.$anonfun$findLastEnclosingAt$4(Trees.scala:76)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.Trees.findLastEnclosingAt(Trees.scala:75)
	at scala.meta.internal.metals.codeactions.PatternMatchRefactor.contribute(PatternMatchRefactor.scala:96)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:64)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:63)
	at scala.collection.immutable.List.collect(List.scala:275)
	at scala.meta.internal.metals.CodeActionProvider.codeActions(CodeActionProvider.scala:63)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeAction$1(MetalsLanguageServer.scala:1639)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLanguageServer.codeAction(MetalsLanguageServer.scala:1638)
	... 15 more

Jun 01, 2022 11:52:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: 7 is not a valid line number, allowed [0..6]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:37)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:32)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionPositionLspInverse.toMeta(MtagsEnrichments.scala:179)
	at scala.meta.internal.parsing.Trees.$anonfun$findLastEnclosingAt$4(Trees.scala:76)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.Trees.findLastEnclosingAt(Trees.scala:75)
	at scala.meta.internal.metals.codeactions.PatternMatchRefactor.contribute(PatternMatchRefactor.scala:96)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:64)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:63)
	at scala.collection.immutable.List.collect(List.scala:275)
	at scala.meta.internal.metals.CodeActionProvider.codeActions(CodeActionProvider.scala:63)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeAction$1(MetalsLanguageServer.scala:1639)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLanguageServer.codeAction(MetalsLanguageServer.scala:1638)
	... 15 more

Jun 01, 2022 11:52:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: 7 is not a valid line number, allowed [0..6]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:37)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:32)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionPositionLspInverse.toMeta(MtagsEnrichments.scala:179)
	at scala.meta.internal.parsing.Trees.$anonfun$findLastEnclosingAt$4(Trees.scala:76)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.Trees.findLastEnclosingAt(Trees.scala:75)
	at scala.meta.internal.metals.codeactions.PatternMatchRefactor.contribute(PatternMatchRefactor.scala:96)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:64)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:63)
	at scala.collection.immutable.List.collect(List.scala:275)
	at scala.meta.internal.metals.CodeActionProvider.codeActions(CodeActionProvider.scala:63)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeAction$1(MetalsLanguageServer.scala:1639)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLanguageServer.codeAction(MetalsLanguageServer.scala:1638)
	... 15 more

Jun 01, 2022 11:52:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: 7 is not a valid line number, allowed [0..6]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:37)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:32)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionPositionLspInverse.toMeta(MtagsEnrichments.scala:179)
	at scala.meta.internal.parsing.Trees.$anonfun$findLastEnclosingAt$4(Trees.scala:76)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.Trees.findLastEnclosingAt(Trees.scala:75)
	at scala.meta.internal.metals.codeactions.PatternMatchRefactor.contribute(PatternMatchRefactor.scala:96)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:64)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:63)
	at scala.collection.immutable.List.collect(List.scala:275)
	at scala.meta.internal.metals.CodeActionProvider.codeActions(CodeActionProvider.scala:63)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeAction$1(MetalsLanguageServer.scala:1639)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLanguageServer.codeAction(MetalsLanguageServer.scala:1638)
	... 15 more

2022.06.01 23:55:01 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.01 23:55:01 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.01 23:55:01 INFO  Connected to Build server: Bloop v1.5.0
2022.06.01 23:55:01 INFO  Connected to Build server: Bloop v1.5.0
2022.06.01 23:55:01 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\project\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.01 23:55:01 INFO  compiling root (1 scala source)
2022.06.01 23:55:01 INFO  time: Imported build in 0.16s
2022.06.01 23:55:03 INFO  time: indexed workspace in 1.54s
2022.06.01 23:55:03 INFO  compiling root (1 scala source)
2022.06.01 23:55:04 INFO  time: compiled root in 1.2s
2022.06.01 23:56:02 INFO  compiling root (1 scala source)
2022.06.01 23:56:02 INFO  time: compiled root in 73ms
2022.06.01 23:57:51 INFO  compiling root (1 scala source)
2022.06.01 23:57:51 INFO  time: compiled root in 0.57s
Jun 01, 2022 11:58:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 462,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:DateTime)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:DateTime)\r\n\r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..571]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 463,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:DateTime)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:DateTime)\r\n\r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..569]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1159
Jun 01, 2022 11:58:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 464,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:DateTime)\r\n\r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..565]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 468,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n\r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..561]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

2022.06.01 23:58:52 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:1:8: stale bloop error: value scala_tools is not a member of org
import org.scala_tools.time.Imports._
       ^^^^^^^^^^^^^^^
2022.06.01 23:58:52 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:1:8: stale bloop error: value scala_tools is not a member of org
import org.scala_tools.time.Imports._
       ^^^^^^^^^^^^^^^
2022.06.01 23:58:52 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:1:8: stale bloop error: value scala_tools is not a member of org
import org.scala_tools.time.Imports._
       ^^^^^^^^^^^^^^^
2022.06.01 23:58:52 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:1:8: stale bloop error: value scala_tools is not a member of org
import org.scala_tools.time.Imports._
       ^^^^^^^^^^^^^^^
Jun 01, 2022 11:58:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 472,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..565]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 473,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\n\r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..567]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 474,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\nc\r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..568]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 475,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\nca\r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..569]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 478,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase \r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..572]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 484,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class \r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..578]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 485,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class D\r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..579]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 488,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class Date\r\n\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..582]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 489,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class Date(\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..581]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:58:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 490,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class Date()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..582]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 493,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class D()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..579]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 495,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class T()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..579]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 497,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class Tim()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..581]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 498,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Date)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class Time()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..582]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 503,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:T)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class Time()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..579]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 504,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Ti)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class Time()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..580]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 505,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Tim)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class Time()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..581]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 506,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Time)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Date)\r\n/**/\r\ncase class Time()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..582]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 511,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Time)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:T)\r\n/**/\r\ncase class Time()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..579]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 512,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Time)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Ti)\r\n/**/\r\ncase class Time()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..580]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 513,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Time)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Tim)\r\n/**/\r\ncase class Time()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..581]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

Jun 01, 2022 11:59:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 514,
      "uri": "file:///c%3A/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala"
    },
    "contentChanges": [
      {
        "text": "\r\n/*\r\n * Order: Customer name and contact, shipping address, grand total, date when the order was placed\r\n */\r\ncase class Order(customerName:String, contact:String, shippingAddress:String, total:String, placedDate:Time)\r\n/*\r\n * Item: Cost, shipping fee, tax amount\r\n */\r\ncase class Item(cost:Double, shippingFee:Double, taxAmount:Double)\r\n/*\r\n * Product: Name, category, weight, price, creation date\r\n */\r\ncase class Product(name:String, category:String, weight:Double, price:Double, creationDate:Time)\r\n/**/\r\ncase class Time()\r\n\r\n@main def hello: Unit \u003d \r\n  println(\"Hello world!\")"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor9.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..582]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:48)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:42)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:37)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionMetaPosition.toLSP(CommonMtagsEnrichments.scala:95)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:227)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:253)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3(Diagnostics.scala:222)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$3$adapted(Diagnostics.scala:221)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:563)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:561)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:926)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:221)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:178)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:126)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1200)
	... 15 more

2022.06.01 23:59:21 INFO  compiling root (1 scala source)
2022.06.01 23:59:21 INFO  time: compiled root in 0.55s
2022.06.02 00:04:52 INFO  compiling root (1 scala source)
2022.06.02 00:04:52 INFO  time: compiled root in 84ms
2022.06.02 00:06:22 INFO  compiling root (1 scala source)
2022.06.02 00:06:22 INFO  time: compiled root in 0.39s
2022.06.02 00:06:49 INFO  compiling root (1 scala source)
2022.06.02 00:06:49 INFO  time: compiled root in 53ms
2022.06.02 00:07:02 INFO  compiling root (1 scala source)
2022.06.02 00:07:02 INFO  time: compiled root in 0.29s
2022.06.02 00:11:10 INFO  compiling root (1 scala source)
2022.06.02 00:11:10 INFO  time: compiled root in 63ms
2022.06.02 00:13:07 INFO  compiling root (1 scala source)
2022.06.02 00:13:07 INFO  time: compiled root in 52ms
2022.06.02 00:13:14 INFO  compiling root (1 scala source)
2022.06.02 00:13:14 INFO  time: compiled root in 61ms
2022.06.02 00:13:29 INFO  compiling root (1 scala source)
2022.06.02 00:13:29 INFO  time: compiled root in 51ms
2022.06.02 00:14:05 INFO  compiling root (1 scala source)
2022.06.02 00:14:05 INFO  time: compiled root in 0.27s
2022.06.02 00:14:21 INFO  compiling root (1 scala source)
2022.06.02 00:14:21 INFO  time: compiled root in 0.31s
2022.06.02 00:14:32 INFO  compiling root-test (1 scala source)
2022.06.02 00:14:32 INFO  time: compiled root-test in 0.19s
2022.06.02 00:14:35 INFO  compiling root (1 scala source)
2022.06.02 00:14:35 INFO  time: compiled root in 0.21s
2022.06.02 00:14:38 INFO  compiling root (1 scala source)
2022.06.02 00:14:38 INFO  time: compiled root in 54ms
2022.06.02 00:15:55 INFO  compiling root (1 scala source)
2022.06.02 00:15:55 INFO  time: compiled root in 0.18s
2022.06.02 00:16:07 INFO  compiling root (1 scala source)
2022.06.02 00:16:07 INFO  time: compiled root in 0.22s
2022.06.02 00:17:09 INFO  compiling root (1 scala source)
2022.06.02 00:17:09 INFO  time: compiled root in 0.27s
2022.06.02 00:17:17 INFO  compiling root (1 scala source)
2022.06.02 00:17:17 INFO  time: compiled root in 0.22s
2022.06.02 00:19:20 INFO  compiling root (1 scala source)
2022.06.02 00:19:20 INFO  time: compiled root in 0.22s
2022.06.02 00:19:36 INFO  compiling root (1 scala source)
2022.06.02 00:19:36 INFO  time: compiled root in 49ms
2022.06.02 00:19:40 INFO  compiling root (1 scala source)
2022.06.02 00:19:40 INFO  time: compiled root in 46ms
2022.06.02 00:19:42 INFO  compiling root (1 scala source)
2022.06.02 00:19:42 INFO  time: compiled root in 0.21s
2022.06.02 00:19:58 INFO  compiling root (1 scala source)
2022.06.02 00:19:58 INFO  time: compiled root in 0.2s
2022.06.02 00:22:39 INFO  compiling root (1 scala source)
2022.06.02 00:22:39 INFO  time: compiled root in 0.21s
Jun 02, 2022 12:25:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11.0.14/lib/src.zip%21/java.base/java/lang/String.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.lang;\n\nimport java.io.ObjectStreamField;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Native;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Spliterator;\nimport java.util.StringJoiner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\nimport jdk.internal.HotSpotIntrinsicCandidate;\nimport jdk.internal.vm.annotation.Stable;\n\n/**\n * The {@code String} class represents character strings. All\n * string literals in Java programs, such as {@code \"abc\"}, are\n * implemented as instances of this class.\n * \u003cp\u003e\n * Strings are constant; their values cannot be changed after they\n * are created. String buffers support mutable strings.\n * Because String objects are immutable they can be shared. For example:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     String str \u003d \"abc\";\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * is equivalent to:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     char data[] \u003d {\u0027a\u0027, \u0027b\u0027, \u0027c\u0027};\n *     String str \u003d new String(data);\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003cp\u003e\n * Here are some more examples of how strings can be used:\n * \u003cblockquote\u003e\u003cpre\u003e\n *     System.out.println(\"abc\");\n *     String cde \u003d \"cde\";\n *     System.out.println(\"abc\" + cde);\n *     String c \u003d \"abc\".substring(2,3);\n *     String d \u003d cde.substring(1, 2);\n * \u003c/pre\u003e\u003c/blockquote\u003e\n * \u003cp\u003e\n * The class {@code String} includes methods for examining\n * individual characters of the sequence, for comparing strings, for\n * searching strings, for extracting substrings, and for creating a\n * copy of a string with all characters translated to uppercase or to\n * lowercase. Case mapping is based on the Unicode Standard version\n * specified by the {@link java.lang.Character Character} class.\n * \u003cp\u003e\n * The Java language provides special support for the string\n * concatenation operator (\u0026nbsp;+\u0026nbsp;), and for conversion of\n * other objects to strings. For additional information on string\n * concatenation and conversion, see \u003ci\u003eThe Java\u0026trade; Language Specification\u003c/i\u003e.\n *\n * \u003cp\u003e Unless otherwise noted, passing a {@code null} argument to a constructor\n * or method in this class will cause a {@link NullPointerException} to be\n * thrown.\n *\n * \u003cp\u003eA {@code String} represents a string in the UTF-16 format\n * in which \u003cem\u003esupplementary characters\u003c/em\u003e are represented by \u003cem\u003esurrogate\n * pairs\u003c/em\u003e (see the section \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n * Character Representations\u003c/a\u003e in the {@code Character} class for\n * more information).\n * Index values refer to {@code char} code units, so a supplementary\n * character uses two positions in a {@code String}.\n * \u003cp\u003eThe {@code String} class provides methods for dealing with\n * Unicode code points (i.e., characters), in addition to those for\n * dealing with Unicode code units (i.e., {@code char} values).\n *\n * \u003cp\u003eUnless otherwise noted, methods for comparing Strings do not take locale\n * into account.  The {@link java.text.Collator} class provides methods for\n * finer-grain, locale-sensitive String comparison.\n *\n * @implNote The implementation of the string concatenation operator is left to\n * the discretion of a Java compiler, as long as the compiler ultimately conforms\n * to \u003ci\u003eThe Java\u0026trade; Language Specification\u003c/i\u003e. For example, the {@code javac} compiler\n * may implement the operator with {@code StringBuffer}, {@code StringBuilder},\n * or {@code java.lang.invoke.StringConcatFactory} depending on the JDK version. The\n * implementation of string conversion is typically through the method {@code toString},\n * defined by {@code Object} and inherited by all classes in Java.\n *\n * @author  Lee Boynton\n * @author  Arthur van Hoff\n * @author  Martin Buchholz\n * @author  Ulf Zibis\n * @see     java.lang.Object#toString()\n * @see     java.lang.StringBuffer\n * @see     java.lang.StringBuilder\n * @see     java.nio.charset.Charset\n * @since   1.0\n * @jls     15.18.1 String Concatenation Operator +\n */\n\npublic final class String\n    implements java.io.Serializable, Comparable\u003cString\u003e, CharSequence {\n\n    /**\n     * The value is used for character storage.\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     *\n     * Additionally, it is marked with {@link Stable} to trust the contents\n     * of the array. No other facility in JDK provides this functionality (yet).\n     * {@link Stable} is safe here, because value is never null.\n     */\n    @Stable\n    private final byte[] value;\n\n    /**\n     * The identifier of the encoding used to encode the bytes in\n     * {@code value}. The supported values in this implementation are\n     *\n     * LATIN1\n     * UTF16\n     *\n     * @implNote This field is trusted by the VM, and is a subject to\n     * constant folding if String instance is constant. Overwriting this\n     * field after construction will cause problems.\n     */\n    private final byte coder;\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    private static final long serialVersionUID \u003d -6849794470754667710L;\n\n    /**\n     * If String compaction is disabled, the bytes in {@code value} are\n     * always encoded in UTF16.\n     *\n     * For methods with several possible implementation paths, when String\n     * compaction is disabled, only one code path is taken.\n     *\n     * The instance field value is generally opaque to optimizing JIT\n     * compilers. Therefore, in performance-sensitive place, an explicit\n     * check of the static boolean {@code COMPACT_STRINGS} is done first\n     * before checking the {@code coder} field since the static boolean\n     * {@code COMPACT_STRINGS} would be constant folded away by an\n     * optimizing JIT compiler. The idioms for these cases are as follows.\n     *\n     * For code such as:\n     *\n     *    if (coder \u003d\u003d LATIN1) { ... }\n     *\n     * can be written more optimally as\n     *\n     *    if (coder() \u003d\u003d LATIN1) { ... }\n     *\n     * or:\n     *\n     *    if (COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1) { ... }\n     *\n     * An optimizing JIT compiler can fold the above conditional as:\n     *\n     *    COMPACT_STRINGS \u003d\u003d true  \u003d\u003e if (coder \u003d\u003d LATIN1) { ... }\n     *    COMPACT_STRINGS \u003d\u003d false \u003d\u003e if (false)           { ... }\n     *\n     * @implNote\n     * The actual value for this field is injected by JVM. The static\n     * initialization block is used to set the value here to communicate\n     * that this static final field is not statically foldable, and to\n     * avoid any possible circular dependency during vm initialization.\n     */\n    static final boolean COMPACT_STRINGS;\n\n    static {\n        COMPACT_STRINGS \u003d true;\n    }\n\n    /**\n     * Class String is special cased within the Serialization Stream Protocol.\n     *\n     * A String instance is written into an ObjectOutputStream according to\n     * \u003ca href\u003d\"{@docRoot}/../specs/serialization/protocol.html#stream-elements\"\u003e\n     * Object Serialization Specification, Section 6.2, \"Stream Elements\"\u003c/a\u003e\n     */\n    private static final ObjectStreamField[] serialPersistentFields \u003d\n        new ObjectStreamField[0];\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * an empty character sequence.  Note that use of this constructor is\n     * unnecessary since Strings are immutable.\n     */\n    public String() {\n        this.value \u003d \"\".value;\n        this.coder \u003d \"\".coder;\n    }\n\n    /**\n     * Initializes a newly created {@code String} object so that it represents\n     * the same sequence of characters as the argument; in other words, the\n     * newly created string is a copy of the argument string. Unless an\n     * explicit copy of {@code original} is needed, use of this constructor is\n     * unnecessary since Strings are immutable.\n     *\n     * @param  original\n     *         A {@code String}\n     */\n    @HotSpotIntrinsicCandidate\n    public String(String original) {\n        this.value \u003d original.value;\n        this.coder \u003d original.coder;\n        this.hash \u003d original.hash;\n    }\n\n    /**\n     * Allocates a new {@code String} so that it represents the sequence of\n     * characters currently contained in the character array argument. The\n     * contents of the character array are copied; subsequent modification of\n     * the character array does not affect the newly created string.\n     *\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char value[]) {\n        this(value, 0, value.length, null);\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the character array argument. The {@code offset} argument is the\n     * index of the first character of the subarray and the {@code count}\n     * argument specifies the length of the subarray. The contents of the\n     * subarray are copied; subsequent modification of the character array does\n     * not affect the newly created string.\n     *\n     * @param  value\n     *         Array that is the source of characters\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code value.length - count}\n     */\n    public String(char value[], int offset, int count) {\n        this(value, offset, count, rangeCheck(value, offset, count));\n    }\n\n    private static Void rangeCheck(char[] value, int offset, int count) {\n        checkBoundsOffCount(offset, count, value.length);\n        return null;\n    }\n\n    /**\n     * Allocates a new {@code String} that contains characters from a subarray\n     * of the \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode code point\u003c/a\u003e array\n     * argument.  The {@code offset} argument is the index of the first code\n     * point of the subarray and the {@code count} argument specifies the\n     * length of the subarray.  The contents of the subarray are converted to\n     * {@code char}s; subsequent modification of the {@code int} array does not\n     * affect the newly created string.\n     *\n     * @param  codePoints\n     *         Array that is the source of Unicode code points\n     *\n     * @param  offset\n     *         The initial offset\n     *\n     * @param  count\n     *         The length\n     *\n     * @throws  IllegalArgumentException\n     *          If any invalid Unicode code point is found in {@code\n     *          codePoints}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code codePoints.length - count}\n     *\n     * @since  1.5\n     */\n    public String(int[] codePoints, int offset, int count) {\n        checkBoundsOffCount(offset, count, codePoints.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringLatin1.toBytes(codePoints, offset, count);\n            if (val !\u003d null) {\n                this.coder \u003d LATIN1;\n                this.value \u003d val;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(codePoints, offset, count);\n    }\n\n    /**\n     * Allocates a new {@code String} constructed from a subarray of an array\n     * of 8-bit integer values.\n     *\n     * \u003cp\u003e The {@code offset} argument is the index of the first byte of the\n     * subarray, and the {@code count} argument specifies the length of the\n     * subarray.\n     *\n     * \u003cp\u003e Each {@code byte} in the subarray is converted to a {@code char} as\n     * specified in the {@link #String(byte[],int) String(byte[],int)} constructor.\n     *\n     * @deprecated This method does not properly convert bytes into characters.\n     * As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link\n     * java.nio.charset.Charset}, charset name, or that use the platform\u0027s\n     * default charset.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @param  offset\n     *         The initial offset\n     * @param  count\n     *         The length\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative, or\n     *          {@code offset} is greater than {@code ascii.length - count}\n     *\n     * @see  #String(byte[], int)\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte ascii[], int hibyte, int offset, int count) {\n        checkBoundsOffCount(offset, count, ascii.length);\n        if (count \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS \u0026\u0026 (byte)hibyte \u003d\u003d 0) {\n            this.value \u003d Arrays.copyOfRange(ascii, offset, offset + count);\n            this.coder \u003d LATIN1;\n        } else {\n            hibyte \u003c\u003c\u003d 8;\n            byte[] val \u003d StringUTF16.newBytesFor(count);\n            for (int i \u003d 0; i \u003c count; i++) {\n                StringUTF16.putChar(val, i, hibyte | (ascii[offset++] \u0026 0xff));\n            }\n            this.value \u003d val;\n            this.coder \u003d UTF16;\n        }\n    }\n\n    /**\n     * Allocates a new {@code String} containing characters constructed from\n     * an array of 8-bit integer values. Each character \u003ci\u003ec\u003c/i\u003e in the\n     * resulting string is constructed from the corresponding component\n     * \u003ci\u003eb\u003c/i\u003e in the byte array such that:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     \u003cb\u003e\u003ci\u003ec\u003c/i\u003e\u003c/b\u003e \u003d\u003d (char)(((hibyte \u0026amp; 0xff) \u0026lt;\u0026lt; 8)\n     *                         | (\u003cb\u003e\u003ci\u003eb\u003c/i\u003e\u003c/b\u003e \u0026amp; 0xff))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert bytes into\n     * characters.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@code String} constructors that take a {@link\n     * java.nio.charset.Charset}, charset name, or that use the platform\u0027s\n     * default charset.\n     *\n     * @param  ascii\n     *         The bytes to be converted to characters\n     *\n     * @param  hibyte\n     *         The top 8 bits of each 16-bit Unicode code unit\n     *\n     * @see  #String(byte[], int, int, java.lang.String)\n     * @see  #String(byte[], int, int, java.nio.charset.Charset)\n     * @see  #String(byte[], int, int)\n     * @see  #String(byte[], java.lang.String)\n     * @see  #String(byte[], java.nio.charset.Charset)\n     * @see  #String(byte[])\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public String(byte ascii[], int hibyte) {\n        this(ascii, hibyte, 0, ascii.length);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified charset.  The length of the new {@code String}\n     * is a function of the charset, and hence may not be equal to the length\n     * of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte bytes[], int offset, int length, String charsetName)\n            throws UnsupportedEncodingException {\n        if (charsetName \u003d\u003d null)\n            throw new NullPointerException(\"charsetName\");\n        checkBoundsOffCount(offset, length, bytes.length);\n        StringCoding.Result ret \u003d\n            StringCoding.decode(charsetName, bytes, offset, length);\n        this.value \u003d ret.value;\n        this.coder \u003d ret.coder;\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the subarray.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.6\n     */\n    public String(byte bytes[], int offset, int length, Charset charset) {\n        if (charset \u003d\u003d null)\n            throw new NullPointerException(\"charset\");\n        checkBoundsOffCount(offset, length, bytes.length);\n        StringCoding.Result ret \u003d\n            StringCoding.decode(charset, bytes, offset, length);\n        this.value \u003d ret.value;\n        this.coder \u003d ret.coder;\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the specified {@linkplain java.nio.charset.Charset charset}.  The\n     * length of the new {@code String} is a function of the charset, and hence\n     * may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public String(byte bytes[], String charsetName)\n            throws UnsupportedEncodingException {\n        this(bytes, 0, bytes.length, charsetName);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of\n     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n     * The length of the new {@code String} is a function of the charset, and\n     * hence may not be equal to the length of the byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement string.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset charset} to be used to\n     *         decode the {@code bytes}\n     *\n     * @since  1.6\n     */\n    public String(byte bytes[], Charset charset) {\n        this(bytes, 0, bytes.length, charset);\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified subarray of\n     * bytes using the platform\u0027s default charset.  The length of the new\n     * {@code String} is a function of the charset, and hence may not be equal\n     * to the length of the subarray.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @param  offset\n     *         The index of the first byte to decode\n     *\n     * @param  length\n     *         The number of bytes to decode\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code length} is negative, or\n     *          {@code offset} is greater than {@code bytes.length - length}\n     *\n     * @since  1.1\n     */\n    public String(byte bytes[], int offset, int length) {\n        checkBoundsOffCount(offset, length, bytes.length);\n        StringCoding.Result ret \u003d StringCoding.decode(bytes, offset, length);\n        this.value \u003d ret.value;\n        this.coder \u003d ret.coder;\n    }\n\n    /**\n     * Constructs a new {@code String} by decoding the specified array of bytes\n     * using the platform\u0027s default charset.  The length of the new {@code\n     * String} is a function of the charset, and hence may not be equal to the\n     * length of the byte array.\n     *\n     * \u003cp\u003e The behavior of this constructor when the given bytes are not valid\n     * in the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetDecoder} class should be used when more control\n     * over the decoding process is required.\n     *\n     * @param  bytes\n     *         The bytes to be decoded into characters\n     *\n     * @since  1.1\n     */\n    public String(byte[] bytes) {\n        this(bytes, 0, bytes.length);\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string buffer argument. The contents of the\n     * string buffer are copied; subsequent modification of the string buffer\n     * does not affect the newly created string.\n     *\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        this(buffer.toString());\n    }\n\n    /**\n     * Allocates a new string that contains the sequence of characters\n     * currently contained in the string builder argument. The contents of the\n     * string builder are copied; subsequent modification of the string builder\n     * does not affect the newly created string.\n     *\n     * \u003cp\u003e This constructor is provided to ease migration to {@code\n     * StringBuilder}. Obtaining a string from a string builder via the {@code\n     * toString} method is likely to run faster and is generally preferred.\n     *\n     * @param   builder\n     *          A {@code StringBuilder}\n     *\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this(builder, null);\n    }\n\n    /**\n     * Returns the length of this string.\n     * The length is equal to the number of \u003ca href\u003d\"Character.html#unicode\"\u003eUnicode\n     * code units\u003c/a\u003e in the string.\n     *\n     * @return  the length of the sequence of characters represented by this\n     *          object.\n     */\n    public int length() {\n        return value.length \u003e\u003e coder();\n    }\n\n    /**\n     * Returns {@code true} if, and only if, {@link #length()} is {@code 0}.\n     *\n     * @return {@code true} if {@link #length()} is {@code 0}, otherwise\n     * {@code false}\n     *\n     * @since 1.6\n     */\n    public boolean isEmpty() {\n        return value.length \u003d\u003d 0;\n    }\n\n    /**\n     * Returns the {@code char} value at the\n     * specified index. An index ranges from {@code 0} to\n     * {@code length() - 1}. The first {@code char} value of the sequence\n     * is at index {@code 0}, the next at index {@code 1},\n     * and so on, as for array indexing.\n     *\n     * \u003cp\u003eIf the {@code char} value specified by the index is a\n     * \u003ca href\u003d\"Character.html#unicode\"\u003esurrogate\u003c/a\u003e, the surrogate\n     * value is returned.\n     *\n     * @param      index   the index of the {@code char} value.\n     * @return     the {@code char} value at the specified index of this string.\n     *             The first {@code char} value is at index {@code 0}.\n     * @exception  IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     */\n    public char charAt(int index) {\n        if (isLatin1()) {\n            return StringLatin1.charAt(value, index);\n        } else {\n            return StringUTF16.charAt(value, index);\n        }\n    }\n\n    /**\n     * Returns the character (Unicode code point) at the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 0} to\n     * {@link #length()}{@code  - 1}.\n     *\n     * \u003cp\u003e If the {@code char} value specified at the given index\n     * is in the high-surrogate range, the following index is less\n     * than the length of this {@code String}, and the\n     * {@code char} value at the following index is in the\n     * low-surrogate range, then the supplementary code point\n     * corresponding to this surrogate pair is returned. Otherwise,\n     * the {@code char} value at the given index is returned.\n     *\n     * @param      index the index to the {@code char} values\n     * @return     the code point value of the character at the\n     *             {@code index}\n     * @exception  IndexOutOfBoundsException  if the {@code index}\n     *             argument is negative or not less than the length of this\n     *             string.\n     * @since      1.5\n     */\n    public int codePointAt(int index) {\n        if (isLatin1()) {\n            checkIndex(index, value.length);\n            return value[index] \u0026 0xff;\n        }\n        int length \u003d value.length \u003e\u003e 1;\n        checkIndex(index, length);\n        return StringUTF16.codePointAt(value, index, length);\n    }\n\n    /**\n     * Returns the character (Unicode code point) before the specified\n     * index. The index refers to {@code char} values\n     * (Unicode code units) and ranges from {@code 1} to {@link\n     * CharSequence#length() length}.\n     *\n     * \u003cp\u003e If the {@code char} value at {@code (index - 1)}\n     * is in the low-surrogate range, {@code (index - 2)} is not\n     * negative, and the {@code char} value at {@code (index -\n     * 2)} is in the high-surrogate range, then the\n     * supplementary code point value of the surrogate pair is\n     * returned. If the {@code char} value at {@code index -\n     * 1} is an unpaired low-surrogate or a high-surrogate, the\n     * surrogate value is returned.\n     *\n     * @param     index the index following the code point that should be returned\n     * @return    the Unicode code point value before the given index.\n     * @exception IndexOutOfBoundsException if the {@code index}\n     *            argument is less than 1 or greater than the length\n     *            of this string.\n     * @since     1.5\n     */\n    public int codePointBefore(int index) {\n        int i \u003d index - 1;\n        if (i \u003c 0 || i \u003e\u003d length()) {\n            throw new StringIndexOutOfBoundsException(index);\n        }\n        if (isLatin1()) {\n            return (value[i] \u0026 0xff);\n        }\n        return StringUTF16.codePointBefore(value, index);\n    }\n\n    /**\n     * Returns the number of Unicode code points in the specified text\n     * range of this {@code String}. The text range begins at the\n     * specified {@code beginIndex} and extends to the\n     * {@code char} at index {@code endIndex - 1}. Thus the\n     * length (in {@code char}s) of the text range is\n     * {@code endIndex-beginIndex}. Unpaired surrogates within\n     * the text range count as one code point each.\n     *\n     * @param beginIndex the index to the first {@code char} of\n     * the text range.\n     * @param endIndex the index after the last {@code char} of\n     * the text range.\n     * @return the number of Unicode code points in the specified text\n     * range\n     * @exception IndexOutOfBoundsException if the\n     * {@code beginIndex} is negative, or {@code endIndex}\n     * is larger than the length of this {@code String}, or\n     * {@code beginIndex} is larger than {@code endIndex}.\n     * @since  1.5\n     */\n    public int codePointCount(int beginIndex, int endIndex) {\n        if (beginIndex \u003c 0 || beginIndex \u003e endIndex ||\n            endIndex \u003e length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        if (isLatin1()) {\n            return endIndex - beginIndex;\n        }\n        return StringUTF16.codePointCount(value, beginIndex, endIndex);\n    }\n\n    /**\n     * Returns the index within this {@code String} that is\n     * offset from the given {@code index} by\n     * {@code codePointOffset} code points. Unpaired surrogates\n     * within the text range given by {@code index} and\n     * {@code codePointOffset} count as one code point each.\n     *\n     * @param index the index to be offset\n     * @param codePointOffset the offset in code points\n     * @return the index within this {@code String}\n     * @exception IndexOutOfBoundsException if {@code index}\n     *   is negative or larger then the length of this\n     *   {@code String}, or if {@code codePointOffset} is positive\n     *   and the substring starting with {@code index} has fewer\n     *   than {@code codePointOffset} code points,\n     *   or if {@code codePointOffset} is negative and the substring\n     *   before {@code index} has fewer than the absolute value\n     *   of {@code codePointOffset} code points.\n     * @since 1.5\n     */\n    public int offsetByCodePoints(int index, int codePointOffset) {\n        if (index \u003c 0 || index \u003e length()) {\n            throw new IndexOutOfBoundsException();\n        }\n        return Character.offsetByCodePoints(this, index, codePointOffset);\n    }\n\n    /**\n     * Copies characters from this string into the destination character\n     * array.\n     * \u003cp\u003e\n     * The first character to be copied is at index {@code srcBegin};\n     * the last character to be copied is at index {@code srcEnd-1}\n     * (thus the total number of characters to be copied is\n     * {@code srcEnd-srcBegin}). The characters are copied into the\n     * subarray of {@code dst} starting at index {@code dstBegin}\n     * and ending at index:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      srcBegin   index of the first character in the string\n     *                        to copy.\n     * @param      srcEnd     index after the last character in the string\n     *                        to copy.\n     * @param      dst        the destination array.\n     * @param      dstBegin   the start offset in the destination array.\n     * @exception IndexOutOfBoundsException If any of the following\n     *            is true:\n     *            \u003cul\u003e\u003cli\u003e{@code srcBegin} is negative.\n     *            \u003cli\u003e{@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e{@code srcEnd} is greater than the length of this\n     *                string\n     *            \u003cli\u003e{@code dstBegin} is negative\n     *            \u003cli\u003e{@code dstBegin+(srcEnd-srcBegin)} is larger than\n     *                {@code dst.length}\u003c/ul\u003e\n     */\n    public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getChars(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Copies characters from this string into the destination byte array. Each\n     * byte receives the 8 low-order bits of the corresponding character. The\n     * eight high-order bits of each character are not copied and do not\n     * participate in the transfer in any way.\n     *\n     * \u003cp\u003e The first character to be copied is at index {@code srcBegin}; the\n     * last character to be copied is at index {@code srcEnd-1}.  The total\n     * number of characters to be copied is {@code srcEnd-srcBegin}. The\n     * characters, converted to bytes, are copied into the subarray of {@code\n     * dst} starting at index {@code dstBegin} and ending at index:\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     dstBegin + (srcEnd-srcBegin) - 1\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @deprecated  This method does not properly convert characters into\n     * bytes.  As of JDK\u0026nbsp;1.1, the preferred way to do this is via the\n     * {@link #getBytes()} method, which uses the platform\u0027s default charset.\n     *\n     * @param  srcBegin\n     *         Index of the first character in the string to copy\n     *\n     * @param  srcEnd\n     *         Index after the last character in the string to copy\n     *\n     * @param  dst\n     *         The destination array\n     *\n     * @param  dstBegin\n     *         The start offset in the destination array\n     *\n     * @throws  IndexOutOfBoundsException\n     *          If any of the following is true:\n     *          \u003cul\u003e\n     *            \u003cli\u003e {@code srcBegin} is negative\n     *            \u003cli\u003e {@code srcBegin} is greater than {@code srcEnd}\n     *            \u003cli\u003e {@code srcEnd} is greater than the length of this String\n     *            \u003cli\u003e {@code dstBegin} is negative\n     *            \u003cli\u003e {@code dstBegin+(srcEnd-srcBegin)} is larger than {@code\n     *                 dst.length}\n     *          \u003c/ul\u003e\n     */\n    @Deprecated(since\u003d\"1.1\")\n    public void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) {\n        checkBoundsBeginEnd(srcBegin, srcEnd, length());\n        Objects.requireNonNull(dst);\n        checkBoundsOffCount(dstBegin, srcEnd - srcBegin, dst.length);\n        if (isLatin1()) {\n            StringLatin1.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        } else {\n            StringUTF16.getBytes(value, srcBegin, srcEnd, dst, dstBegin);\n        }\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the named\n     * charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the given charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @param  charsetName\n     *         The name of a supported {@linkplain java.nio.charset.Charset\n     *         charset}\n     *\n     * @return  The resultant byte array\n     *\n     * @throws  UnsupportedEncodingException\n     *          If the named charset is not supported\n     *\n     * @since  1.1\n     */\n    public byte[] getBytes(String charsetName)\n            throws UnsupportedEncodingException {\n        if (charsetName \u003d\u003d null) throw new NullPointerException();\n        return StringCoding.encode(charsetName, coder(), value);\n    }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the given\n     * {@linkplain java.nio.charset.Charset charset}, storing the result into a\n     * new byte array.\n     *\n     * \u003cp\u003e This method always replaces malformed-input and unmappable-character\n     * sequences with this charset\u0027s default replacement byte array.  The\n     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n     * control over the encoding process is required.\n     *\n     * @param  charset\n     *         The {@linkplain java.nio.charset.Charset} to be used to encode\n     *         the {@code String}\n     *\n     * @return  The resultant byte array\n     *\n     * @since  1.6\n     */\n    public byte[] getBytes(Charset charset) {\n        if (charset \u003d\u003d null) throw new NullPointerException();\n        return StringCoding.encode(charset, coder(), value);\n     }\n\n    /**\n     * Encodes this {@code String} into a sequence of bytes using the\n     * platform\u0027s default charset, storing the result into a new byte array.\n     *\n     * \u003cp\u003e The behavior of this method when this string cannot be encoded in\n     * the default charset is unspecified.  The {@link\n     * java.nio.charset.CharsetEncoder} class should be used when more control\n     * over the encoding process is required.\n     *\n     * @return  The resultant byte array\n     *\n     * @since      1.1\n     */\n    public byte[] getBytes() {\n        return StringCoding.encode(coder(), value);\n    }\n\n    /**\n     * Compares this string to the specified object.  The result is {@code\n     * true} if and only if the argument is not {@code null} and is a {@code\n     * String} object that represents the same sequence of characters as this\n     * object.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this \u003d\u003d anObject) {\n            return true;\n        }\n        if (anObject instanceof String) {\n            String aString \u003d (String)anObject;\n            if (coder() \u003d\u003d aString.coder()) {\n                return isLatin1() ? StringLatin1.equals(value, aString.value)\n                                  : StringUTF16.equals(value, aString.value);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Compares this string to the specified {@code StringBuffer}.  The result\n     * is {@code true} if and only if this {@code String} represents the same\n     * sequence of characters as the specified {@code StringBuffer}. This method\n     * synchronizes on the {@code StringBuffer}.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  sb\n     *         The {@code StringBuffer} to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of characters as the specified {@code StringBuffer},\n     *          {@code false} otherwise\n     *\n     * @since  1.4\n     */\n    public boolean contentEquals(StringBuffer sb) {\n        return contentEquals((CharSequence)sb);\n    }\n\n    private boolean nonSyncContentEquals(AbstractStringBuilder sb) {\n        int len \u003d length();\n        if (len !\u003d sb.length()) {\n            return false;\n        }\n        byte v1[] \u003d value;\n        byte v2[] \u003d sb.getValue();\n        if (coder() \u003d\u003d sb.getCoder()) {\n            int n \u003d v1.length;\n            for (int i \u003d 0; i \u003c n; i++) {\n                if (v1[i] !\u003d v2[i]) {\n                    return false;\n                }\n            }\n        } else {\n            if (!isLatin1()) {  // utf16 str and latin1 abs can never be \"equal\"\n                return false;\n            }\n            return StringUTF16.contentEquals(v1, v2, len);\n        }\n        return true;\n    }\n\n    /**\n     * Compares this string to the specified {@code CharSequence}.  The\n     * result is {@code true} if and only if this {@code String} represents the\n     * same sequence of char values as the specified sequence. Note that if the\n     * {@code CharSequence} is a {@code StringBuffer} then the method\n     * synchronizes on it.\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param  cs\n     *         The sequence to compare this {@code String} against\n     *\n     * @return  {@code true} if this {@code String} represents the same\n     *          sequence of char values as the specified sequence, {@code\n     *          false} otherwise\n     *\n     * @since  1.5\n     */\n    public boolean contentEquals(CharSequence cs) {\n        // Argument is a StringBuffer, StringBuilder\n        if (cs instanceof AbstractStringBuilder) {\n            if (cs instanceof StringBuffer) {\n                synchronized(cs) {\n                   return nonSyncContentEquals((AbstractStringBuilder)cs);\n                }\n            } else {\n                return nonSyncContentEquals((AbstractStringBuilder)cs);\n            }\n        }\n        // Argument is a String\n        if (cs instanceof String) {\n            return equals(cs);\n        }\n        // Argument is a generic CharSequence\n        int n \u003d cs.length();\n        if (n !\u003d length()) {\n            return false;\n        }\n        byte[] val \u003d this.value;\n        if (isLatin1()) {\n            for (int i \u003d 0; i \u003c n; i++) {\n                if ((val[i] \u0026 0xff) !\u003d cs.charAt(i)) {\n                    return false;\n                }\n            }\n        } else {\n            if (!StringUTF16.contentEquals(val, cs, n)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares this {@code String} to another {@code String}, ignoring case\n     * considerations.  Two strings are considered equal ignoring case if they\n     * are of the same length and corresponding characters in the two strings\n     * are equal ignoring case.\n     *\n     * \u003cp\u003e Two characters {@code c1} and {@code c2} are considered the same\n     * ignoring case if at least one of the following is true:\n     * \u003cul\u003e\n     *   \u003cli\u003e The two characters are the same (as compared by the\n     *        {@code \u003d\u003d} operator)\n     *   \u003cli\u003e Calling {@code Character.toLowerCase(Character.toUpperCase(char))}\n     *        on each character produces the same result\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account, and\n     * will result in unsatisfactory results for certain locales.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param  anotherString\n     *         The {@code String} to compare this {@code String} against\n     *\n     * @return  {@code true} if the argument is not {@code null} and it\n     *          represents an equivalent {@code String} ignoring case; {@code\n     *          false} otherwise\n     *\n     * @see  #equals(Object)\n     */\n    public boolean equalsIgnoreCase(String anotherString) {\n        return (this \u003d\u003d anotherString) ? true\n                : (anotherString !\u003d null)\n                \u0026\u0026 (anotherString.length() \u003d\u003d length())\n                \u0026\u0026 regionMatches(true, 0, anotherString, 0, length());\n    }\n\n    /**\n     * Compares two strings lexicographically.\n     * The comparison is based on the Unicode value of each character in\n     * the strings. The character sequence represented by this\n     * {@code String} object is compared lexicographically to the\n     * character sequence represented by the argument string. The result is\n     * a negative integer if this {@code String} object\n     * lexicographically precedes the argument string. The result is a\n     * positive integer if this {@code String} object lexicographically\n     * follows the argument string. The result is zero if the strings\n     * are equal; {@code compareTo} returns {@code 0} exactly when\n     * the {@link #equals(Object)} method would return {@code true}.\n     * \u003cp\u003e\n     * This is the definition of lexicographic ordering. If two strings are\n     * different, then either they have different characters at some index\n     * that is a valid index for both strings, or their lengths are different,\n     * or both. If they have different characters at one or more index\n     * positions, let \u003ci\u003ek\u003c/i\u003e be the smallest such index; then the string\n     * whose character at position \u003ci\u003ek\u003c/i\u003e has the smaller value, as\n     * determined by using the {@code \u003c} operator, lexicographically precedes the\n     * other string. In this case, {@code compareTo} returns the\n     * difference of the two character values at position {@code k} in\n     * the two string -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(k)-anotherString.charAt(k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * If there is no index position at which they differ, then the shorter\n     * string lexicographically precedes the longer string. In this case,\n     * {@code compareTo} returns the difference of the lengths of the\n     * strings -- that is, the value:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.length()-anotherString.length()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003eFor finer-grained String comparison, refer to\n     * {@link java.text.Collator}.\n     *\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        byte v1[] \u003d value;\n        byte v2[] \u003d anotherString.value;\n        if (coder() \u003d\u003d anotherString.coder()) {\n            return isLatin1() ? StringLatin1.compareTo(v1, v2)\n                              : StringUTF16.compareTo(v1, v2);\n        }\n        return isLatin1() ? StringLatin1.compareToUTF16(v1, v2)\n                          : StringUTF16.compareToLatin1(v1, v2);\n     }\n\n    /**\n     * A Comparator that orders {@code String} objects as by\n     * {@code compareToIgnoreCase}. This comparator is serializable.\n     * \u003cp\u003e\n     * Note that this Comparator does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public static final Comparator\u003cString\u003e CASE_INSENSITIVE_ORDER\n                                         \u003d new CaseInsensitiveComparator();\n    private static class CaseInsensitiveComparator\n            implements Comparator\u003cString\u003e, java.io.Serializable {\n        // use serialVersionUID from JDK 1.2.2 for interoperability\n        private static final long serialVersionUID \u003d 8575799808933029326L;\n\n        public int compare(String s1, String s2) {\n            byte v1[] \u003d s1.value;\n            byte v2[] \u003d s2.value;\n            if (s1.coder() \u003d\u003d s2.coder()) {\n                return s1.isLatin1() ? StringLatin1.compareToCI(v1, v2)\n                                     : StringUTF16.compareToCI(v1, v2);\n            }\n            return s1.isLatin1() ? StringLatin1.compareToCI_UTF16(v1, v2)\n                                 : StringUTF16.compareToCI_Latin1(v1, v2);\n        }\n\n        /** Replaces the de-serialized object. */\n        private Object readResolve() { return CASE_INSENSITIVE_ORDER; }\n    }\n\n    /**\n     * Compares two strings lexicographically, ignoring case\n     * differences. This method returns an integer whose sign is that of\n     * calling {@code compareTo} with normalized versions of the strings\n     * where case differences have been eliminated by calling\n     * {@code Character.toLowerCase(Character.toUpperCase(character))} on\n     * each character.\n     * \u003cp\u003e\n     * Note that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in an unsatisfactory ordering for certain locales.\n     * The {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   str   the {@code String} to be compared.\n     * @return  a negative integer, zero, or a positive integer as the\n     *          specified String is greater than, equal to, or less\n     *          than this String, ignoring case considerations.\n     * @see     java.text.Collator\n     * @since   1.2\n     */\n    public int compareToIgnoreCase(String str) {\n        return CASE_INSENSITIVE_ORDER.compare(this, str);\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument other. The result is true if these substrings\n     * represent identical character sequences. The substring of this\n     * {@code String} object to be compared begins at index {@code toffset}\n     * and has length {@code len}. The substring of other to be compared\n     * begins at index {@code ooffset} and has length {@code len}. The\n     * result is {@code false} if and only if at least one of the following\n     * is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003eThere is some nonnegative integer \u003ci\u003ek\u003c/i\u003e less than {@code len}\n     * such that:\n     * {@code this.charAt(toffset + }\u003ci\u003ek\u003c/i\u003e{@code ) !\u003d other.charAt(ooffset + }\n     * \u003ci\u003ek\u003c/i\u003e{@code )}\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account.  The\n     * {@link java.text.Collator} class provides locale-sensitive comparison.\n     *\n     * @param   toffset   the starting offset of the subregion in this string.\n     * @param   other     the string argument.\n     * @param   ooffset   the starting offset of the subregion in the string\n     *                    argument.\n     * @param   len       the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          exactly matches the specified subregion of the string argument;\n     *          {@code false} otherwise.\n     */\n    public boolean regionMatches(int toffset, String other, int ooffset, int len) {\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0) ||\n             (toffset \u003e (long)length() - len) ||\n             (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        if (coder() \u003d\u003d other.coder()) {\n            if (!isLatin1() \u0026\u0026 (len \u003e 0)) {\n                toffset \u003d toffset \u003c\u003c 1;\n                ooffset \u003d ooffset \u003c\u003c 1;\n                len \u003d len \u003c\u003c 1;\n            }\n            while (len-- \u003e 0) {\n                if (tv[toffset++] !\u003d ov[ooffset++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (coder() \u003d\u003d LATIN1) {\n                while (len-- \u003e 0) {\n                    if (StringLatin1.getChar(tv, toffset++) !\u003d\n                        StringUTF16.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            } else {\n                while (len-- \u003e 0) {\n                    if (StringUTF16.getChar(tv, toffset++) !\u003d\n                        StringLatin1.getChar(ov, ooffset++)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if two string regions are equal.\n     * \u003cp\u003e\n     * A substring of this {@code String} object is compared to a substring\n     * of the argument {@code other}. The result is {@code true} if these\n     * substrings represent character sequences that are the same, ignoring\n     * case if and only if {@code ignoreCase} is true. The substring of\n     * this {@code String} object to be compared begins at index\n     * {@code toffset} and has length {@code len}. The substring of\n     * {@code other} to be compared begins at index {@code ooffset} and\n     * has length {@code len}. The result is {@code false} if and only if\n     * at least one of the following is true:\n     * \u003cul\u003e\u003cli\u003e{@code toffset} is negative.\n     * \u003cli\u003e{@code ooffset} is negative.\n     * \u003cli\u003e{@code toffset+len} is greater than the length of this\n     * {@code String} object.\n     * \u003cli\u003e{@code ooffset+len} is greater than the length of the other\n     * argument.\n     * \u003cli\u003e{@code ignoreCase} is {@code false} and there is some nonnegative\n     * integer \u003ci\u003ek\u003c/i\u003e less than {@code len} such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(toffset+k) !\u003d other.charAt(ooffset+k)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cli\u003e{@code ignoreCase} is {@code true} and there is some nonnegative\n     * integer \u003ci\u003ek\u003c/i\u003e less than {@code len} such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Character.toLowerCase(Character.toUpperCase(this.charAt(toffset+k))) !\u003d\n     Character.toLowerCase(Character.toUpperCase(other.charAt(ooffset+k)))\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003eNote that this method does \u003cem\u003enot\u003c/em\u003e take locale into account,\n     * and will result in unsatisfactory results for certain locales when\n     * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class\n     * provides locale-sensitive comparison.\n     *\n     * @param   ignoreCase   if {@code true}, ignore case when comparing\n     *                       characters.\n     * @param   toffset      the starting offset of the subregion in this\n     *                       string.\n     * @param   other        the string argument.\n     * @param   ooffset      the starting offset of the subregion in the string\n     *                       argument.\n     * @param   len          the number of characters to compare.\n     * @return  {@code true} if the specified subregion of this string\n     *          matches the specified subregion of the string argument;\n     *          {@code false} otherwise. Whether the matching is exact\n     *          or case insensitive depends on the {@code ignoreCase}\n     *          argument.\n     */\n    public boolean regionMatches(boolean ignoreCase, int toffset,\n            String other, int ooffset, int len) {\n        if (!ignoreCase) {\n            return regionMatches(toffset, other, ooffset, len);\n        }\n        // Note: toffset, ooffset, or len might be near -1\u003e\u003e\u003e1.\n        if ((ooffset \u003c 0) || (toffset \u003c 0)\n                || (toffset \u003e (long)length() - len)\n                || (ooffset \u003e (long)other.length() - len)) {\n            return false;\n        }\n        byte tv[] \u003d value;\n        byte ov[] \u003d other.value;\n        if (coder() \u003d\u003d other.coder()) {\n            return isLatin1()\n              ? StringLatin1.regionMatchesCI(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI(tv, toffset, ov, ooffset, len);\n        }\n        return isLatin1()\n              ? StringLatin1.regionMatchesCI_UTF16(tv, toffset, ov, ooffset, len)\n              : StringUTF16.regionMatchesCI_Latin1(tv, toffset, ov, ooffset, len);\n    }\n\n    /**\n     * Tests if the substring of this string beginning at the\n     * specified index starts with the specified prefix.\n     *\n     * @param   prefix    the prefix.\n     * @param   toffset   where to begin looking in this string.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the substring of this object starting\n     *          at index {@code toffset}; {@code false} otherwise.\n     *          The result is {@code false} if {@code toffset} is\n     *          negative or greater than the length of this\n     *          {@code String} object; otherwise the result is the same\n     *          as the result of the expression\n     *          \u003cpre\u003e\n     *          this.substring(toffset).startsWith(prefix)\n     *          \u003c/pre\u003e\n     */\n    public boolean startsWith(String prefix, int toffset) {\n        // Note: toffset might be near -1\u003e\u003e\u003e1.\n        if (toffset \u003c 0 || toffset \u003e length() - prefix.length()) {\n            return false;\n        }\n        byte ta[] \u003d value;\n        byte pa[] \u003d prefix.value;\n        int po \u003d 0;\n        int pc \u003d pa.length;\n        if (coder() \u003d\u003d prefix.coder()) {\n            int to \u003d isLatin1() ? toffset : toffset \u003c\u003c 1;\n            while (po \u003c pc) {\n                if (ta[to++] !\u003d pa[po++]) {\n                    return false;\n                }\n            }\n        } else {\n            if (isLatin1()) {  // \u0026\u0026 pcoder \u003d\u003d UTF16\n                return false;\n            }\n            // coder \u003d\u003d UTF16 \u0026\u0026 pcoder \u003d\u003d LATIN1)\n            while (po \u003c pc) {\n                if (StringUTF16.getChar(ta, toffset++) !\u003d (pa[po++] \u0026 0xff)) {\n                    return false;\n               }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     *\n     * @param   prefix   the prefix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a prefix of the character sequence represented by\n     *          this string; {@code false} otherwise.\n     *          Note also that {@code true} will be returned if the\n     *          argument is an empty string or is equal to this\n     *          {@code String} object as determined by the\n     *          {@link #equals(Object)} method.\n     * @since   1.0\n     */\n    public boolean startsWith(String prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     *\n     * @param   suffix   the suffix.\n     * @return  {@code true} if the character sequence represented by the\n     *          argument is a suffix of the character sequence represented by\n     *          this object; {@code false} otherwise. Note that the\n     *          result will be {@code true} if the argument is the\n     *          empty string or is equal to this {@code String} object\n     *          as determined by the {@link #equals(Object)} method.\n     */\n    public boolean endsWith(String suffix) {\n        return startsWith(suffix, length() - suffix.length());\n    }\n\n    /**\n     * Returns a hash code for this string. The hash code for a\n     * {@code String} object is computed as\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * using {@code int} arithmetic, where {@code s[i]} is the\n     * \u003ci\u003ei\u003c/i\u003eth character of the string, {@code n} is the length of\n     * the string, and {@code ^} indicates exponentiation.\n     * (The hash value of the empty string is zero.)\n     *\n     * @return  a hash code value for this object.\n     */\n    public int hashCode() {\n        int h \u003d hash;\n        if (h \u003d\u003d 0 \u0026\u0026 value.length \u003e 0) {\n            hash \u003d h \u003d isLatin1() ? StringLatin1.hashCode(value)\n                                  : StringUTF16.hashCode(value);\n        }\n        return h;\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of\n     * the specified character. If a character with value\n     * {@code ch} occurs in the character sequence represented by\n     * this {@code String} object, then the index (in Unicode\n     * code units) of the first such occurrence is returned. For\n     * values of {@code ch} in the range from 0 to 0xFFFF\n     * (inclusive), this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int indexOf(int ch) {\n        return indexOf(ch, 0);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified character, starting the search at the specified index.\n     * \u003cp\u003e\n     * If a character with value {@code ch} occurs in the\n     * character sequence represented by this {@code String}\n     * object at an index no smaller than {@code fromIndex}, then\n     * the index of the first such occurrence is returned. For values\n     * of {@code ch} in the range from 0 to 0xFFFF (inclusive),\n     * this is the smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * smallest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026gt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or after position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003e\n     * There is no restriction on the value of {@code fromIndex}. If it\n     * is negative, it has the same effect as if it were zero: this entire\n     * string may be searched. If it is greater than the length of this\n     * string, it has the same effect as if it were equal to the length of\n     * this string: {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the first occurrence of the character in the\n     *          character sequence represented by this object that is greater\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur.\n     */\n    public int indexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex)\n                          : StringUTF16.indexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character. For values of {@code ch} in the\n     * range from 0 to 0xFFFF (inclusive), the index (in Unicode code\n     * units) returned is the largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true.  In either case, if no such character occurs in this\n     * string, then {@code -1} is returned.  The\n     * {@code String} is searched backwards starting at the last\n     * character.\n     *\n     * @param   ch   a character (Unicode code point).\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object, or\n     *          {@code -1} if the character does not occur.\n     */\n    public int lastIndexOf(int ch) {\n        return lastIndexOf(ch, length() - 1);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of\n     * the specified character, searching backward starting at the\n     * specified index. For values of {@code ch} in the range\n     * from 0 to 0xFFFF (inclusive), the index returned is the largest\n     * value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.charAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. For other values of {@code ch}, it is the\n     * largest value \u003ci\u003ek\u003c/i\u003e such that:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * (this.codePointAt(\u003ci\u003ek\u003c/i\u003e) \u003d\u003d ch) {@code \u0026\u0026} (\u003ci\u003ek\u003c/i\u003e \u0026lt;\u003d fromIndex)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * is true. In either case, if no such character occurs in this\n     * string at or before position {@code fromIndex}, then\n     * {@code -1} is returned.\n     *\n     * \u003cp\u003eAll indices are specified in {@code char} values\n     * (Unicode code units).\n     *\n     * @param   ch          a character (Unicode code point).\n     * @param   fromIndex   the index to start the search from. There is no\n     *          restriction on the value of {@code fromIndex}. If it is\n     *          greater than or equal to the length of this string, it has\n     *          the same effect as if it were equal to one less than the\n     *          length of this string: this entire string may be searched.\n     *          If it is negative, it has the same effect as if it were -1:\n     *          -1 is returned.\n     * @return  the index of the last occurrence of the character in the\n     *          character sequence represented by this object that is less\n     *          than or equal to {@code fromIndex}, or {@code -1}\n     *          if the character does not occur before that point.\n     */\n    public int lastIndexOf(int ch, int fromIndex) {\n        return isLatin1() ? StringLatin1.lastIndexOf(value, ch, fromIndex)\n                          : StringUTF16.lastIndexOf(value, ch, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the first occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str) {\n        if (coder() \u003d\u003d str.coder()) {\n            return isLatin1() ? StringLatin1.indexOf(value, str.value)\n                              : StringUTF16.indexOf(value, str.value);\n        }\n        if (coder() \u003d\u003d LATIN1) {  // str.coder \u003d\u003d UTF16\n            return -1;\n        }\n        return StringUTF16.indexOfLatin1(value, str.value);\n    }\n\n    /**\n     * Returns the index within this string of the first occurrence of the\n     * specified substring, starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the smallest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003e\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index from which to start the search.\n     * @return  the index of the first occurrence of the specified substring,\n     *          starting at the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int indexOf(String str, int fromIndex) {\n        return indexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src       the characters being searched.\n     * @param   srcCoder  the coder of the source string.\n     * @param   srcCount  length of the source string.\n     * @param   tgtStr    the characters being searched for.\n     * @param   fromIndex the index to begin searching from.\n     */\n    static int indexOf(byte[] src, byte srcCoder, int srcCount,\n                       String tgtStr, int fromIndex) {\n        byte[] tgt    \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount  \u003d tgtStr.length();\n\n        if (fromIndex \u003e\u003d srcCount) {\n            return (tgtCount \u003d\u003d 0 ? srcCount : -1);\n        }\n        if (fromIndex \u003c 0) {\n            fromIndex \u003d 0;\n        }\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (tgtCount \u003e srcCount) {\n            return -1;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.indexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.indexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    //  \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1) {\n        return StringUTF16.indexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring.  The last occurrence of the empty string \"\"\n     * is considered to occur at the index value {@code this.length()}.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     * this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str   the substring to search for.\n     * @return  the index of the last occurrence of the specified substring,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str) {\n        return lastIndexOf(str, length());\n    }\n\n    /**\n     * Returns the index within this string of the last occurrence of the\n     * specified substring, searching backward starting at the specified index.\n     *\n     * \u003cp\u003eThe returned index is the largest value {@code k} for which:\n     * \u003cpre\u003e{@code\n     *     k \u003c\u003d Math.min(fromIndex, this.length()) \u0026\u0026\n     *                   this.startsWith(str, k)\n     * }\u003c/pre\u003e\n     * If no such value of {@code k} exists, then {@code -1} is returned.\n     *\n     * @param   str         the substring to search for.\n     * @param   fromIndex   the index to start the search from.\n     * @return  the index of the last occurrence of the specified substring,\n     *          searching backward from the specified index,\n     *          or {@code -1} if there is no such occurrence.\n     */\n    public int lastIndexOf(String str, int fromIndex) {\n        return lastIndexOf(value, coder(), length(), str, fromIndex);\n    }\n\n    /**\n     * Code shared by String and AbstractStringBuilder to do searches. The\n     * source is the character array being searched, and the target\n     * is the string being searched for.\n     *\n     * @param   src         the characters being searched.\n     * @param   srcCoder    coder handles the mapping between bytes/chars\n     * @param   srcCount    count of the source string.\n     * @param   tgt         the characters being searched for.\n     * @param   fromIndex   the index to begin searching from.\n     */\n    static int lastIndexOf(byte[] src, byte srcCoder, int srcCount,\n                           String tgtStr, int fromIndex) {\n        byte[] tgt \u003d tgtStr.value;\n        byte tgtCoder \u003d tgtStr.coder();\n        int tgtCount \u003d tgtStr.length();\n        /*\n         * Check arguments; return immediately where possible. For\n         * consistency, don\u0027t check for null str.\n         */\n        int rightIndex \u003d srcCount - tgtCount;\n        if (fromIndex \u003e rightIndex) {\n            fromIndex \u003d rightIndex;\n        }\n        if (fromIndex \u003c 0) {\n            return -1;\n        }\n        /* Empty string always matches. */\n        if (tgtCount \u003d\u003d 0) {\n            return fromIndex;\n        }\n        if (srcCoder \u003d\u003d tgtCoder) {\n            return srcCoder \u003d\u003d LATIN1\n                ? StringLatin1.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex)\n                : StringUTF16.lastIndexOf(src, srcCount, tgt, tgtCount, fromIndex);\n        }\n        if (srcCoder \u003d\u003d LATIN1) {    // \u0026\u0026 tgtCoder \u003d\u003d UTF16\n            return -1;\n        }\n        // srcCoder \u003d\u003d UTF16 \u0026\u0026 tgtCoder \u003d\u003d LATIN1\n        return StringUTF16.lastIndexOfLatin1(src, srcCount, tgt, tgtCount, fromIndex);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins with the character at the specified index and\n     * extends to the end of this string. \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"unhappy\".substring(2) returns \"happy\"\n     * \"Harbison\".substring(3) returns \"bison\"\n     * \"emptiness\".substring(9) returns \"\" (an empty string)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @return     the specified substring.\n     * @exception  IndexOutOfBoundsException  if\n     *             {@code beginIndex} is negative or larger than the\n     *             length of this {@code String} object.\n     */\n    public String substring(int beginIndex) {\n        if (beginIndex \u003c 0) {\n            throw new StringIndexOutOfBoundsException(beginIndex);\n        }\n        int subLen \u003d length() - beginIndex;\n        if (subLen \u003c 0) {\n            throw new StringIndexOutOfBoundsException(subLen);\n        }\n        if (beginIndex \u003d\u003d 0) {\n            return this;\n        }\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a string that is a substring of this string. The\n     * substring begins at the specified {@code beginIndex} and\n     * extends to the character at index {@code endIndex - 1}.\n     * Thus the length of the substring is {@code endIndex-beginIndex}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"hamburger\".substring(4, 8) returns \"urge\"\n     * \"smiles\".substring(1, 5) returns \"mile\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      beginIndex   the beginning index, inclusive.\n     * @param      endIndex     the ending index, exclusive.\n     * @return     the specified substring.\n     * @exception  IndexOutOfBoundsException  if the\n     *             {@code beginIndex} is negative, or\n     *             {@code endIndex} is larger than the length of\n     *             this {@code String} object, or\n     *             {@code beginIndex} is larger than\n     *             {@code endIndex}.\n     */\n    public String substring(int beginIndex, int endIndex) {\n        int length \u003d length();\n        checkBoundsBeginEnd(beginIndex, endIndex, length);\n        int subLen \u003d endIndex - beginIndex;\n        if (beginIndex \u003d\u003d 0 \u0026\u0026 endIndex \u003d\u003d length) {\n            return this;\n        }\n        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                          : StringUTF16.newString(value, beginIndex, subLen);\n    }\n\n    /**\n     * Returns a character sequence that is a subsequence of this sequence.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.subSequence(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * behaves in exactly the same way as the invocation\n     *\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * str.substring(begin,\u0026nbsp;end)\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method is defined so that the {@code String} class can implement\n     * the {@link CharSequence} interface.\n     *\n     * @param   beginIndex   the begin index, inclusive.\n     * @param   endIndex     the end index, exclusive.\n     * @return  the specified subsequence.\n     *\n     * @throws  IndexOutOfBoundsException\n     *          if {@code beginIndex} or {@code endIndex} is negative,\n     *          if {@code endIndex} is greater than {@code length()},\n     *          or if {@code beginIndex} is greater than {@code endIndex}\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public CharSequence subSequence(int beginIndex, int endIndex) {\n        return this.substring(beginIndex, endIndex);\n    }\n\n    /**\n     * Concatenates the specified string to the end of this string.\n     * \u003cp\u003e\n     * If the length of the argument string is {@code 0}, then this\n     * {@code String} object is returned. Otherwise, a\n     * {@code String} object is returned that represents a character\n     * sequence that is the concatenation of the character sequence\n     * represented by this {@code String} object and the character\n     * sequence represented by the argument string.\u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"cares\".concat(\"s\") returns \"caress\"\n     * \"to\".concat(\"get\").concat(\"her\") returns \"together\"\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   str   the {@code String} that is concatenated to the end\n     *                of this {@code String}.\n     * @return  a string that represents the concatenation of this object\u0027s\n     *          characters followed by the string argument\u0027s characters.\n     */\n    public String concat(String str) {\n        if (str.isEmpty()) {\n            return this;\n        }\n        if (coder() \u003d\u003d str.coder()) {\n            byte[] val \u003d this.value;\n            byte[] oval \u003d str.value;\n            int len \u003d val.length + oval.length;\n            byte[] buf \u003d Arrays.copyOf(val, len);\n            System.arraycopy(oval, 0, buf, val.length, oval.length);\n            return new String(buf, coder);\n        }\n        int len \u003d length();\n        int olen \u003d str.length();\n        byte[] buf \u003d StringUTF16.newBytesFor(len + olen);\n        getBytes(buf, 0, UTF16);\n        str.getBytes(buf, len, UTF16);\n        return new String(buf, UTF16);\n    }\n\n    /**\n     * Returns a string resulting from replacing all occurrences of\n     * {@code oldChar} in this string with {@code newChar}.\n     * \u003cp\u003e\n     * If the character {@code oldChar} does not occur in the\n     * character sequence represented by this {@code String} object,\n     * then a reference to this {@code String} object is returned.\n     * Otherwise, a {@code String} object is returned that\n     * represents a character sequence identical to the character sequence\n     * represented by this {@code String} object, except that every\n     * occurrence of {@code oldChar} is replaced by an occurrence\n     * of {@code newChar}.\n     * \u003cp\u003e\n     * Examples:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * \"mesquite in your cellar\".replace(\u0027e\u0027, \u0027o\u0027)\n     *         returns \"mosquito in your collar\"\n     * \"the war of baronets\".replace(\u0027r\u0027, \u0027y\u0027)\n     *         returns \"the way of bayonets\"\n     * \"sparring with a purple porpoise\".replace(\u0027p\u0027, \u0027t\u0027)\n     *         returns \"starring with a turtle tortoise\"\n     * \"JonL\".replace(\u0027q\u0027, \u0027x\u0027) returns \"JonL\" (no change)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param   oldChar   the old character.\n     * @param   newChar   the new character.\n     * @return  a string derived from this string by replacing every\n     *          occurrence of {@code oldChar} with {@code newChar}.\n     */\n    public String replace(char oldChar, char newChar) {\n        if (oldChar !\u003d newChar) {\n            String ret \u003d isLatin1() ? StringLatin1.replace(value, oldChar, newChar)\n                                    : StringUTF16.replace(value, oldChar, newChar);\n            if (ret !\u003d null) {\n                return ret;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Tells whether or not this string matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .matches(}\u003ci\u003eregex\u003c/i\u003e{@code )} yields exactly the\n     * same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#matches(String,CharSequence)\n     * matches(\u003ci\u003eregex\u003c/i\u003e, \u003ci\u003estr\u003c/i\u003e)}\n     * \u003c/blockquote\u003e\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     *\n     * @return  {@code true} if, and only if, this string matches the\n     *          given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public boolean matches(String regex) {\n        return Pattern.matches(regex, this);\n    }\n\n    /**\n     * Returns true if and only if this string contains the specified\n     * sequence of char values.\n     *\n     * @param s the sequence to search for\n     * @return true if this string contains {@code s}, false otherwise\n     * @since 1.5\n     */\n    public boolean contains(CharSequence s) {\n        return indexOf(s.toString()) \u003e\u003d 0;\n    }\n\n    /**\n     * Replaces the first substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceFirst(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceFirst replaceFirst}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceFirst}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for the first match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public String replaceFirst(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceFirst(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e with the\n     * given replacement.\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr\u003c/i\u003e{@code .replaceAll(}\u003ci\u003eregex\u003c/i\u003e{@code ,} \u003ci\u003erepl\u003c/i\u003e{@code )}\n     * yields exactly the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(\u003ci\u003estr\u003c/i\u003e).{@link\n     * java.util.regex.Matcher#replaceAll replaceAll}(\u003ci\u003erepl\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\u003cp\u003e\n     * Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the\n     * replacement string may cause the results to be different than if it were\n     * being treated as a literal replacement string; see\n     * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.\n     * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special\n     * meaning of these characters, if desired.\n     *\n     * @param   regex\n     *          the regular expression to which this string is to be matched\n     * @param   replacement\n     *          the string to be substituted for each match\n     *\n     * @return  The resulting {@code String}\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public String replaceAll(String regex, String replacement) {\n        return Pattern.compile(regex).matcher(this).replaceAll(replacement);\n    }\n\n    /**\n     * Replaces each substring of this string that matches the literal target\n     * sequence with the specified literal replacement sequence. The\n     * replacement proceeds from the beginning of the string to the end, for\n     * example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in\n     * \"ba\" rather than \"ab\".\n     *\n     * @param  target The sequence of char values to be replaced\n     * @param  replacement The replacement sequence of char values\n     * @return  The resulting string\n     * @since 1.5\n     */\n    public String replace(CharSequence target, CharSequence replacement) {\n        String tgtStr \u003d target.toString();\n        String replStr \u003d replacement.toString();\n        int j \u003d indexOf(tgtStr);\n        if (j \u003c 0) {\n            return this;\n        }\n        int tgtLen \u003d tgtStr.length();\n        int tgtLen1 \u003d Math.max(tgtLen, 1);\n        int thisLen \u003d length();\n\n        int newLenHint \u003d thisLen - tgtLen + replStr.length();\n        if (newLenHint \u003c 0) {\n            throw new OutOfMemoryError();\n        }\n        StringBuilder sb \u003d new StringBuilder(newLenHint);\n        int i \u003d 0;\n        do {\n            sb.append(this, i, j).append(replStr);\n            i \u003d j + tgtLen;\n        } while (j \u003c thisLen \u0026\u0026 (j \u003d indexOf(tgtStr, j + tgtLen1)) \u003e 0);\n        return sb.append(this, i, thisLen).toString();\n    }\n\n    /**\n     * Splits this string around matches of the given\n     * \u003ca href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e The array returned by this method contains each substring of this\n     * string that is terminated by another substring that matches the given\n     * expression or is terminated by the end of the string.  The substrings in\n     * the array are in the order in which they occur in this string.  If the\n     * expression does not match any part of the input then the resulting array\n     * has just one element, namely this string.\n     *\n     * \u003cp\u003e When there is a positive-width match at the beginning of this\n     * string then an empty leading substring is included at the beginning\n     * of the resulting array. A zero-width match at the beginning however\n     * never produces such empty leading substring.\n     *\n     * \u003cp\u003e The {@code limit} parameter controls the number of times the\n     * pattern is applied and therefore affects the length of the resulting\n     * array.\n     * \u003cul\u003e\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is positive then the pattern will be applied\n     *    at most \u003ci\u003elimit\u003c/i\u003e\u0026nbsp;-\u0026nbsp;1 times, the array\u0027s length will be\n     *    no greater than \u003ci\u003elimit\u003c/i\u003e, and the array\u0027s last entry will contain\n     *    all input beyond the last matched delimiter.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is zero then the pattern will be applied as\n     *    many times as possible, the array can have any length, and trailing\n     *    empty strings will be discarded.\u003c/p\u003e\u003c/li\u003e\n     *\n     *    \u003cli\u003e\u003cp\u003e\n     *    If the \u003ci\u003elimit\u003c/i\u003e is negative then the pattern will be applied\n     *    as many times as possible and the array can have any length.\u003c/p\u003e\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the\n     * following results with these parameters:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit example showing regex, limit, and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *     \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eLimit\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and:foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- : --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" rowspan\u003d\"3\" style\u003d\"font-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e5\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e-2\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\", \"\", \"\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003c!-- o --\u003e\n     *     \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:right; padding-right:1em\"\u003e0\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     * \u003cp\u003e An invocation of this method of the form\n     * \u003ci\u003estr.\u003c/i\u003e{@code split(}\u003ci\u003eregex\u003c/i\u003e{@code ,}\u0026nbsp;\u003ci\u003en\u003c/i\u003e{@code )}\n     * yields the same result as the expression\n     *\n     * \u003cblockquote\u003e\n     * \u003ccode\u003e\n     * {@link java.util.regex.Pattern}.{@link\n     * java.util.regex.Pattern#compile compile}(\u003ci\u003eregex\u003c/i\u003e).{@link\n     * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(\u003ci\u003estr\u003c/i\u003e,\u0026nbsp;\u003ci\u003en\u003c/i\u003e)\n     * \u003c/code\u003e\n     * \u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @param  limit\n     *         the result threshold, as described above\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public String[] split(String regex, int limit) {\n        /* fastpath if the regex is a\n         (1)one-char String and this character is not one of the\n            RegEx\u0027s meta characters \".$|()[{^?*+\\\\\", or\n         (2)two-char String and the first char is the backslash and\n            the second is not the ascii digit or ascii letter.\n         */\n        char ch \u003d 0;\n        if (((regex.length() \u003d\u003d 1 \u0026\u0026\n             \".$|()[{^?*+\\\\\".indexOf(ch \u003d regex.charAt(0)) \u003d\u003d -1) ||\n             (regex.length() \u003d\u003d 2 \u0026\u0026\n              regex.charAt(0) \u003d\u003d \u0027\\\\\u0027 \u0026\u0026\n              (((ch \u003d regex.charAt(1))-\u00270\u0027)|(\u00279\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027a\u0027)|(\u0027z\u0027-ch)) \u003c 0 \u0026\u0026\n              ((ch-\u0027A\u0027)|(\u0027Z\u0027-ch)) \u003c 0)) \u0026\u0026\n            (ch \u003c Character.MIN_HIGH_SURROGATE ||\n             ch \u003e Character.MAX_LOW_SURROGATE))\n        {\n            int off \u003d 0;\n            int next \u003d 0;\n            boolean limited \u003d limit \u003e 0;\n            ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n            while ((next \u003d indexOf(ch, off)) !\u003d -1) {\n                if (!limited || list.size() \u003c limit - 1) {\n                    list.add(substring(off, next));\n                    off \u003d next + 1;\n                } else {    // last one\n                    //assert (list.size() \u003d\u003d limit - 1);\n                    int last \u003d length();\n                    list.add(substring(off, last));\n                    off \u003d last;\n                    break;\n                }\n            }\n            // If no match was found, return this\n            if (off \u003d\u003d 0)\n                return new String[]{this};\n\n            // Add remaining segment\n            if (!limited || list.size() \u003c limit)\n                list.add(substring(off, length()));\n\n            // Construct result\n            int resultSize \u003d list.size();\n            if (limit \u003d\u003d 0) {\n                while (resultSize \u003e 0 \u0026\u0026 list.get(resultSize - 1).isEmpty()) {\n                    resultSize--;\n                }\n            }\n            String[] result \u003d new String[resultSize];\n            return list.subList(0, resultSize).toArray(result);\n        }\n        return Pattern.compile(regex).split(this, limit);\n    }\n\n    /**\n     * Splits this string around matches of the given \u003ca\n     * href\u003d\"../util/regex/Pattern.html#sum\"\u003eregular expression\u003c/a\u003e.\n     *\n     * \u003cp\u003e This method works as if by invoking the two-argument {@link\n     * #split(String, int) split} method with the given expression and a limit\n     * argument of zero.  Trailing empty strings are therefore not included in\n     * the resulting array.\n     *\n     * \u003cp\u003e The string {@code \"boo:and:foo\"}, for example, yields the following\n     * results with these expressions:\n     *\n     * \u003cblockquote\u003e\u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eSplit examples showing regex and result\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eRegex\u003c/th\u003e\n     *  \u003cth scope\u003d\"col\"\u003eResult\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003e:\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"boo\", \"and\", \"foo\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\" style\u003d\"text-weight:normal\"\u003eo\u003c/th\u003e\n     *     \u003ctd\u003e{@code { \"b\", \"\", \":and:f\" }}\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\u003c/blockquote\u003e\n     *\n     *\n     * @param  regex\n     *         the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting this string\n     *          around matches of the given regular expression\n     *\n     * @throws  PatternSyntaxException\n     *          if the regular expression\u0027s syntax is invalid\n     *\n     * @see java.util.regex.Pattern\n     *\n     * @since 1.4\n     * @spec JSR-51\n     */\n    public String[] split(String regex) {\n        return split(regex, 0);\n    }\n\n    /**\n     * Returns a new String composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of\n     * the specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     String message \u003d String.join(\"-\", \"Java\", \"is\", \"cool\");\n     *     // message returned is: \"Java-is-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an element is null, then {@code \"null\"} is added.\n     *\n     * @param  delimiter the delimiter that separates each element\n     * @param  elements the elements to join together.\n     *\n     * @return a new {@code String} that is composed of the {@code elements}\n     *         separated by the {@code delimiter}\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter, CharSequence... elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        // Number of elements not likely worth Arrays.stream overhead.\n        StringJoiner joiner \u003d new StringJoiner(delimiter);\n        for (CharSequence cs: elements) {\n            joiner.add(cs);\n        }\n        return joiner.toString();\n    }\n\n    /**\n     * Returns a new {@code String} composed of copies of the\n     * {@code CharSequence elements} joined together with a copy of the\n     * specified {@code delimiter}.\n     *\n     * \u003cblockquote\u003eFor example,\n     * \u003cpre\u003e{@code\n     *     List\u003cString\u003e strings \u003d List.of(\"Java\", \"is\", \"cool\");\n     *     String message \u003d String.join(\" \", strings);\n     *     //message returned is: \"Java is cool\"\n     *\n     *     Set\u003cString\u003e strings \u003d\n     *         new LinkedHashSet\u003c\u003e(List.of(\"Java\", \"is\", \"very\", \"cool\"));\n     *     String message \u003d String.join(\"-\", strings);\n     *     //message returned is: \"Java-is-very-cool\"\n     * }\u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * Note that if an individual element is {@code null}, then {@code \"null\"} is added.\n     *\n     * @param  delimiter a sequence of characters that is used to separate each\n     *         of the {@code elements} in the resulting {@code String}\n     * @param  elements an {@code Iterable} that will have its {@code elements}\n     *         joined together.\n     *\n     * @return a new {@code String} that is composed from the {@code elements}\n     *         argument\n     *\n     * @throws NullPointerException If {@code delimiter} or {@code elements}\n     *         is {@code null}\n     *\n     * @see    #join(CharSequence,CharSequence...)\n     * @see    java.util.StringJoiner\n     * @since 1.8\n     */\n    public static String join(CharSequence delimiter,\n            Iterable\u003c? extends CharSequence\u003e elements) {\n        Objects.requireNonNull(delimiter);\n        Objects.requireNonNull(elements);\n        StringJoiner joiner \u003d new StringJoiner(delimiter);\n        for (CharSequence cs: elements) {\n            joiner.add(cs);\n        }\n        return joiner.toString();\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the given {@code Locale}.  Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\n     * {@code String} may be a different length than the original {@code String}.\n     * \u003cp\u003e\n     * Examples of lowercase  mappings are in the following table:\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eLowercase mapping examples showing language code of locale, upper case, lower case, and description\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0130\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0069\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I with dot above -\u0026gt; small letter i\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0049\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0131\u003c/td\u003e\n     *   \u003ctd\u003ecapital letter I -\u0026gt; small letter dotless i \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFrench Fries\u003c/th\u003e\n     *   \u003ctd\u003efrench fries\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\n     *       \u0026Iota;\u0026Chi;\u0026Theta;\u0026Upsilon;\u0026Sigma;\u003c/th\u003e\n     *   \u003ctd\u003e\u0026iota;\u0026chi;\u0026theta;\u0026upsilon;\u0026sigma;\u003c/td\u003e\n     *   \u003ctd\u003elowercased all chars in String\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toUpperCase(Locale)\n     * @since   1.1\n     */\n    public String toLowerCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)\n                          : StringUTF16.toLowerCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower\n     * case using the rules of the default locale. This is equivalent to calling\n     * {@code toLowerCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"TITLE\".toLowerCase()} in a Turkish locale\n     * returns {@code \"t\\u005Cu0131tle\"}, where \u0027\\u005Cu0131\u0027 is the\n     * LATIN SMALL LETTER DOTLESS I character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toLowerCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to lowercase.\n     * @see     java.lang.String#toLowerCase(Locale)\n     */\n    public String toLowerCase() {\n        return toLowerCase(Locale.getDefault());\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the given {@code Locale}. Case mapping is based\n     * on the Unicode Standard version specified by the {@link java.lang.Character Character}\n     * class. Since case mappings are not always 1:1 char mappings, the resulting\n     * {@code String} may be a different length than the original {@code String}.\n     * \u003cp\u003e\n     * Examples of locale-sensitive and 1:M case mappings are in the following table.\n     *\n     * \u003ctable class\u003d\"plain\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eExamples of locale-sensitive and 1:M case mappings. Shows Language code of locale, lower case, upper case, and description.\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLanguage Code of Locale\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eLower Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eUpper Case\u003c/th\u003e\n     *   \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e\n     * \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0069\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0130\u003c/td\u003e\n     *   \u003ctd\u003esmall letter i -\u0026gt; capital letter I with dot above\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003etr (Turkish)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u0131\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0049\u003c/td\u003e\n     *   \u003ctd\u003esmall letter dotless i -\u0026gt; capital letter I\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003e\u0026#92;u00df\u003c/th\u003e\n     *   \u003ctd\u003e\u0026#92;u0053 \u0026#92;u0053\u003c/td\u003e\n     *   \u003ctd\u003esmall letter sharp s -\u0026gt; two letters: SS\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003ctd\u003e(all)\u003c/td\u003e\n     *   \u003cth scope\u003d\"row\" style\u003d\"font-weight:normal; text-align:left\"\u003eFahrvergn\u0026uuml;gen\u003c/th\u003e\n     *   \u003ctd\u003eFAHRVERGN\u0026Uuml;GEN\u003c/td\u003e\n     *   \u003ctd\u003e\u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * @param locale use the case transformation rules for this locale\n     * @return the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase()\n     * @see     java.lang.String#toLowerCase()\n     * @see     java.lang.String#toLowerCase(Locale)\n     * @since   1.1\n     */\n    public String toUpperCase(Locale locale) {\n        return isLatin1() ? StringLatin1.toUpperCase(this, value, locale)\n                          : StringUTF16.toUpperCase(this, value, locale);\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to upper\n     * case using the rules of the default locale. This method is equivalent to\n     * {@code toUpperCase(Locale.getDefault())}.\n     * \u003cp\u003e\n     * \u003cb\u003eNote:\u003c/b\u003e This method is locale sensitive, and may produce unexpected\n     * results if used for strings that are intended to be interpreted locale\n     * independently.\n     * Examples are programming language identifiers, protocol keys, and HTML\n     * tags.\n     * For instance, {@code \"title\".toUpperCase()} in a Turkish locale\n     * returns {@code \"T\\u005Cu0130TLE\"}, where \u0027\\u005Cu0130\u0027 is the\n     * LATIN CAPITAL LETTER I WITH DOT ABOVE character.\n     * To obtain correct results for locale insensitive strings, use\n     * {@code toUpperCase(Locale.ROOT)}.\n     *\n     * @return  the {@code String}, converted to uppercase.\n     * @see     java.lang.String#toUpperCase(Locale)\n     */\n    public String toUpperCase() {\n        return toUpperCase(Locale.getDefault());\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing space removed, where space is defined\n     * as any character whose codepoint is less than or equal to\n     * {@code \u0027U+0020\u0027} (the space character).\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty character\n     * sequence, or the first and last characters of character sequence\n     * represented by this {@code String} object both have codes\n     * that are not space (as defined above), then a\n     * reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * Otherwise, if all characters in this string are space (as\n     * defined above), then a  {@code String} object representing an\n     * empty string is returned.\n     * \u003cp\u003e\n     * Otherwise, let \u003ci\u003ek\u003c/i\u003e be the index of the first character in the\n     * string whose code is not a space (as defined above) and let\n     * \u003ci\u003em\u003c/i\u003e be the index of the last character in the string whose code\n     * is not a space (as defined above). A {@code String}\n     * object is returned, representing the substring of this string that\n     * begins with the character at index \u003ci\u003ek\u003c/i\u003e and ends with the\n     * character at index \u003ci\u003em\u003c/i\u003e-that is, the result of\n     * {@code this.substring(k, m + 1)}.\n     * \u003cp\u003e\n     * This method may be used to trim space (as defined above) from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing space removed, or this string if it\n     *          has no leading or trailing space.\n     */\n    public String trim() {\n        String ret \u003d isLatin1() ? StringLatin1.trim(value)\n                                : StringUTF16.trim(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * and trailing {@link Character#isWhitespace(int) white space}\n     * removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@link Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@link Character#isWhitespace(int) white space}\n     * up to and including the last code point that is not a\n     * {@link Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to strip\n     * {@link Character#isWhitespace(int) white space} from\n     * the beginning and end of a string.\n     *\n     * @return  a string whose value is this string, with all leading\n     *          and trailing white space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String strip() {\n        String ret \u003d isLatin1() ? StringLatin1.strip(value)\n                                : StringUTF16.strip(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all leading\n     * {@link Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all code points in this string are\n     * {@link Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point that is not a {@link Character#isWhitespace(int) white space}\n     * up to to and including the last code point of this string.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@link Character#isWhitespace(int) white space} from\n     * the beginning of a string.\n     *\n     * @return  a string whose value is this string, with all leading white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripLeading() {\n        String ret \u003d isLatin1() ? StringLatin1.stripLeading(value)\n                                : StringUTF16.stripLeading(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns a string whose value is this string, with all trailing\n     * {@link Character#isWhitespace(int) white space} removed.\n     * \u003cp\u003e\n     * If this {@code String} object represents an empty string,\n     * or if all characters in this string are\n     * {@link Character#isWhitespace(int) white space}, then an empty string\n     * is returned.\n     * \u003cp\u003e\n     * Otherwise, returns a substring of this string beginning with the first\n     * code point of this string up to and including the last code point\n     * that is not a {@link Character#isWhitespace(int) white space}.\n     * \u003cp\u003e\n     * This method may be used to trim\n     * {@link Character#isWhitespace(int) white space} from\n     * the end of a string.\n     *\n     * @return  a string whose value is this string, with all trailing white\n     *          space removed\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public String stripTrailing() {\n        String ret \u003d isLatin1() ? StringLatin1.stripTrailing(value)\n                                : StringUTF16.stripTrailing(value);\n        return ret \u003d\u003d null ? this : ret;\n    }\n\n    /**\n     * Returns {@code true} if the string is empty or contains only\n     * {@link Character#isWhitespace(int) white space} codepoints,\n     * otherwise {@code false}.\n     *\n     * @return {@code true} if the string is empty or contains only\n     *         {@link Character#isWhitespace(int) white space} codepoints,\n     *         otherwise {@code false}\n     *\n     * @see Character#isWhitespace(int)\n     *\n     * @since 11\n     */\n    public boolean isBlank() {\n        return indexOfNonWhitespace() \u003d\u003d length();\n    }\n\n    private int indexOfNonWhitespace() {\n        if (isLatin1()) {\n            return StringLatin1.indexOfNonWhitespace(value);\n        } else {\n            return StringUTF16.indexOfNonWhitespace(value);\n        }\n    }\n\n    /**\n     * Returns a stream of lines extracted from this string,\n     * separated by line terminators.\n     * \u003cp\u003e\n     * A \u003ci\u003eline terminator\u003c/i\u003e is one of the following:\n     * a line feed character {@code \"\\n\"} (U+000A),\n     * a carriage return character {@code \"\\r\"} (U+000D),\n     * or a carriage return followed immediately by a line feed\n     * {@code \"\\r\\n\"} (U+000D U+000A).\n     * \u003cp\u003e\n     * A \u003ci\u003eline\u003c/i\u003e is either a sequence of zero or more characters\n     * followed by a line terminator, or it is a sequence of one or\n     * more characters followed by the end of the string. A\n     * line does not include the line terminator.\n     * \u003cp\u003e\n     * The stream returned by this method contains the lines from\n     * this string in the order in which they occur.\n     *\n     * @apiNote This definition of \u003ci\u003eline\u003c/i\u003e implies that an empty\n     *          string has zero lines and that there is no empty line\n     *          following a line terminator at the end of a string.\n     *\n     * @implNote This method provides better performance than\n     *           split(\"\\R\") by supplying elements lazily and\n     *           by faster search of new line terminators.\n     *\n     * @return  the stream of lines extracted from this string\n     *\n     * @since 11\n     */\n    public Stream\u003cString\u003e lines() {\n        return isLatin1() ? StringLatin1.lines(value)\n                          : StringUTF16.lines(value);\n    }\n\n    /**\n     * This object (which is already a string!) is itself returned.\n     *\n     * @return  the string itself.\n     */\n    public String toString() {\n        return this;\n    }\n\n    /**\n     * Returns a stream of {@code int} zero-extending the {@code char} values\n     * from this sequence.  Any char which maps to a \u003ca\n     * href\u003d\"{@docRoot}/java.base/java/lang/Character.html#unicode\"\u003esurrogate code\n     * point\u003c/a\u003e is passed through uninterpreted.\n     *\n     * @return an IntStream of char values from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream chars() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CharsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n\n    /**\n     * Returns a stream of code point values from this sequence.  Any surrogate\n     * pairs encountered in the sequence are combined as if by {@linkplain\n     * Character#toCodePoint Character.toCodePoint} and the result is passed\n     * to the stream. Any other code units, including ordinary BMP characters,\n     * unpaired surrogates, and undefined code units, are zero-extended to\n     * {@code int} values which are then passed to the stream.\n     *\n     * @return an IntStream of Unicode code points from this sequence\n     * @since 9\n     */\n    @Override\n    public IntStream codePoints() {\n        return StreamSupport.intStream(\n            isLatin1() ? new StringLatin1.CharsSpliterator(value, Spliterator.IMMUTABLE)\n                       : new StringUTF16.CodePointsSpliterator(value, Spliterator.IMMUTABLE),\n            false);\n    }\n\n    /**\n     * Converts this string to a new character array.\n     *\n     * @return  a newly allocated character array whose length is the length\n     *          of this string and whose contents are initialized to contain\n     *          the character sequence represented by this string.\n     */\n    public char[] toCharArray() {\n        return isLatin1() ? StringLatin1.toChars(value)\n                          : StringUTF16.toChars(value);\n    }\n\n    /**\n     * Returns a formatted string using the specified format string and\n     * arguments.\n     *\n     * \u003cp\u003e The locale always used is the one returned by {@link\n     * java.util.Locale#getDefault(java.util.Locale.Category)\n     * Locale.getDefault(Locale.Category)} with\n     * {@link java.util.Locale.Category#FORMAT FORMAT} category specified.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the \u003ca\n     *         href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification.\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(String format, Object... args) {\n        return new Formatter().format(format, args).toString();\n    }\n\n    /**\n     * Returns a formatted string using the specified locale, format string,\n     * and arguments.\n     *\n     * @param  l\n     *         The {@linkplain java.util.Locale locale} to apply during\n     *         formatting.  If {@code l} is {@code null} then no localization\n     *         is applied.\n     *\n     * @param  format\n     *         A \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003eformat string\u003c/a\u003e\n     *\n     * @param  args\n     *         Arguments referenced by the format specifiers in the format\n     *         string.  If there are more arguments than format specifiers, the\n     *         extra arguments are ignored.  The number of arguments is\n     *         variable and may be zero.  The maximum number of arguments is\n     *         limited by the maximum dimension of a Java array as defined by\n     *         \u003ccite\u003eThe Java\u0026trade; Virtual Machine Specification\u003c/cite\u003e.\n     *         The behaviour on a\n     *         {@code null} argument depends on the\n     *         \u003ca href\u003d\"../util/Formatter.html#syntax\"\u003econversion\u003c/a\u003e.\n     *\n     * @throws  java.util.IllegalFormatException\n     *          If a format string contains an illegal syntax, a format\n     *          specifier that is incompatible with the given arguments,\n     *          insufficient arguments given the format string, or other\n     *          illegal conditions.  For specification of all possible\n     *          formatting errors, see the \u003ca\n     *          href\u003d\"../util/Formatter.html#detail\"\u003eDetails\u003c/a\u003e section of the\n     *          formatter class specification\n     *\n     * @return  A formatted string\n     *\n     * @see  java.util.Formatter\n     * @since  1.5\n     */\n    public static String format(Locale l, String format, Object... args) {\n        return new Formatter(l).format(format, args).toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code Object} argument.\n     *\n     * @param   obj   an {@code Object}.\n     * @return  if the argument is {@code null}, then a string equal to\n     *          {@code \"null\"}; otherwise, the value of\n     *          {@code obj.toString()} is returned.\n     * @see     java.lang.Object#toString()\n     */\n    public static String valueOf(Object obj) {\n        return (obj \u003d\u003d null) ? \"null\" : obj.toString();\n    }\n\n    /**\n     * Returns the string representation of the {@code char} array\n     * argument. The contents of the character array are copied; subsequent\n     * modification of the character array does not affect the returned\n     * string.\n     *\n     * @param   data     the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String valueOf(char data[]) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of a specific subarray of the\n     * {@code char} array argument.\n     * \u003cp\u003e\n     * The {@code offset} argument is the index of the first\n     * character of the subarray. The {@code count} argument\n     * specifies the length of the subarray. The contents of the subarray\n     * are copied; subsequent modification of the character array does not\n     * affect the returned string.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @exception IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String valueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[], int, int)}.\n     *\n     * @param   data     the character array.\n     * @param   offset   initial offset of the subarray.\n     * @param   count    length of the subarray.\n     * @return  a {@code String} that contains the characters of the\n     *          specified subarray of the character array.\n     * @exception IndexOutOfBoundsException if {@code offset} is\n     *          negative, or {@code count} is negative, or\n     *          {@code offset+count} is larger than\n     *          {@code data.length}.\n     */\n    public static String copyValueOf(char data[], int offset, int count) {\n        return new String(data, offset, count);\n    }\n\n    /**\n     * Equivalent to {@link #valueOf(char[])}.\n     *\n     * @param   data   the character array.\n     * @return  a {@code String} that contains the characters of the\n     *          character array.\n     */\n    public static String copyValueOf(char data[]) {\n        return new String(data);\n    }\n\n    /**\n     * Returns the string representation of the {@code boolean} argument.\n     *\n     * @param   b   a {@code boolean}.\n     * @return  if the argument is {@code true}, a string equal to\n     *          {@code \"true\"} is returned; otherwise, a string equal to\n     *          {@code \"false\"} is returned.\n     */\n    public static String valueOf(boolean b) {\n        return b ? \"true\" : \"false\";\n    }\n\n    /**\n     * Returns the string representation of the {@code char}\n     * argument.\n     *\n     * @param   c   a {@code char}.\n     * @return  a string of length {@code 1} containing\n     *          as its single character the argument {@code c}.\n     */\n    public static String valueOf(char c) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(c)) {\n            return new String(StringLatin1.toBytes(c), LATIN1);\n        }\n        return new String(StringUTF16.toBytes(c), UTF16);\n    }\n\n    /**\n     * Returns the string representation of the {@code int} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Integer.toString} method of one argument.\n     *\n     * @param   i   an {@code int}.\n     * @return  a string representation of the {@code int} argument.\n     * @see     java.lang.Integer#toString(int, int)\n     */\n    public static String valueOf(int i) {\n        return Integer.toString(i);\n    }\n\n    /**\n     * Returns the string representation of the {@code long} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Long.toString} method of one argument.\n     *\n     * @param   l   a {@code long}.\n     * @return  a string representation of the {@code long} argument.\n     * @see     java.lang.Long#toString(long)\n     */\n    public static String valueOf(long l) {\n        return Long.toString(l);\n    }\n\n    /**\n     * Returns the string representation of the {@code float} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Float.toString} method of one argument.\n     *\n     * @param   f   a {@code float}.\n     * @return  a string representation of the {@code float} argument.\n     * @see     java.lang.Float#toString(float)\n     */\n    public static String valueOf(float f) {\n        return Float.toString(f);\n    }\n\n    /**\n     * Returns the string representation of the {@code double} argument.\n     * \u003cp\u003e\n     * The representation is exactly the one returned by the\n     * {@code Double.toString} method of one argument.\n     *\n     * @param   d   a {@code double}.\n     * @return  a  string representation of the {@code double} argument.\n     * @see     java.lang.Double#toString(double)\n     */\n    public static String valueOf(double d) {\n        return Double.toString(d);\n    }\n\n    /**\n     * Returns a canonical representation for the string object.\n     * \u003cp\u003e\n     * A pool of strings, initially empty, is maintained privately by the\n     * class {@code String}.\n     * \u003cp\u003e\n     * When the intern method is invoked, if the pool already contains a\n     * string equal to this {@code String} object as determined by\n     * the {@link #equals(Object)} method, then the string from the pool is\n     * returned. Otherwise, this {@code String} object is added to the\n     * pool and a reference to this {@code String} object is returned.\n     * \u003cp\u003e\n     * It follows that for any two strings {@code s} and {@code t},\n     * {@code s.intern() \u003d\u003d t.intern()} is {@code true}\n     * if and only if {@code s.equals(t)} is {@code true}.\n     * \u003cp\u003e\n     * All literal strings and string-valued constant expressions are\n     * interned. String literals are defined in section 3.10.5 of the\n     * \u003ccite\u003eThe Java\u0026trade; Language Specification\u003c/cite\u003e.\n     *\n     * @return  a string that has the same contents as this string, but is\n     *          guaranteed to be from a pool of unique strings.\n     * @jls 3.10.5 String Literals\n     */\n    public native String intern();\n\n    /**\n     * Returns a string whose value is the concatenation of this\n     * string repeated {@code count} times.\n     * \u003cp\u003e\n     * If this string is empty or count is zero then the empty\n     * string is returned.\n     *\n     * @param   count number of times to repeat\n     *\n     * @return  A string composed of this string repeated\n     *          {@code count} times or the empty string if this\n     *          string is empty or count is zero\n     *\n     * @throws  IllegalArgumentException if the {@code count} is\n     *          negative.\n     *\n     * @since 11\n     */\n    public String repeat(int count) {\n        if (count \u003c 0) {\n            throw new IllegalArgumentException(\"count is negative: \" + count);\n        }\n        if (count \u003d\u003d 1) {\n            return this;\n        }\n        final int len \u003d value.length;\n        if (len \u003d\u003d 0 || count \u003d\u003d 0) {\n            return \"\";\n        }\n        if (len \u003d\u003d 1) {\n            final byte[] single \u003d new byte[count];\n            Arrays.fill(single, value[0]);\n            return new String(single, coder);\n        }\n        if (Integer.MAX_VALUE / count \u003c len) {\n            throw new OutOfMemoryError(\"Repeating \" + len + \" bytes String \" + count +\n                    \" times will produce a String exceeding maximum size.\");\n        }\n        final int limit \u003d len * count;\n        final byte[] multiple \u003d new byte[limit];\n        System.arraycopy(value, 0, multiple, 0, len);\n        int copied \u003d len;\n        for (; copied \u003c limit - copied; copied \u003c\u003c\u003d 1) {\n            System.arraycopy(multiple, 0, multiple, copied, copied);\n        }\n        System.arraycopy(multiple, 0, multiple, copied, limit - copied);\n        return new String(multiple, coder);\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * Copy character bytes from this string into dst starting at dstBegin.\n     * This method doesn\u0027t perform any range checking.\n     *\n     * Invoker guarantees: dst is in UTF16 (inflate itself for asb), if two\n     * coders are different, and dst is big enough (range check)\n     *\n     * @param dstBegin  the char index, not offset of byte[]\n     * @param coder     the coder of dst[]\n     */\n    void getBytes(byte dst[], int dstBegin, byte coder) {\n        if (coder() \u003d\u003d coder) {\n            System.arraycopy(value, 0, dst, dstBegin \u003c\u003c coder, value.length);\n        } else {    // this.coder \u003d\u003d LATIN \u0026\u0026 coder \u003d\u003d UTF16\n            StringLatin1.inflate(value, 0, dst, dstBegin, value.length);\n        }\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     *\n     * Stores the char[] value into a byte[] that each byte represents\n     * the8 low-order bits of the corresponding character, if the char[]\n     * contains only latin1 character. Or a byte[] that stores all\n     * characters in their byte sequences defined by the {@code StringUTF16}.\n     */\n    String(char[] value, int off, int len, Void sig) {\n        if (len \u003d\u003d 0) {\n            this.value \u003d \"\".value;\n            this.coder \u003d \"\".coder;\n            return;\n        }\n        if (COMPACT_STRINGS) {\n            byte[] val \u003d StringUTF16.compress(value, off, len);\n            if (val !\u003d null) {\n                this.value \u003d val;\n                this.coder \u003d LATIN1;\n                return;\n            }\n        }\n        this.coder \u003d UTF16;\n        this.value \u003d StringUTF16.toBytes(value, off, len);\n    }\n\n    /*\n     * Package private constructor. Trailing Void argument is there for\n     * disambiguating it against other (public) constructors.\n     */\n    String(AbstractStringBuilder asb, Void sig) {\n        byte[] val \u003d asb.getValue();\n        int length \u003d asb.length();\n        if (asb.isLatin1()) {\n            this.coder \u003d LATIN1;\n            this.value \u003d Arrays.copyOfRange(val, 0, length);\n        } else {\n            if (COMPACT_STRINGS) {\n                byte[] buf \u003d StringUTF16.compress(val, 0, length);\n                if (buf !\u003d null) {\n                    this.coder \u003d LATIN1;\n                    this.value \u003d buf;\n                    return;\n                }\n            }\n            this.coder \u003d UTF16;\n            this.value \u003d Arrays.copyOfRange(val, 0, length \u003c\u003c 1);\n        }\n    }\n\n   /*\n    * Package private constructor which shares value array for speed.\n    */\n    String(byte[] value, byte coder) {\n        this.value \u003d value;\n        this.coder \u003d coder;\n    }\n\n    byte coder() {\n        return COMPACT_STRINGS ? coder : UTF16;\n    }\n\n    byte[] value() {\n        return value;\n    }\n\n    private boolean isLatin1() {\n        return COMPACT_STRINGS \u0026\u0026 coder \u003d\u003d LATIN1;\n    }\n\n    @Native static final byte LATIN1 \u003d 0;\n    @Native static final byte UTF16  \u003d 1;\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code index} is\n     * negative or greater than or equal to {@code length}.\n     */\n    static void checkIndex(int index, int length) {\n        if (index \u003c 0 || index \u003e\u003d length) {\n            throw new StringIndexOutOfBoundsException(\"index \" + index +\n                                                      \",length \" + length);\n        }\n    }\n\n    /*\n     * StringIndexOutOfBoundsException  if {@code offset}\n     * is negative or greater than {@code length}.\n     */\n    static void checkOffset(int offset, int length) {\n        if (offset \u003c 0 || offset \u003e length) {\n            throw new StringIndexOutOfBoundsException(\"offset \" + offset +\n                                                      \",length \" + length);\n        }\n    }\n\n    /*\n     * Check {@code offset}, {@code count} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code offset} is negative, {@code count} is negative,\n     *          or {@code offset} is greater than {@code length - count}\n     */\n    static void checkBoundsOffCount(int offset, int count, int length) {\n        if (offset \u003c 0 || count \u003c 0 || offset \u003e length - count) {\n            throw new StringIndexOutOfBoundsException(\n                \"offset \" + offset + \", count \" + count + \", length \" + length);\n        }\n    }\n\n    /*\n     * Check {@code begin}, {@code end} against {@code 0} and {@code length}\n     * bounds.\n     *\n     * @throws  StringIndexOutOfBoundsException\n     *          If {@code begin} is negative, {@code begin} is greater than\n     *          {@code end}, or {@code end} is greater than {@code length}.\n     */\n    static void checkBoundsBeginEnd(int begin, int end, int length) {\n        if (begin \u003c 0 || begin \u003e end || end \u003e length) {\n            throw new StringIndexOutOfBoundsException(\n                \"begin \" + begin + \", end \" + end + \", length \" + length);\n        }\n    }\n\n    /**\n     * Returns the string representation of the {@code codePoint}\n     * argument.\n     *\n     * @param   codePoint a {@code codePoint}.\n     * @return  a string of length {@code 1} or {@code 2} containing\n     *          as its single character the argument {@code codePoint}.\n     * @throws IllegalArgumentException if the specified\n     *          {@code codePoint} is not a {@linkplain Character#isValidCodePoint\n     *          valid Unicode code point}.\n     */\n    static String valueOfCodePoint(int codePoint) {\n        if (COMPACT_STRINGS \u0026\u0026 StringLatin1.canEncode(codePoint)) {\n            return new String(StringLatin1.toBytes((char)codePoint), LATIN1);\n        } else if (Character.isBmpCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytes((char)codePoint), UTF16);\n        } else if (Character.isSupplementaryCodePoint(codePoint)) {\n            return new String(StringUTF16.toBytesSupplementary(codePoint), UTF16);\n        }\n\n        throw new IllegalArgumentException(\n            format(\"Not a valid Unicode code point: 0x%X\", codePoint));\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:883)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:137)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:135)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:617)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:614)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:1040)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2913)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3084)
	at java.base/java.net.URI$Parser.parse(URI.java:3120)
	at java.base/java.net.URI.<init>(URI.java:600)
	at java.base/java.net.URI.create(URI.java:881)
	... 21 more

Jun 02, 2022 12:25:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11.0.14/lib/src.zip%21/java.base/java/lang/String.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI.create(URI.java:883)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:137)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:135)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:617)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:614)
	at scala.meta.internal.metals.MetalsLanguageServer.didClose(MetalsLanguageServer.scala:1209)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/lang/String.java
	at java.base/java.net.URI$Parser.fail(URI.java:2913)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3084)
	at java.base/java.net.URI$Parser.parse(URI.java:3120)
	at java.base/java.net.URI.<init>(URI.java:600)
	at java.base/java.net.URI.create(URI.java:881)
	... 21 more

2022.06.02 00:25:46 INFO  compiling root (1 scala source)
2022.06.02 00:25:46 INFO  time: compiled root in 0.21s
2022.06.02 00:30:12 INFO  compiling root (1 scala source)
2022.06.02 00:30:12 INFO  time: compiled root in 0.3s
2022.06.02 00:30:23 INFO  compiling root (1 scala source)
2022.06.02 00:30:23 INFO  time: compiled root in 0.25s
2022.06.02 00:31:25 INFO  compiling root (1 scala source)
2022.06.02 00:31:25 INFO  time: compiled root in 0.18s
2022.06.02 00:31:46 INFO  compiling root (1 scala source)
2022.06.02 00:31:46 INFO  time: compiled root in 0.19s
2022.06.02 00:31:49 INFO  compiling root (1 scala source)
2022.06.02 00:31:49 INFO  time: compiled root in 86ms
2022.06.02 00:31:57 INFO  compiling root (1 scala source)
2022.06.02 00:31:57 INFO  time: compiled root in 0.24s
2022.06.02 00:32:13 INFO  compiling root (1 scala source)
2022.06.02 00:32:13 INFO  time: compiled root in 0.22s
2022.06.02 00:32:36 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 00:32:36 INFO  compiling root (1 scala source)
2022.06.02 00:32:36 INFO  time: compiled root in 0.19s
2022.06.02 00:32:46 INFO  compiling root (1 scala source)
2022.06.02 00:32:46 INFO  time: compiled root in 0.19s
2022.06.02 00:33:31 INFO  compiling root (1 scala source)
2022.06.02 00:33:31 INFO  time: compiled root in 66ms
2022.06.02 00:33:34 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 00:33:41 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 00:33:42 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 00:33:42 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 00:33:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 00:33:43 INFO  compiling root (1 scala source)
2022.06.02 00:33:43 INFO  time: compiled root in 61ms
2022.06.02 00:33:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 00:33:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 00:33:45 INFO  compiling root (1 scala source)
2022.06.02 00:33:45 INFO  time: compiled root in 0.2s
2022.06.02 00:33:48 INFO  compiling root (1 scala source)
2022.06.02 00:33:48 INFO  time: compiled root in 0.19s
Jun 02, 2022 12:34:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3454
Jun 02, 2022 12:34:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3471
2022.06.02 00:34:27 INFO  compiling root (1 scala source)
2022.06.02 00:34:27 INFO  time: compiled root in 0.2s
2022.06.02 00:36:38 INFO  compiling root (1 scala source)
2022.06.02 00:36:38 ERROR Bad symbolic reference. A signature
refers to Product[Unique $ 2]/T in package <empty> which is not available.
It may be completely missing from the current classpath, or the version on
the classpath might be incompatible with the version used when compiling the signature.
2022.06.02 00:36:38 INFO  time: compiled root in 0.1s
2022.06.02 00:37:04 INFO  compiling root (1 scala source)
2022.06.02 00:37:04 INFO  time: compiled root in 0.27s
2022.06.02 00:37:13 INFO  compiling root (1 scala source)
2022.06.02 00:37:13 INFO  time: compiled root in 0.24s
2022.06.02 00:38:05 INFO  compiling root (1 scala source)
2022.06.02 00:38:05 INFO  time: compiled root in 0.21s
2022.06.02 00:39:32 INFO  compiling root (1 scala source)
2022.06.02 00:39:32 INFO  time: compiled root in 0.21s
2022.06.02 00:40:02 INFO  compiling root (1 scala source)
2022.06.02 00:40:02 INFO  time: compiled root in 0.18s
2022.06.02 00:40:41 INFO  compiling root (1 scala source)
2022.06.02 00:40:41 INFO  time: compiled root in 0.18s
2022.06.02 00:40:55 INFO  compiling root (1 scala source)
2022.06.02 00:40:55 INFO  time: compiled root in 0.18s
Jun 02, 2022 12:41:27 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4372
2022.06.02 00:43:25 INFO  compiling root (1 scala source)
2022.06.02 00:43:25 INFO  time: compiled root in 0.22s
2022.06.02 00:44:14 INFO  compiling root (1 scala source)
2022.06.02 00:44:14 INFO  time: compiled root in 0.21s
2022.06.02 00:44:51 INFO  compiling root (1 scala source)
2022.06.02 00:44:51 INFO  time: compiled root in 81ms
2022.06.02 00:44:52 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 00:45:03 INFO  compiling root (1 scala source)
2022.06.02 00:45:03 INFO  time: compiled root in 0.21s
2022.06.02 18:23:34 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.02 18:23:34 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.02 18:23:34 INFO  Connected to Build server: Bloop v1.5.0
2022.06.02 18:23:34 INFO  Connected to Build server: Bloop v1.5.0
2022.06.02 18:23:34 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\project\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.02 18:23:34 INFO  compiling root (1 scala source)
2022.06.02 18:23:35 INFO  time: indexed workspace in 1.05s
2022.06.02 18:23:35 INFO  compiling root (1 scala source)
2022.06.02 18:23:36 INFO  time: compiled root in 1.1s
Jun 02, 2022 6:23:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5411
2022.06.02 18:25:31 INFO  compiling root (1 scala source)
2022.06.02 18:25:31 INFO  time: compiled root in 0.16s
2022.06.02 18:25:33 INFO  compiling root (1 scala source)
2022.06.02 18:25:33 INFO  time: compiled root in 0.16s
2022.06.02 18:26:02 INFO  compiling root (1 scala source)
2022.06.02 18:26:02 INFO  time: compiled root in 0.15s
2022.06.02 18:26:37 INFO  compiling root (1 scala source)
2022.06.02 18:26:37 INFO  time: compiled root in 0.16s
2022.06.02 18:27:01 INFO  compiling root (1 scala source)
2022.06.02 18:27:01 INFO  time: compiled root in 0.17s
2022.06.02 18:27:07 INFO  compiling root (1 scala source)
2022.06.02 18:27:07 INFO  time: compiled root in 0.15s
2022.06.02 18:27:25 INFO  compiling root (1 scala source)
2022.06.02 18:27:25 INFO  time: compiled root in 0.14s
2022.06.02 18:27:31 INFO  compiling root (1 scala source)
2022.06.02 18:27:31 INFO  time: compiled root in 0.16s
2022.06.02 18:29:24 INFO  compiling root (1 scala source)
2022.06.02 18:29:24 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:29:24 INFO  time: compiled root in 66ms
2022.06.02 18:29:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:29:42 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:29:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:29:50 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:29:52 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:30:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:30:35 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:30:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:30:50 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:30:51 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:30:51 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:30:52 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:31:01 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:31:02 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:31:02 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:33:07 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:33:08 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:33:08 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:39:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:40:09 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:40:15 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:40:16 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:44:19 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:44:23 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 18:46:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:06:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:12:10 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:41 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:41 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:45 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:48 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:51 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:52 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:52 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:56 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:20:59 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:53:28: stale bloop error: Missing parameter type

I could not infer the type of the parameter elems.
  val orders:List[Order] = List[Order].empty()
                           ^
2022.06.02 19:20:59 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:53:28: stale bloop error: Missing parameter type

I could not infer the type of the parameter elems.
  val orders:List[Order] = List[Order].empty()
                           ^
2022.06.02 19:20:59 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:00 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:01 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:01 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:02 INFO  compiling root (1 scala source)
2022.06.02 19:21:02 INFO  time: compiled root in 91ms
2022.06.02 19:21:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:04 INFO  compiling root (1 scala source)
2022.06.02 19:21:04 INFO  time: compiled root in 67ms
2022.06.02 19:21:05 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:07 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:10 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:18 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:18 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:18 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:18 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:19 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:19 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:22 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:23 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:24 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:25 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:25 INFO  compiling root (1 scala source)
2022.06.02 19:21:25 INFO  time: compiled root in 0.22s
2022.06.02 19:21:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:28 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:39 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:39 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:40 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:41 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:42 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:42 INFO  compiling root (1 scala source)
2022.06.02 19:21:42 INFO  time: compiled root in 87ms
2022.06.02 19:21:45 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:47 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:48 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:48 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:53 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:21:59 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:22:02 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:22:02 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:22:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:22:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:22:05 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:22:06 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:22:08 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:22:11 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 19:22:12 INFO  compiling root (1 scala source)
2022.06.02 19:22:12 INFO  time: compiled root in 0.17s
2022.06.02 19:22:29 INFO  compiling root (1 scala source)
2022.06.02 19:22:29 INFO  time: compiled root in 0.15s
2022.06.02 19:23:12 INFO  compiling root (1 scala source)
2022.06.02 19:23:12 INFO  time: compiled root in 0.16s
2022.06.02 19:23:35 INFO  compiling root (1 scala source)
2022.06.02 19:23:35 INFO  time: compiled root in 0.2s
2022.06.02 19:24:43 INFO  compiling root (1 scala source)
2022.06.02 19:24:43 INFO  time: compiled root in 0.15s
Jun 02, 2022 7:31:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6718
2022.06.02 19:32:15 INFO  compiling root (1 scala source)
2022.06.02 19:32:15 INFO  time: compiled root in 0.15s
2022.06.02 19:33:44 INFO  compiling root (1 scala source)
2022.06.02 19:33:44 INFO  time: compiled root in 0.19s
2022.06.02 19:33:54 INFO  compiling root (1 scala source)
2022.06.02 19:33:54 INFO  time: compiled root in 0.17s
2022.06.02 19:34:00 INFO  compiling root (1 scala source)
2022.06.02 19:34:00 INFO  time: compiled root in 0.14s
2022.06.02 19:34:06 INFO  compiling root (1 scala source)
2022.06.02 19:34:06 INFO  time: compiled root in 58ms
2022.06.02 19:34:28 INFO  compiling root (1 scala source)
2022.06.02 19:34:28 INFO  time: compiled root in 56ms
2022.06.02 19:34:36 INFO  compiling root (1 scala source)
2022.06.02 19:34:36 INFO  time: compiled root in 0.15s
2022.06.02 19:35:01 INFO  compiling root (1 scala source)
2022.06.02 19:35:01 INFO  time: compiled root in 0.15s
2022.06.02 19:35:05 INFO  compiling root (1 scala source)
2022.06.02 19:35:05 INFO  time: compiled root in 0.15s
2022.06.02 19:36:46 INFO  compiling root (1 scala source)
2022.06.02 19:36:46 INFO  time: compiled root in 0.15s
2022.06.02 19:39:05 INFO  compiling root (1 scala source)
2022.06.02 19:39:05 INFO  time: compiled root in 0.16s
2022.06.02 19:40:06 INFO  compiling root (1 scala source)
2022.06.02 19:40:06 INFO  time: compiled root in 0.15s
2022.06.02 19:40:33 INFO  compiling root (1 scala source)
2022.06.02 19:40:33 INFO  time: compiled root in 0.15s
2022.06.02 19:42:19 INFO  compiling root (1 scala source)
2022.06.02 19:42:19 INFO  time: compiled root in 0.18s
2022.06.02 19:42:23 INFO  compiling root (1 scala source)
2022.06.02 19:42:23 INFO  time: compiled root in 0.23s
2022.06.02 19:42:43 INFO  compiling root (1 scala source)
2022.06.02 19:42:43 INFO  time: compiled root in 0.16s
2022.06.02 19:42:53 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:67:47: stale bloop error: Found:    Seq[MonthPeriod]
Required: MonthPeriod
    val monthPeriods:List[MonthPeriod] = List(args.tail.tail.map(interval => MonthPeriod(interval)))
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:42:53 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:67:47: stale bloop error: Found:    Seq[MonthPeriod]
Required: MonthPeriod
    val monthPeriods:List[MonthPeriod] = List(args.tail.tail.map(interval => MonthPeriod(interval)))
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:43:35 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:67:47: stale bloop error: Found:    Seq[MonthPeriod]
Required: MonthPeriod
    val monthPeriods:List[MonthPeriod] = List(args.tail.tail.map(interval => MonthPeriod(interval)))
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:43:35 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:67:47: stale bloop error: Found:    Seq[MonthPeriod]
Required: MonthPeriod
    val monthPeriods:List[MonthPeriod] = List(args.tail.tail.map(interval => MonthPeriod(interval)))
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:43:35 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:67:47: stale bloop error: Found:    Seq[MonthPeriod]
Required: MonthPeriod
    val monthPeriods:List[MonthPeriod] = List(args.tail.tail.map(interval => MonthPeriod(interval)))
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:43:35 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:67:47: stale bloop error: Found:    Seq[MonthPeriod]
Required: MonthPeriod
    val monthPeriods:List[MonthPeriod] = List(args.tail.tail.map(interval => MonthPeriod(interval)))
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:43:39 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:67:47: stale bloop error: Found:    Seq[MonthPeriod]
Required: MonthPeriod
    val monthPeriods:List[MonthPeriod] = List(args.tail.tail.map(interval => MonthPeriod(interval)))
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:43:39 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:67:47: stale bloop error: Found:    Seq[MonthPeriod]
Required: MonthPeriod
    val monthPeriods:List[MonthPeriod] = List(args.tail.tail.map(interval => MonthPeriod(interval)))
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:43:39 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:67:47: stale bloop error: Found:    Seq[MonthPeriod]
Required: MonthPeriod
    val monthPeriods:List[MonthPeriod] = List(args.tail.tail.map(interval => MonthPeriod(interval)))
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:43:39 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:67:47: stale bloop error: Found:    Seq[MonthPeriod]
Required: MonthPeriod
    val monthPeriods:List[MonthPeriod] = List(args.tail.tail.map(interval => MonthPeriod(interval)))
                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:44:00 INFO  compiling root (1 scala source)
2022.06.02 19:44:00 INFO  time: compiled root in 0.14s
2022.06.02 19:44:06 INFO  compiling root (1 scala source)
2022.06.02 19:44:06 INFO  time: compiled root in 0.15s
2022.06.02 19:45:29 INFO  compiling root (1 scala source)
2022.06.02 19:45:29 INFO  time: compiled root in 0.14s
2022.06.02 19:46:01 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:68:111: stale bloop error: value +: is not a member of MonthPeriod
    val monthPeriods:List[MonthPeriod] = args.tail.tail.foldLeft(List[MonthPeriod]())((acc, interval) => (acc +: MonthPeriod(interval)))
                                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:46:01 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:68:111: stale bloop error: value +: is not a member of MonthPeriod
    val monthPeriods:List[MonthPeriod] = args.tail.tail.foldLeft(List[MonthPeriod]())((acc, interval) => (acc +: MonthPeriod(interval)))
                                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:46:01 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:68:111: stale bloop error: value +: is not a member of MonthPeriod
    val monthPeriods:List[MonthPeriod] = args.tail.tail.foldLeft(List[MonthPeriod]())((acc, interval) => (acc +: MonthPeriod(interval)))
                                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:46:01 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:68:111: stale bloop error: value +: is not a member of MonthPeriod
    val monthPeriods:List[MonthPeriod] = args.tail.tail.foldLeft(List[MonthPeriod]())((acc, interval) => (acc +: MonthPeriod(interval)))
                                                                                                              ^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 19:46:30 INFO  compiling root (1 scala source)
2022.06.02 19:46:30 INFO  time: compiled root in 0.13s
2022.06.02 19:47:00 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:70:113: stale bloop error: value +: is not a member of MonthPeriod
                                                                                                            acc +: monthPeriod
                                                                                                                ^^^^^^^^^^^^^^
2022.06.02 19:47:00 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:70:113: stale bloop error: value +: is not a member of MonthPeriod
                                                                                                            acc +: monthPeriod
                                                                                                                ^^^^^^^^^^^^^^
2022.06.02 19:47:00 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:70:113: stale bloop error: value +: is not a member of MonthPeriod
                                                                                                            acc +: monthPeriod
                                                                                                                ^^^^^^^^^^^^^^
2022.06.02 19:47:00 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:70:113: stale bloop error: value +: is not a member of MonthPeriod
                                                                                                            acc +: monthPeriod
                                                                                                                ^^^^^^^^^^^^^^
2022.06.02 19:47:03 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:70:113: stale bloop error: value +: is not a member of MonthPeriod
                                                                                                            acc +: monthPeriod
                                                                                                                ^^^^^^^^^^^^^^
2022.06.02 19:47:03 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:70:113: stale bloop error: value +: is not a member of MonthPeriod
                                                                                                            acc +: monthPeriod
                                                                                                                ^^^^^^^^^^^^^^
2022.06.02 19:47:03 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:70:113: stale bloop error: value +: is not a member of MonthPeriod
                                                                                                            acc +: monthPeriod
                                                                                                                ^^^^^^^^^^^^^^
2022.06.02 19:47:03 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:70:113: stale bloop error: value +: is not a member of MonthPeriod
                                                                                                            acc +: monthPeriod
                                                                                                                ^^^^^^^^^^^^^^
2022.06.02 19:47:52 INFO  compiling root (1 scala source)
2022.06.02 19:47:52 INFO  time: compiled root in 0.15s
2022.06.02 19:47:59 INFO  compiling root (1 scala source)
2022.06.02 19:47:59 INFO  time: compiled root in 0.23s
2022.06.02 19:48:03 INFO  compiling root (1 scala source)
2022.06.02 19:48:03 INFO  time: compiled root in 0.16s
2022.06.02 19:48:31 INFO  compiling root (1 scala source)
2022.06.02 19:48:31 INFO  time: compiled root in 45ms
2022.06.02 19:48:38 INFO  compiling root (1 scala source)
2022.06.02 19:48:38 INFO  time: compiled root in 0.15s
2022.06.02 19:49:12 INFO  compiling root (1 scala source)
2022.06.02 19:49:12 INFO  time: compiled root in 55ms
2022.06.02 19:49:55 INFO  compiling root (1 scala source)
2022.06.02 19:49:55 INFO  time: compiled root in 0.14s
2022.06.02 19:50:47 INFO  compiling root (1 scala source)
2022.06.02 19:50:47 INFO  time: compiled root in 0.14s
2022.06.02 19:50:53 INFO  compiling root (1 scala source)
2022.06.02 19:50:53 INFO  time: compiled root in 0.14s
2022.06.02 19:51:24 INFO  compiling root (1 scala source)
2022.06.02 19:51:24 INFO  time: compiled root in 0.15s
2022.06.02 19:53:04 INFO  compiling root (1 scala source)
2022.06.02 19:53:04 INFO  time: compiled root in 0.15s
2022.06.02 19:53:59 INFO  compiling root (1 scala source)
2022.06.02 19:53:59 INFO  time: compiled root in 0.16s
2022.06.02 19:54:05 INFO  compiling root (1 scala source)
2022.06.02 19:54:05 INFO  time: compiled root in 0.15s
2022.06.02 19:54:27 INFO  compiling root (1 scala source)
2022.06.02 19:54:27 INFO  time: compiled root in 0.19s
2022.06.02 19:54:44 INFO  compiling root (1 scala source)
2022.06.02 19:54:44 INFO  time: compiled root in 0.14s
2022.06.02 19:56:00 INFO  compiling root (1 scala source)
2022.06.02 19:56:00 INFO  time: compiled root in 0.14s
2022.06.02 19:56:02 INFO  compiling root (1 scala source)
2022.06.02 19:56:02 INFO  time: compiled root in 0.14s
2022.06.02 19:56:16 INFO  compiling root (1 scala source)
2022.06.02 19:56:16 INFO  time: compiled root in 0.14s
2022.06.02 19:56:36 INFO  compiling root (1 scala source)
2022.06.02 19:56:36 INFO  time: compiled root in 0.14s
2022.06.02 20:06:24 INFO  compiling root (1 scala source)
2022.06.02 20:06:24 INFO  time: compiled root in 0.17s
2022.06.02 20:06:45 INFO  compiling root (1 scala source)
2022.06.02 20:06:45 INFO  time: compiled root in 0.14s
2022.06.02 20:08:27 INFO  compiling root (1 scala source)
2022.06.02 20:08:27 INFO  time: compiled root in 0.14s
2022.06.02 20:09:18 INFO  compiling root (1 scala source)
2022.06.02 20:09:18 INFO  time: compiled root in 0.14s
2022.06.02 20:09:20 INFO  compiling root (1 scala source)
2022.06.02 20:09:20 INFO  time: compiled root in 0.15s
2022.06.02 20:17:30 INFO  compiling root (1 scala source)
2022.06.02 20:17:30 INFO  time: compiled root in 0.15s
2022.06.02 20:19:59 INFO  compiling root (1 scala source)
2022.06.02 20:19:59 INFO  time: compiled root in 0.15s
2022.06.02 20:20:05 INFO  compiling root (1 scala source)
2022.06.02 20:20:05 INFO  time: compiled root in 0.14s
2022.06.02 20:22:03 INFO  compiling root (1 scala source)
2022.06.02 20:22:03 INFO  time: compiled root in 0.15s
2022.06.02 20:22:13 INFO  compiling root (1 scala source)
2022.06.02 20:22:13 INFO  time: compiled root in 0.15s
2022.06.02 20:23:10 INFO  compiling root (1 scala source)
2022.06.02 20:23:10 INFO  time: compiled root in 0.15s
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:59:1: stale bloop error: 'then' expected, but '}' found
}
^
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:140:9: stale bloop error: Found:    Time
Required: Int
        item.getProduct().getAge() 
        ^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:57:40: stale bloop warning: A pure expression does nothing in statement position; you may be omitting necessary parentheses
    if this.toString() < other.toString
                                       ^
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:59:1: stale bloop error: 'then' expected, but '}' found
}
^
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:140:9: stale bloop error: Found:    Time
Required: Int
        item.getProduct().getAge() 
        ^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:57:40: stale bloop warning: A pure expression does nothing in statement position; you may be omitting necessary parentheses
    if this.toString() < other.toString
                                       ^
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:59:1: stale bloop error: 'then' expected, but '}' found
}
^
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:140:9: stale bloop error: Found:    Time
Required: Int
        item.getProduct().getAge() 
        ^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:57:40: stale bloop warning: A pure expression does nothing in statement position; you may be omitting necessary parentheses
    if this.toString() < other.toString
                                       ^
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:59:1: stale bloop error: 'then' expected, but '}' found
}
^
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:140:9: stale bloop error: Found:    Time
Required: Int
        item.getProduct().getAge() 
        ^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 20:23:13 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:57:40: stale bloop warning: A pure expression does nothing in statement position; you may be omitting necessary parentheses
    if this.toString() < other.toString
                                       ^
2022.06.02 20:23:14 INFO  compiling root (1 scala source)
2022.06.02 20:23:14 INFO  time: compiled root in 0.14s
2022.06.02 20:23:17 INFO  compiling root (1 scala source)
2022.06.02 20:23:17 INFO  time: compiled root in 0.15s
2022.06.02 20:23:19 INFO  compiling root (1 scala source)
2022.06.02 20:23:19 INFO  time: compiled root in 0.16s
2022.06.02 20:24:14 INFO  compiling root (1 scala source)
2022.06.02 20:24:14 INFO  time: compiled root in 59ms
2022.06.02 20:24:17 INFO  compiling root (1 scala source)
2022.06.02 20:24:17 INFO  time: compiled root in 0.14s
2022.06.02 20:24:27 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:59:7: stale bloop error: Not found: pass
      pass
      ^^^^
2022.06.02 20:24:27 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:143:9: stale bloop error: Found:    Time
Required: Int
        item.getProduct().getAge() 
        ^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 20:24:27 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:59:7: stale bloop error: Not found: pass
      pass
      ^^^^
2022.06.02 20:24:27 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:143:9: stale bloop error: Found:    Time
Required: Int
        item.getProduct().getAge() 
        ^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 20:24:28 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:59:7: stale bloop error: Not found: pass
      pass
      ^^^^
2022.06.02 20:24:28 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:143:9: stale bloop error: Found:    Time
Required: Int
        item.getProduct().getAge() 
        ^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 20:24:28 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:59:7: stale bloop error: Not found: pass
      pass
      ^^^^
2022.06.02 20:24:28 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:143:9: stale bloop error: Found:    Time
Required: Int
        item.getProduct().getAge() 
        ^^^^^^^^^^^^^^^^^^^^^^^^^^
2022.06.02 20:24:33 INFO  compiling root (1 scala source)
2022.06.02 20:24:33 INFO  time: compiled root in 0.16s
2022.06.02 20:25:04 INFO  compiling root (1 scala source)
2022.06.02 20:25:04 INFO  time: compiled root in 0.13s
2022.06.02 20:25:26 INFO  compiling root (1 scala source)
2022.06.02 20:25:26 INFO  time: compiled root in 0.19s
2022.06.02 20:25:30 INFO  compiling root (1 scala source)
2022.06.02 20:25:30 INFO  time: compiled root in 64ms
2022.06.02 20:25:33 INFO  compiling root (1 scala source)
2022.06.02 20:25:33 INFO  time: compiled root in 0.2s
2022.06.02 20:25:42 INFO  compiling root (1 scala source)
2022.06.02 20:25:42 INFO  time: compiled root in 0.14s
2022.06.02 20:25:58 INFO  compiling root (1 scala source)
2022.06.02 20:25:58 INFO  time: compiled root in 0.14s
2022.06.02 20:26:06 INFO  compiling root (1 scala source)
2022.06.02 20:26:06 INFO  time: compiled root in 57ms
2022.06.02 20:26:08 INFO  compiling root (1 scala source)
2022.06.02 20:26:08 INFO  time: compiled root in 0.15s
2022.06.02 20:26:25 INFO  compiling root (1 scala source)
2022.06.02 20:26:25 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 20:26:25 INFO  time: compiled root in 0.15s
2022.06.02 20:26:50 INFO  compiling root (1 scala source)
2022.06.02 20:26:50 INFO  time: compiled root in 0.14s
2022.06.02 20:26:55 INFO  compiling root (1 scala source)
2022.06.02 20:26:55 INFO  time: compiled root in 0.15s
2022.06.02 20:27:33 INFO  compiling root (1 scala source)
2022.06.02 20:27:33 INFO  time: compiled root in 0.17s
2022.06.02 20:27:46 INFO  compiling root (1 scala source)
2022.06.02 20:27:46 INFO  time: compiled root in 0.15s
2022.06.02 20:29:04 INFO  compiling root (1 scala source)
2022.06.02 20:29:04 INFO  time: compiled root in 48ms
2022.06.02 20:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:58:47: stale bloop error: expression expected but def found
    if this.toString() < other.toString() then
                                              ^
2022.06.02 20:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:153:3: stale bloop error: unindent expected, but eof found
  
  ^
2022.06.02 20:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:58:42: stale bloop warning: A pure expression does nothing in statement position; you may be omitting necessary parentheses
    if this.toString() < other.toString() then
                                         ^
2022.06.02 20:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:58:47: stale bloop error: expression expected but def found
    if this.toString() < other.toString() then
                                              ^
2022.06.02 20:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:153:3: stale bloop error: unindent expected, but eof found
  
  ^
2022.06.02 20:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:58:42: stale bloop warning: A pure expression does nothing in statement position; you may be omitting necessary parentheses
    if this.toString() < other.toString() then
                                         ^
2022.06.02 20:33:33 INFO  compiling root (1 scala source)
2022.06.02 20:33:33 INFO  time: compiled root in 0.15s
2022.06.02 20:34:01 INFO  compiling root (1 scala source)
2022.06.02 20:34:01 INFO  time: compiled root in 66ms
2022.06.02 20:34:05 INFO  compiling root (1 scala source)
2022.06.02 20:34:05 INFO  time: compiled root in 0.14s
2022.06.02 20:34:15 INFO  compiling root (1 scala source)
2022.06.02 20:34:15 INFO  time: compiled root in 0.13s
2022.06.02 20:34:27 INFO  compiling root (1 scala source)
2022.06.02 20:34:27 INFO  time: compiled root in 53ms
2022.06.02 20:34:42 INFO  compiling root (1 scala source)
2022.06.02 20:34:42 INFO  time: compiled root in 56ms
2022.06.02 20:34:46 INFO  compiling root (1 scala source)
2022.06.02 20:34:46 INFO  time: compiled root in 0.11s
2022.06.02 20:36:08 INFO  compiling root (1 scala source)
2022.06.02 20:36:08 INFO  time: compiled root in 0.15s
2022.06.02 20:36:30 INFO  compiling root (1 scala source)
2022.06.02 20:36:30 INFO  time: compiled root in 0.15s
2022.06.02 20:37:25 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 20:37:25 INFO  compiling root (1 scala source)
2022.06.02 20:37:25 INFO  time: compiled root in 0.14s
2022.06.02 20:37:46 INFO  compiling root (1 scala source)
2022.06.02 20:37:46 INFO  time: compiled root in 0.14s
2022.06.02 20:37:57 INFO  compiling root (1 scala source)
2022.06.02 20:37:57 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 20:37:57 INFO  time: compiled root in 0.15s
Jun 02, 2022 8:38:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13585
2022.06.02 20:39:04 INFO  compiling root (1 scala source)
2022.06.02 20:39:04 INFO  time: compiled root in 56ms
2022.06.02 20:39:37 INFO  compiling root (1 scala source)
2022.06.02 20:39:37 INFO  time: compiled root in 57ms
2022.06.02 20:39:49 INFO  compiling root (1 scala source)
2022.06.02 20:39:49 INFO  time: compiled root in 0.15s
2022.06.02 20:40:07 INFO  compiling root (1 scala source)
2022.06.02 20:40:07 INFO  time: compiled root in 0.15s
2022.06.02 20:41:13 INFO  compiling root (1 scala source)
2022.06.02 20:41:13 INFO  time: compiled root in 0.14s
2022.06.02 20:42:14 INFO  compiling root (1 scala source)
2022.06.02 20:42:14 INFO  time: compiled root in 0.14s
2022.06.02 20:43:09 INFO  compiling root (1 scala source)
2022.06.02 20:43:09 INFO  time: compiled root in 0.2s
2022.06.02 20:44:01 INFO  compiling root (1 scala source)
2022.06.02 20:44:01 INFO  time: compiled root in 0.15s
2022.06.02 20:44:03 INFO  compiling root (1 scala source)
2022.06.02 20:44:03 INFO  time: compiled root in 0.15s
2022.06.02 20:44:20 INFO  compiling root (1 scala source)
2022.06.02 20:44:20 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 20:44:20 INFO  time: compiled root in 0.15s
2022.06.02 20:46:10 INFO  compiling root (1 scala source)
2022.06.02 20:46:10 INFO  time: compiled root in 0.15s
2022.06.02 20:46:22 INFO  compiling root (1 scala source)
2022.06.02 20:46:22 INFO  time: compiled root in 0.15s
2022.06.02 20:47:54 INFO  compiling root (1 scala source)
2022.06.02 20:47:54 INFO  time: compiled root in 37ms
Jun 02, 2022 8:48:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11.0.14/lib/src.zip%21/java.base/java/util/Calendar.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n * (C) Copyright Taligent, Inc. 1996-1998 - All Rights Reserved\n * (C) Copyright IBM Corp. 1996-1998 - All Rights Reserved\n *\n *   The original version of this source code and documentation is copyrighted\n * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These\n * materials are provided under terms of a License Agreement between Taligent\n * and Sun. This technology is protected by multiple US and International\n * patents. This notice and attribution to Taligent may not be removed.\n *   Taligent is a registered trademark of Taligent, Inc.\n *\n */\n\npackage java.util;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OptionalDataException;\nimport java.io.Serializable;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.PermissionCollection;\nimport java.security.PrivilegedActionException;\nimport java.security.PrivilegedExceptionAction;\nimport java.security.ProtectionDomain;\nimport java.text.DateFormat;\nimport java.text.DateFormatSymbols;\nimport java.time.Instant;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport sun.util.BuddhistCalendar;\nimport sun.util.calendar.ZoneInfo;\nimport sun.util.locale.provider.CalendarDataUtility;\nimport sun.util.locale.provider.LocaleProviderAdapter;\nimport sun.util.locale.provider.TimeZoneNameUtility;\nimport sun.util.spi.CalendarProvider;\n\n/**\n * The \u003ccode\u003eCalendar\u003c/code\u003e class is an abstract class that provides methods\n * for converting between a specific instant in time and a set of {@link\n * #fields calendar fields} such as \u003ccode\u003eYEAR\u003c/code\u003e, \u003ccode\u003eMONTH\u003c/code\u003e,\n * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e, \u003ccode\u003eHOUR\u003c/code\u003e, and so on, and for\n * manipulating the calendar fields, such as getting the date of the next\n * week. An instant in time can be represented by a millisecond value that is\n * an offset from the \u003ca id\u003d\"Epoch\"\u003e\u003cem\u003eEpoch\u003c/em\u003e\u003c/a\u003e, January 1, 1970\n * 00:00:00.000 GMT (Gregorian).\n *\n * \u003cp\u003eThe class also provides additional fields and methods for\n * implementing a concrete calendar system outside the package. Those\n * fields and methods are defined as \u003ccode\u003eprotected\u003c/code\u003e.\n *\n * \u003cp\u003e\n * Like other locale-sensitive classes, \u003ccode\u003eCalendar\u003c/code\u003e provides a\n * class method, \u003ccode\u003egetInstance\u003c/code\u003e, for getting a generally useful\n * object of this type. \u003ccode\u003eCalendar\u003c/code\u003e\u0027s \u003ccode\u003egetInstance\u003c/code\u003e method\n * returns a \u003ccode\u003eCalendar\u003c/code\u003e object whose\n * calendar fields have been initialized with the current date and time:\n * \u003cblockquote\u003e\n * \u003cpre\u003e\n *     Calendar rightNow \u003d Calendar.getInstance();\n * \u003c/pre\u003e\n * \u003c/blockquote\u003e\n *\n * \u003cp\u003eA \u003ccode\u003eCalendar\u003c/code\u003e object can produce all the calendar field values\n * needed to implement the date-time formatting for a particular language and\n * calendar style (for example, Japanese-Gregorian, Japanese-Traditional).\n * \u003ccode\u003eCalendar\u003c/code\u003e defines the range of values returned by\n * certain calendar fields, as well as their meaning.  For example,\n * the first month of the calendar system has value \u003ccode\u003eMONTH \u003d\u003d\n * JANUARY\u003c/code\u003e for all calendars.  Other values are defined by the\n * concrete subclass, such as \u003ccode\u003eERA\u003c/code\u003e.  See individual field\n * documentation and subclass documentation for details.\n *\n * \u003ch3\u003eGetting and Setting Calendar Field Values\u003c/h3\u003e\n *\n * \u003cp\u003eThe calendar field values can be set by calling the \u003ccode\u003eset\u003c/code\u003e\n * methods. Any field values set in a \u003ccode\u003eCalendar\u003c/code\u003e will not be\n * interpreted until it needs to calculate its time value (milliseconds from\n * the Epoch) or values of the calendar fields. Calling the\n * \u003ccode\u003eget\u003c/code\u003e, \u003ccode\u003egetTimeInMillis\u003c/code\u003e, \u003ccode\u003egetTime\u003c/code\u003e,\n * \u003ccode\u003eadd\u003c/code\u003e and \u003ccode\u003eroll\u003c/code\u003e involves such calculation.\n *\n * \u003ch4\u003eLeniency\u003c/h4\u003e\n *\n * \u003cp\u003e\u003ccode\u003eCalendar\u003c/code\u003e has two modes for interpreting the calendar\n * fields, \u003cem\u003elenient\u003c/em\u003e and \u003cem\u003enon-lenient\u003c/em\u003e.  When a\n * \u003ccode\u003eCalendar\u003c/code\u003e is in lenient mode, it accepts a wider range of\n * calendar field values than it produces.  When a \u003ccode\u003eCalendar\u003c/code\u003e\n * recomputes calendar field values for return by \u003ccode\u003eget()\u003c/code\u003e, all of\n * the calendar fields are normalized. For example, a lenient\n * \u003ccode\u003eGregorianCalendar\u003c/code\u003e interprets \u003ccode\u003eMONTH \u003d\u003d JANUARY\u003c/code\u003e,\n * \u003ccode\u003eDAY_OF_MONTH \u003d\u003d 32\u003c/code\u003e as February 1.\n\n * \u003cp\u003eWhen a \u003ccode\u003eCalendar\u003c/code\u003e is in non-lenient mode, it throws an\n * exception if there is any inconsistency in its calendar fields. For\n * example, a \u003ccode\u003eGregorianCalendar\u003c/code\u003e always produces\n * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e values between 1 and the length of the month. A\n * non-lenient \u003ccode\u003eGregorianCalendar\u003c/code\u003e throws an exception upon\n * calculating its time or calendar field values if any out-of-range field\n * value has been set.\n *\n * \u003ch4\u003e\u003ca id\u003d\"first_week\"\u003eFirst Week\u003c/a\u003e\u003c/h4\u003e\n *\n * \u003ccode\u003eCalendar\u003c/code\u003e defines a locale-specific seven day week using two\n * parameters: the first day of the week and the minimal days in first week\n * (from 1 to 7).  These numbers are taken from the locale resource data or the\n * locale itself when a {@code Calendar} is constructed. If the designated\n * locale contains \"fw\" and/or \"rg\" \u003ca href\u003d\"./Locale.html#def_locale_extension\"\u003e\n * Unicode extensions\u003c/a\u003e, the first day of the week will be obtained according to\n * those extensions. If both \"fw\" and \"rg\" are specified, the value from the \"fw\"\n * extension supersedes the implicit one from the \"rg\" extension.\n * They may also be specified explicitly through the methods for setting their\n * values.\n *\n * \u003cp\u003eWhen setting or getting the \u003ccode\u003eWEEK_OF_MONTH\u003c/code\u003e or\n * \u003ccode\u003eWEEK_OF_YEAR\u003c/code\u003e fields, \u003ccode\u003eCalendar\u003c/code\u003e must determine the\n * first week of the month or year as a reference point.  The first week of a\n * month or year is defined as the earliest seven day period beginning on\n * \u003ccode\u003egetFirstDayOfWeek()\u003c/code\u003e and containing at least\n * \u003ccode\u003egetMinimalDaysInFirstWeek()\u003c/code\u003e days of that month or year.  Weeks\n * numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow\n * it.  Note that the normalized numbering returned by \u003ccode\u003eget()\u003c/code\u003e may be\n * different.  For example, a specific \u003ccode\u003eCalendar\u003c/code\u003e subclass may\n * designate the week before week 1 of a year as week \u003ccode\u003e\u003ci\u003en\u003c/i\u003e\u003c/code\u003e of\n * the previous year.\n *\n * \u003ch4\u003eCalendar Fields Resolution\u003c/h4\u003e\n *\n * When computing a date and time from the calendar fields, there\n * may be insufficient information for the computation (such as only\n * year and month with no day of month), or there may be inconsistent\n * information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15,\n * 1996 is actually a Monday). \u003ccode\u003eCalendar\u003c/code\u003e will resolve\n * calendar field values to determine the date and time in the\n * following way.\n *\n * \u003cp\u003e\u003ca id\u003d\"resolution\"\u003eIf there is any conflict in calendar field values,\n * \u003ccode\u003eCalendar\u003c/code\u003e gives priorities to calendar fields that have been set\n * more recently.\u003c/a\u003e The following are the default combinations of the\n * calendar fields. The most recent combination, as determined by the\n * most recently set single field, will be used.\n *\n * \u003cp\u003e\u003ca id\u003d\"date_resolution\"\u003eFor the date fields\u003c/a\u003e:\n * \u003cblockquote\u003e\n * \u003cpre\u003e\n * YEAR + MONTH + DAY_OF_MONTH\n * YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK\n * YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK\n * YEAR + DAY_OF_YEAR\n * YEAR + DAY_OF_WEEK + WEEK_OF_YEAR\n * \u003c/pre\u003e\u003c/blockquote\u003e\n *\n * \u003ca id\u003d\"time_resolution\"\u003eFor the time of day fields\u003c/a\u003e:\n * \u003cblockquote\u003e\n * \u003cpre\u003e\n * HOUR_OF_DAY\n * AM_PM + HOUR\n * \u003c/pre\u003e\u003c/blockquote\u003e\n *\n * \u003cp\u003eIf there are any calendar fields whose values haven\u0027t been set in the selected\n * field combination, \u003ccode\u003eCalendar\u003c/code\u003e uses their default values. The default\n * value of each field may vary by concrete calendar systems. For example, in\n * \u003ccode\u003eGregorianCalendar\u003c/code\u003e, the default of a field is the same as that\n * of the start of the Epoch: i.e., \u003ccode\u003eYEAR \u003d 1970\u003c/code\u003e, \u003ccode\u003eMONTH \u003d\n * JANUARY\u003c/code\u003e, \u003ccode\u003eDAY_OF_MONTH \u003d 1\u003c/code\u003e, etc.\n *\n * \u003cp\u003e\n * \u003cstrong\u003eNote:\u003c/strong\u003e There are certain possible ambiguities in\n * interpretation of certain singular times, which are resolved in the\n * following ways:\n * \u003col\u003e\n *     \u003cli\u003e 23:59 is the last minute of the day and 00:00 is the first\n *          minute of the next day. Thus, 23:59 on Dec 31, 1999 \u0026lt; 00:00 on\n *          Jan 1, 2000 \u0026lt; 00:01 on Jan 1, 2000.\n *\n *     \u003cli\u003e Although historically not precise, midnight also belongs to \"am\",\n *          and noon belongs to \"pm\", so on the same day,\n *          12:00 am (midnight) \u0026lt; 12:01 am, and 12:00 pm (noon) \u0026lt; 12:01 pm\n * \u003c/ol\u003e\n *\n * \u003cp\u003e\n * The date or time format strings are not part of the definition of a\n * calendar, as those must be modifiable or overridable by the user at\n * runtime. Use {@link DateFormat}\n * to format dates.\n *\n * \u003ch4\u003eField Manipulation\u003c/h4\u003e\n *\n * The calendar fields can be changed using three methods:\n * \u003ccode\u003eset()\u003c/code\u003e, \u003ccode\u003eadd()\u003c/code\u003e, and \u003ccode\u003eroll()\u003c/code\u003e.\n *\n * \u003cp\u003e\u003cstrong\u003e\u003ccode\u003eset(f, value)\u003c/code\u003e\u003c/strong\u003e changes calendar field\n * \u003ccode\u003ef\u003c/code\u003e to \u003ccode\u003evalue\u003c/code\u003e.  In addition, it sets an\n * internal member variable to indicate that calendar field \u003ccode\u003ef\u003c/code\u003e has\n * been changed. Although calendar field \u003ccode\u003ef\u003c/code\u003e is changed immediately,\n * the calendar\u0027s time value in milliseconds is not recomputed until the next call to\n * \u003ccode\u003eget()\u003c/code\u003e, \u003ccode\u003egetTime()\u003c/code\u003e, \u003ccode\u003egetTimeInMillis()\u003c/code\u003e,\n * \u003ccode\u003eadd()\u003c/code\u003e, or \u003ccode\u003eroll()\u003c/code\u003e is made. Thus, multiple calls to\n * \u003ccode\u003eset()\u003c/code\u003e do not trigger multiple, unnecessary\n * computations. As a result of changing a calendar field using\n * \u003ccode\u003eset()\u003c/code\u003e, other calendar fields may also change, depending on the\n * calendar field, the calendar field value, and the calendar system. In addition,\n * \u003ccode\u003eget(f)\u003c/code\u003e will not necessarily return \u003ccode\u003evalue\u003c/code\u003e set by\n * the call to the \u003ccode\u003eset\u003c/code\u003e method\n * after the calendar fields have been recomputed. The specifics are determined by\n * the concrete calendar class.\u003c/p\u003e\n *\n * \u003cp\u003e\u003cem\u003eExample\u003c/em\u003e: Consider a \u003ccode\u003eGregorianCalendar\u003c/code\u003e\n * originally set to August 31, 1999. Calling \u003ccode\u003eset(Calendar.MONTH,\n * Calendar.SEPTEMBER)\u003c/code\u003e sets the date to September 31,\n * 1999. This is a temporary internal representation that resolves to\n * October 1, 1999 if \u003ccode\u003egetTime()\u003c/code\u003eis then called. However, a\n * call to \u003ccode\u003eset(Calendar.DAY_OF_MONTH, 30)\u003c/code\u003e before the call to\n * \u003ccode\u003egetTime()\u003c/code\u003e sets the date to September 30, 1999, since\n * no recomputation occurs after \u003ccode\u003eset()\u003c/code\u003e itself.\u003c/p\u003e\n *\n * \u003cp\u003e\u003cstrong\u003e\u003ccode\u003eadd(f, delta)\u003c/code\u003e\u003c/strong\u003e adds \u003ccode\u003edelta\u003c/code\u003e\n * to field \u003ccode\u003ef\u003c/code\u003e.  This is equivalent to calling \u003ccode\u003eset(f,\n * get(f) + delta)\u003c/code\u003e with two adjustments:\u003c/p\u003e\n *\n * \u003cblockquote\u003e\n *   \u003cp\u003e\u003cstrong\u003eAdd rule 1\u003c/strong\u003e. The value of field \u003ccode\u003ef\u003c/code\u003e\n *   after the call minus the value of field \u003ccode\u003ef\u003c/code\u003e before the\n *   call is \u003ccode\u003edelta\u003c/code\u003e, modulo any overflow that has occurred in\n *   field \u003ccode\u003ef\u003c/code\u003e. Overflow occurs when a field value exceeds its\n *   range and, as a result, the next larger field is incremented or\n *   decremented and the field value is adjusted back into its range.\u003c/p\u003e\n *\n *   \u003cp\u003e\u003cstrong\u003eAdd rule 2\u003c/strong\u003e. If a smaller field is expected to be\n *   invariant, but it is impossible for it to be equal to its\n *   prior value because of changes in its minimum or maximum after field\n *   \u003ccode\u003ef\u003c/code\u003e is changed or other constraints, such as time zone\n *   offset changes, then its value is adjusted to be as close\n *   as possible to its expected value. A smaller field represents a\n *   smaller unit of time. \u003ccode\u003eHOUR\u003c/code\u003e is a smaller field than\n *   \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e. No adjustment is made to smaller fields\n *   that are not expected to be invariant. The calendar system\n *   determines what fields are expected to be invariant.\u003c/p\u003e\n * \u003c/blockquote\u003e\n *\n * \u003cp\u003eIn addition, unlike \u003ccode\u003eset()\u003c/code\u003e, \u003ccode\u003eadd()\u003c/code\u003e forces\n * an immediate recomputation of the calendar\u0027s milliseconds and all\n * fields.\u003c/p\u003e\n *\n * \u003cp\u003e\u003cem\u003eExample\u003c/em\u003e: Consider a \u003ccode\u003eGregorianCalendar\u003c/code\u003e\n * originally set to August 31, 1999. Calling \u003ccode\u003eadd(Calendar.MONTH,\n * 13)\u003c/code\u003e sets the calendar to September 30, 2000. \u003cstrong\u003eAdd rule\n * 1\u003c/strong\u003e sets the \u003ccode\u003eMONTH\u003c/code\u003e field to September, since\n * adding 13 months to August gives September of the next year. Since\n * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e cannot be 31 in September in a\n * \u003ccode\u003eGregorianCalendar\u003c/code\u003e, \u003cstrong\u003eadd rule 2\u003c/strong\u003e sets the\n * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e to 30, the closest possible value. Although\n * it is a smaller field, \u003ccode\u003eDAY_OF_WEEK\u003c/code\u003e is not adjusted by\n * rule 2, since it is expected to change when the month changes in a\n * \u003ccode\u003eGregorianCalendar\u003c/code\u003e.\u003c/p\u003e\n *\n * \u003cp\u003e\u003cstrong\u003e\u003ccode\u003eroll(f, delta)\u003c/code\u003e\u003c/strong\u003e adds\n * \u003ccode\u003edelta\u003c/code\u003e to field \u003ccode\u003ef\u003c/code\u003e without changing larger\n * fields. This is equivalent to calling \u003ccode\u003eadd(f, delta)\u003c/code\u003e with\n * the following adjustment:\u003c/p\u003e\n *\n * \u003cblockquote\u003e\n *   \u003cp\u003e\u003cstrong\u003eRoll rule\u003c/strong\u003e. Larger fields are unchanged after the\n *   call. A larger field represents a larger unit of\n *   time. \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e is a larger field than\n *   \u003ccode\u003eHOUR\u003c/code\u003e.\u003c/p\u003e\n * \u003c/blockquote\u003e\n *\n * \u003cp\u003e\u003cem\u003eExample\u003c/em\u003e: See {@link java.util.GregorianCalendar#roll(int, int)}.\n *\n * \u003cp\u003e\u003cstrong\u003eUsage model\u003c/strong\u003e. To motivate the behavior of\n * \u003ccode\u003eadd()\u003c/code\u003e and \u003ccode\u003eroll()\u003c/code\u003e, consider a user interface\n * component with increment and decrement buttons for the month, day, and\n * year, and an underlying \u003ccode\u003eGregorianCalendar\u003c/code\u003e. If the\n * interface reads January 31, 1999 and the user presses the month\n * increment button, what should it read? If the underlying\n * implementation uses \u003ccode\u003eset()\u003c/code\u003e, it might read March 3, 1999. A\n * better result would be February 28, 1999. Furthermore, if the user\n * presses the month increment button again, it should read March 31,\n * 1999, not March 28, 1999. By saving the original date and using either\n * \u003ccode\u003eadd()\u003c/code\u003e or \u003ccode\u003eroll()\u003c/code\u003e, depending on whether larger\n * fields should be affected, the user interface can behave as most users\n * will intuitively expect.\u003c/p\u003e\n *\n * @see          java.lang.System#currentTimeMillis()\n * @see          Date\n * @see          GregorianCalendar\n * @see          TimeZone\n * @see          java.text.DateFormat\n * @author Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu\n * @since 1.1\n */\npublic abstract class Calendar implements Serializable, Cloneable, Comparable\u003cCalendar\u003e {\n\n    // Data flow in Calendar\n    // ---------------------\n\n    // The current time is represented in two ways by Calendar: as UTC\n    // milliseconds from the epoch (1 January 1970 0:00 UTC), and as local\n    // fields such as MONTH, HOUR, AM_PM, etc.  It is possible to compute the\n    // millis from the fields, and vice versa.  The data needed to do this\n    // conversion is encapsulated by a TimeZone object owned by the Calendar.\n    // The data provided by the TimeZone object may also be overridden if the\n    // user sets the ZONE_OFFSET and/or DST_OFFSET fields directly. The class\n    // keeps track of what information was most recently set by the caller, and\n    // uses that to compute any other information as needed.\n\n    // If the user sets the fields using set(), the data flow is as follows.\n    // This is implemented by the Calendar subclass\u0027s computeTime() method.\n    // During this process, certain fields may be ignored.  The disambiguation\n    // algorithm for resolving which fields to pay attention to is described\n    // in the class documentation.\n\n    //   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)\n    //           |\n    //           | Using Calendar-specific algorithm\n    //           V\n    //   local standard millis\n    //           |\n    //           | Using TimeZone or user-set ZONE_OFFSET / DST_OFFSET\n    //           V\n    //   UTC millis (in time data member)\n\n    // If the user sets the UTC millis using setTime() or setTimeInMillis(),\n    // the data flow is as follows.  This is implemented by the Calendar\n    // subclass\u0027s computeFields() method.\n\n    //   UTC millis (in time data member)\n    //           |\n    //           | Using TimeZone getOffset()\n    //           V\n    //   local standard millis\n    //           |\n    //           | Using Calendar-specific algorithm\n    //           V\n    //   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)\n\n    // In general, a round trip from fields, through local and UTC millis, and\n    // back out to fields is made when necessary.  This is implemented by the\n    // complete() method.  Resolving a partial set of fields into a UTC millis\n    // value allows all remaining fields to be generated from that value.  If\n    // the Calendar is lenient, the fields are also renormalized to standard\n    // ranges when they are regenerated.\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * era, e.g., AD or BC in the Julian calendar. This is a calendar-specific\n     * value; see subclass documentation.\n     *\n     * @see GregorianCalendar#AD\n     * @see GregorianCalendar#BC\n     */\n    public static final int ERA \u003d 0;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * year. This is a calendar-specific value; see subclass documentation.\n     */\n    public static final int YEAR \u003d 1;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * month. This is a calendar-specific value. The first month of\n     * the year in the Gregorian and Julian calendars is\n     * \u003ccode\u003eJANUARY\u003c/code\u003e which is 0; the last depends on the number\n     * of months in a year.\n     *\n     * @see #JANUARY\n     * @see #FEBRUARY\n     * @see #MARCH\n     * @see #APRIL\n     * @see #MAY\n     * @see #JUNE\n     * @see #JULY\n     * @see #AUGUST\n     * @see #SEPTEMBER\n     * @see #OCTOBER\n     * @see #NOVEMBER\n     * @see #DECEMBER\n     * @see #UNDECIMBER\n     */\n    public static final int MONTH \u003d 2;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * week number within the current year.  The first week of the year, as\n     * defined by \u003ccode\u003egetFirstDayOfWeek()\u003c/code\u003e and\n     * \u003ccode\u003egetMinimalDaysInFirstWeek()\u003c/code\u003e, has value 1.  Subclasses define\n     * the value of \u003ccode\u003eWEEK_OF_YEAR\u003c/code\u003e for days before the first week of\n     * the year.\n     *\n     * @see #getFirstDayOfWeek\n     * @see #getMinimalDaysInFirstWeek\n     */\n    public static final int WEEK_OF_YEAR \u003d 3;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * week number within the current month.  The first week of the month, as\n     * defined by \u003ccode\u003egetFirstDayOfWeek()\u003c/code\u003e and\n     * \u003ccode\u003egetMinimalDaysInFirstWeek()\u003c/code\u003e, has value 1.  Subclasses define\n     * the value of \u003ccode\u003eWEEK_OF_MONTH\u003c/code\u003e for days before the first week of\n     * the month.\n     *\n     * @see #getFirstDayOfWeek\n     * @see #getMinimalDaysInFirstWeek\n     */\n    public static final int WEEK_OF_MONTH \u003d 4;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * day of the month. This is a synonym for \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e.\n     * The first day of the month has value 1.\n     *\n     * @see #DAY_OF_MONTH\n     */\n    public static final int DATE \u003d 5;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * day of the month. This is a synonym for \u003ccode\u003eDATE\u003c/code\u003e.\n     * The first day of the month has value 1.\n     *\n     * @see #DATE\n     */\n    public static final int DAY_OF_MONTH \u003d 5;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the day\n     * number within the current year.  The first day of the year has value 1.\n     */\n    public static final int DAY_OF_YEAR \u003d 6;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the day\n     * of the week.  This field takes values \u003ccode\u003eSUNDAY\u003c/code\u003e,\n     * \u003ccode\u003eMONDAY\u003c/code\u003e, \u003ccode\u003eTUESDAY\u003c/code\u003e, \u003ccode\u003eWEDNESDAY\u003c/code\u003e,\n     * \u003ccode\u003eTHURSDAY\u003c/code\u003e, \u003ccode\u003eFRIDAY\u003c/code\u003e, and \u003ccode\u003eSATURDAY\u003c/code\u003e.\n     *\n     * @see #SUNDAY\n     * @see #MONDAY\n     * @see #TUESDAY\n     * @see #WEDNESDAY\n     * @see #THURSDAY\n     * @see #FRIDAY\n     * @see #SATURDAY\n     */\n    public static final int DAY_OF_WEEK \u003d 7;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * ordinal number of the day of the week within the current month. Together\n     * with the \u003ccode\u003eDAY_OF_WEEK\u003c/code\u003e field, this uniquely specifies a day\n     * within a month.  Unlike \u003ccode\u003eWEEK_OF_MONTH\u003c/code\u003e and\n     * \u003ccode\u003eWEEK_OF_YEAR\u003c/code\u003e, this field\u0027s value does \u003cem\u003enot\u003c/em\u003e depend on\n     * \u003ccode\u003egetFirstDayOfWeek()\u003c/code\u003e or\n     * \u003ccode\u003egetMinimalDaysInFirstWeek()\u003c/code\u003e.  \u003ccode\u003eDAY_OF_MONTH 1\u003c/code\u003e\n     * through \u003ccode\u003e7\u003c/code\u003e always correspond to \u003ccode\u003eDAY_OF_WEEK_IN_MONTH\n     * 1\u003c/code\u003e; \u003ccode\u003e8\u003c/code\u003e through \u003ccode\u003e14\u003c/code\u003e correspond to\n     * \u003ccode\u003eDAY_OF_WEEK_IN_MONTH 2\u003c/code\u003e, and so on.\n     * \u003ccode\u003eDAY_OF_WEEK_IN_MONTH 0\u003c/code\u003e indicates the week before\n     * \u003ccode\u003eDAY_OF_WEEK_IN_MONTH 1\u003c/code\u003e.  Negative values count back from the\n     * end of the month, so the last Sunday of a month is specified as\n     * \u003ccode\u003eDAY_OF_WEEK \u003d SUNDAY, DAY_OF_WEEK_IN_MONTH \u003d -1\u003c/code\u003e.  Because\n     * negative values count backward they will usually be aligned differently\n     * within the month than positive values.  For example, if a month has 31\n     * days, \u003ccode\u003eDAY_OF_WEEK_IN_MONTH -1\u003c/code\u003e will overlap\n     * \u003ccode\u003eDAY_OF_WEEK_IN_MONTH 5\u003c/code\u003e and the end of \u003ccode\u003e4\u003c/code\u003e.\n     *\n     * @see #DAY_OF_WEEK\n     * @see #WEEK_OF_MONTH\n     */\n    public static final int DAY_OF_WEEK_IN_MONTH \u003d 8;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating\n     * whether the \u003ccode\u003eHOUR\u003c/code\u003e is before or after noon.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eAM_PM\u003c/code\u003e is \u003ccode\u003ePM\u003c/code\u003e.\n     *\n     * @see #AM\n     * @see #PM\n     * @see #HOUR\n     */\n    public static final int AM_PM \u003d 9;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * hour of the morning or afternoon. \u003ccode\u003eHOUR\u003c/code\u003e is used for the\n     * 12-hour clock (0 - 11). Noon and midnight are represented by 0, not by 12.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eHOUR\u003c/code\u003e is 10.\n     *\n     * @see #AM_PM\n     * @see #HOUR_OF_DAY\n     */\n    public static final int HOUR \u003d 10;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * hour of the day. \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e is used for the 24-hour clock.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e is 22.\n     *\n     * @see #HOUR\n     */\n    public static final int HOUR_OF_DAY \u003d 11;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * minute within the hour.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eMINUTE\u003c/code\u003e is 4.\n     */\n    public static final int MINUTE \u003d 12;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * second within the minute.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eSECOND\u003c/code\u003e is 15.\n     */\n    public static final int SECOND \u003d 13;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * millisecond within the second.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eMILLISECOND\u003c/code\u003e is 250.\n     */\n    public static final int MILLISECOND \u003d 14;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e\n     * indicating the raw offset from GMT in milliseconds.\n     * \u003cp\u003e\n     * This field reflects the correct GMT offset value of the time\n     * zone of this \u003ccode\u003eCalendar\u003c/code\u003e if the\n     * \u003ccode\u003eTimeZone\u003c/code\u003e implementation subclass supports\n     * historical GMT offset changes.\n     */\n    public static final int ZONE_OFFSET \u003d 15;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * daylight saving offset in milliseconds.\n     * \u003cp\u003e\n     * This field reflects the correct daylight saving offset value of\n     * the time zone of this \u003ccode\u003eCalendar\u003c/code\u003e if the\n     * \u003ccode\u003eTimeZone\u003c/code\u003e implementation subclass supports\n     * historical Daylight Saving Time schedule changes.\n     */\n    public static final int DST_OFFSET \u003d 16;\n\n    /**\n     * The number of distinct fields recognized by \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e.\n     * Field numbers range from \u003ccode\u003e0..FIELD_COUNT-1\u003c/code\u003e.\n     */\n    public static final int FIELD_COUNT \u003d 17;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Sunday.\n     */\n    public static final int SUNDAY \u003d 1;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Monday.\n     */\n    public static final int MONDAY \u003d 2;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Tuesday.\n     */\n    public static final int TUESDAY \u003d 3;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Wednesday.\n     */\n    public static final int WEDNESDAY \u003d 4;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Thursday.\n     */\n    public static final int THURSDAY \u003d 5;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Friday.\n     */\n    public static final int FRIDAY \u003d 6;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Saturday.\n     */\n    public static final int SATURDAY \u003d 7;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * first month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int JANUARY \u003d 0;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * second month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int FEBRUARY \u003d 1;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * third month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int MARCH \u003d 2;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * fourth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int APRIL \u003d 3;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * fifth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int MAY \u003d 4;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * sixth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int JUNE \u003d 5;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * seventh month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int JULY \u003d 6;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * eighth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int AUGUST \u003d 7;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * ninth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int SEPTEMBER \u003d 8;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * tenth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int OCTOBER \u003d 9;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * eleventh month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int NOVEMBER \u003d 10;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * twelfth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int DECEMBER \u003d 11;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * thirteenth month of the year. Although \u003ccode\u003eGregorianCalendar\u003c/code\u003e\n     * does not use this value, lunar calendars do.\n     */\n    public static final int UNDECIMBER \u003d 12;\n\n    /**\n     * Value of the {@link #AM_PM} field indicating the\n     * period of the day from midnight to just before noon.\n     */\n    public static final int AM \u003d 0;\n\n    /**\n     * Value of the {@link #AM_PM} field indicating the\n     * period of the day from noon to just before midnight.\n     */\n    public static final int PM \u003d 1;\n\n    /**\n     * A style specifier for {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating names in all styles, such as\n     * \"January\" and \"Jan\".\n     *\n     * @see #SHORT_FORMAT\n     * @see #LONG_FORMAT\n     * @see #SHORT_STANDALONE\n     * @see #LONG_STANDALONE\n     * @see #SHORT\n     * @see #LONG\n     * @since 1.6\n     */\n    public static final int ALL_STYLES \u003d 0;\n\n    static final int STANDALONE_MASK \u003d 0x8000;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} equivalent to {@link #SHORT_FORMAT}.\n     *\n     * @see #SHORT_STANDALONE\n     * @see #LONG\n     * @since 1.6\n     */\n    public static final int SHORT \u003d 1;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} equivalent to {@link #LONG_FORMAT}.\n     *\n     * @see #LONG_STANDALONE\n     * @see #SHORT\n     * @since 1.6\n     */\n    public static final int LONG \u003d 2;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a narrow name used for format. Narrow names\n     * are typically single character strings, such as \"M\" for Monday.\n     *\n     * @see #NARROW_STANDALONE\n     * @see #SHORT_FORMAT\n     * @see #LONG_FORMAT\n     * @since 1.8\n     */\n    public static final int NARROW_FORMAT \u003d 4;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a narrow name independently. Narrow names\n     * are typically single character strings, such as \"M\" for Monday.\n     *\n     * @see #NARROW_FORMAT\n     * @see #SHORT_STANDALONE\n     * @see #LONG_STANDALONE\n     * @since 1.8\n     */\n    public static final int NARROW_STANDALONE \u003d NARROW_FORMAT | STANDALONE_MASK;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a short name used for format.\n     *\n     * @see #SHORT_STANDALONE\n     * @see #LONG_FORMAT\n     * @see #LONG_STANDALONE\n     * @since 1.8\n     */\n    public static final int SHORT_FORMAT \u003d 1;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a long name used for format.\n     *\n     * @see #LONG_STANDALONE\n     * @see #SHORT_FORMAT\n     * @see #SHORT_STANDALONE\n     * @since 1.8\n     */\n    public static final int LONG_FORMAT \u003d 2;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a short name used independently,\n     * such as a month abbreviation as calendar headers.\n     *\n     * @see #SHORT_FORMAT\n     * @see #LONG_FORMAT\n     * @see #LONG_STANDALONE\n     * @since 1.8\n     */\n    public static final int SHORT_STANDALONE \u003d SHORT | STANDALONE_MASK;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a long name used independently,\n     * such as a month name as calendar headers.\n     *\n     * @see #LONG_FORMAT\n     * @see #SHORT_FORMAT\n     * @see #SHORT_STANDALONE\n     * @since 1.8\n     */\n    public static final int LONG_STANDALONE \u003d LONG | STANDALONE_MASK;\n\n    // Internal notes:\n    // Calendar contains two kinds of time representations: current \"time\" in\n    // milliseconds, and a set of calendar \"fields\" representing the current time.\n    // The two representations are usually in sync, but can get out of sync\n    // as follows.\n    // 1. Initially, no fields are set, and the time is invalid.\n    // 2. If the time is set, all fields are computed and in sync.\n    // 3. If a single field is set, the time is invalid.\n    // Recomputation of the time and fields happens when the object needs\n    // to return a result to the user, or use a result for a computation.\n\n    /**\n     * The calendar field values for the currently set time for this calendar.\n     * This is an array of \u003ccode\u003eFIELD_COUNT\u003c/code\u003e integers, with index values\n     * \u003ccode\u003eERA\u003c/code\u003e through \u003ccode\u003eDST_OFFSET\u003c/code\u003e.\n     * @serial\n     */\n    @SuppressWarnings(\"ProtectedField\")\n    protected int           fields[];\n\n    /**\n     * The flags which tell if a specified calendar field for the calendar is set.\n     * A new object has no fields set.  After the first call to a method\n     * which generates the fields, they all remain set after that.\n     * This is an array of \u003ccode\u003eFIELD_COUNT\u003c/code\u003e booleans, with index values\n     * \u003ccode\u003eERA\u003c/code\u003e through \u003ccode\u003eDST_OFFSET\u003c/code\u003e.\n     * @serial\n     */\n    @SuppressWarnings(\"ProtectedField\")\n    protected boolean       isSet[];\n\n    /**\n     * Pseudo-time-stamps which specify when each field was set. There\n     * are two special values, UNSET and COMPUTED. Values from\n     * MINIMUM_USER_SET to Integer.MAX_VALUE are legal user set values.\n     */\n    private transient int   stamp[];\n\n    /**\n     * The currently set time for this calendar, expressed in milliseconds after\n     * January 1, 1970, 0:00:00 GMT.\n     * @see #isTimeSet\n     * @serial\n     */\n    @SuppressWarnings(\"ProtectedField\")\n    protected long          time;\n\n    /**\n     * True if then the value of \u003ccode\u003etime\u003c/code\u003e is valid.\n     * The time is made invalid by a change to an item of \u003ccode\u003efield[]\u003c/code\u003e.\n     * @see #time\n     * @serial\n     */\n    @SuppressWarnings(\"ProtectedField\")\n    protected boolean       isTimeSet;\n\n    /**\n     * True if \u003ccode\u003efields[]\u003c/code\u003e are in sync with the currently set time.\n     * If false, then the next attempt to get the value of a field will\n     * force a recomputation of all fields from the current value of\n     * \u003ccode\u003etime\u003c/code\u003e.\n     * @serial\n     */\n    @SuppressWarnings(\"ProtectedField\")\n    protected boolean       areFieldsSet;\n\n    /**\n     * True if all fields have been set.\n     * @serial\n     */\n    transient boolean       areAllFieldsSet;\n\n    /**\n     * \u003ccode\u003eTrue\u003c/code\u003e if this calendar allows out-of-range field values during computation\n     * of \u003ccode\u003etime\u003c/code\u003e from \u003ccode\u003efields[]\u003c/code\u003e.\n     * @see #setLenient\n     * @see #isLenient\n     * @serial\n     */\n    private boolean         lenient \u003d true;\n\n    /**\n     * The \u003ccode\u003eTimeZone\u003c/code\u003e used by this calendar. \u003ccode\u003eCalendar\u003c/code\u003e\n     * uses the time zone data to translate between locale and GMT time.\n     * @serial\n     */\n    private TimeZone        zone;\n\n    /**\n     * \u003ccode\u003eTrue\u003c/code\u003e if zone references to a shared TimeZone object.\n     */\n    private transient boolean sharedZone \u003d false;\n\n    /**\n     * The first day of the week, with possible values \u003ccode\u003eSUNDAY\u003c/code\u003e,\n     * \u003ccode\u003eMONDAY\u003c/code\u003e, etc.  This is a locale-dependent value.\n     * @serial\n     */\n    private int             firstDayOfWeek;\n\n    /**\n     * The number of days required for the first week in a month or year,\n     * with possible values from 1 to 7.  This is a locale-dependent value.\n     * @serial\n     */\n    private int             minimalDaysInFirstWeek;\n\n    /**\n     * Cache to hold the firstDayOfWeek and minimalDaysInFirstWeek\n     * of a Locale.\n     */\n    private static final ConcurrentMap\u003cLocale, int[]\u003e cachedLocaleData\n        \u003d new ConcurrentHashMap\u003c\u003e(3);\n\n    // Special values of stamp[]\n    /**\n     * The corresponding fields[] has no value.\n     */\n    private static final int        UNSET \u003d 0;\n\n    /**\n     * The value of the corresponding fields[] has been calculated internally.\n     */\n    private static final int        COMPUTED \u003d 1;\n\n    /**\n     * The value of the corresponding fields[] has been set externally. Stamp\n     * values which are greater than 1 represents the (pseudo) time when the\n     * corresponding fields[] value was set.\n     */\n    private static final int        MINIMUM_USER_STAMP \u003d 2;\n\n    /**\n     * The mask value that represents all of the fields.\n     */\n    static final int ALL_FIELDS \u003d (1 \u003c\u003c FIELD_COUNT) - 1;\n\n    /**\n     * The next available value for \u003ccode\u003estamp[]\u003c/code\u003e, an internal array.\n     * This actually should not be written out to the stream, and will probably\n     * be removed from the stream in the near future.  In the meantime,\n     * a value of \u003ccode\u003eMINIMUM_USER_STAMP\u003c/code\u003e should be used.\n     * @serial\n     */\n    private int             nextStamp \u003d MINIMUM_USER_STAMP;\n\n    // the internal serial version which says which version was written\n    // - 0 (default) for version up to JDK 1.1.5\n    // - 1 for version from JDK 1.1.6, which writes a correct \u0027time\u0027 value\n    //     as well as compatible values for other fields.  This is a\n    //     transitional format.\n    // - 2 (not implemented yet) a future version, in which fields[],\n    //     areFieldsSet, and isTimeSet become transient, and isSet[] is\n    //     removed. In JDK 1.1.6 we write a format compatible with version 2.\n    static final int        currentSerialVersion \u003d 1;\n\n    /**\n     * The version of the serialized data on the stream.  Possible values:\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003cb\u003e0\u003c/b\u003e or not present on stream\u003c/dt\u003e\n     * \u003cdd\u003e\n     * JDK 1.1.5 or earlier.\n     * \u003c/dd\u003e\n     * \u003cdt\u003e\u003cb\u003e1\u003c/b\u003e\u003c/dt\u003e\n     * \u003cdd\u003e\n     * JDK 1.1.6 or later.  Writes a correct \u0027time\u0027 value\n     * as well as compatible values for other fields.  This is a\n     * transitional format.\n     * \u003c/dd\u003e\n     * \u003c/dl\u003e\n     * When streaming out this class, the most recent format\n     * and the highest allowable \u003ccode\u003eserialVersionOnStream\u003c/code\u003e\n     * is written.\n     * @serial\n     * @since 1.1.6\n     */\n    private int             serialVersionOnStream \u003d currentSerialVersion;\n\n    // Proclaim serialization compatibility with JDK 1.1\n    static final long       serialVersionUID \u003d -1807547505821590642L;\n\n    // Mask values for calendar fields\n    @SuppressWarnings(\"PointlessBitwiseExpression\")\n    static final int ERA_MASK           \u003d (1 \u003c\u003c ERA);\n    static final int YEAR_MASK          \u003d (1 \u003c\u003c YEAR);\n    static final int MONTH_MASK         \u003d (1 \u003c\u003c MONTH);\n    static final int WEEK_OF_YEAR_MASK  \u003d (1 \u003c\u003c WEEK_OF_YEAR);\n    static final int WEEK_OF_MONTH_MASK \u003d (1 \u003c\u003c WEEK_OF_MONTH);\n    static final int DAY_OF_MONTH_MASK  \u003d (1 \u003c\u003c DAY_OF_MONTH);\n    static final int DATE_MASK          \u003d DAY_OF_MONTH_MASK;\n    static final int DAY_OF_YEAR_MASK   \u003d (1 \u003c\u003c DAY_OF_YEAR);\n    static final int DAY_OF_WEEK_MASK   \u003d (1 \u003c\u003c DAY_OF_WEEK);\n    static final int DAY_OF_WEEK_IN_MONTH_MASK  \u003d (1 \u003c\u003c DAY_OF_WEEK_IN_MONTH);\n    static final int AM_PM_MASK         \u003d (1 \u003c\u003c AM_PM);\n    static final int HOUR_MASK          \u003d (1 \u003c\u003c HOUR);\n    static final int HOUR_OF_DAY_MASK   \u003d (1 \u003c\u003c HOUR_OF_DAY);\n    static final int MINUTE_MASK        \u003d (1 \u003c\u003c MINUTE);\n    static final int SECOND_MASK        \u003d (1 \u003c\u003c SECOND);\n    static final int MILLISECOND_MASK   \u003d (1 \u003c\u003c MILLISECOND);\n    static final int ZONE_OFFSET_MASK   \u003d (1 \u003c\u003c ZONE_OFFSET);\n    static final int DST_OFFSET_MASK    \u003d (1 \u003c\u003c DST_OFFSET);\n\n    /**\n     * {@code Calendar.Builder} is used for creating a {@code Calendar} from\n     * various date-time parameters.\n     *\n     * \u003cp\u003eThere are two ways to set a {@code Calendar} to a date-time value. One\n     * is to set the instant parameter to a millisecond offset from the \u003ca\n     * href\u003d\"Calendar.html#Epoch\"\u003eEpoch\u003c/a\u003e. The other is to set individual\n     * field parameters, such as {@link Calendar#YEAR YEAR}, to their desired\n     * values. These two ways can\u0027t be mixed. Trying to set both the instant and\n     * individual fields will cause an {@link IllegalStateException} to be\n     * thrown. However, it is permitted to override previous values of the\n     * instant or field parameters.\n     *\n     * \u003cp\u003eIf no enough field parameters are given for determining date and/or\n     * time, calendar specific default values are used when building a\n     * {@code Calendar}. For example, if the {@link Calendar#YEAR YEAR} value\n     * isn\u0027t given for the Gregorian calendar, 1970 will be used. If there are\n     * any conflicts among field parameters, the \u003ca\n     * href\u003d\"Calendar.html#resolution\"\u003e resolution rules\u003c/a\u003e are applied.\n     * Therefore, the order of field setting matters.\n     *\n     * \u003cp\u003eIn addition to the date-time parameters,\n     * the {@linkplain #setLocale(Locale) locale},\n     * {@linkplain #setTimeZone(TimeZone) time zone},\n     * {@linkplain #setWeekDefinition(int, int) week definition}, and\n     * {@linkplain #setLenient(boolean) leniency mode} parameters can be set.\n     *\n     * \u003cp\u003e\u003cb\u003eExamples\u003c/b\u003e\n     * \u003cp\u003eThe following are sample usages. Sample code assumes that the\n     * {@code Calendar} constants are statically imported.\n     *\n     * \u003cp\u003eThe following code produces a {@code Calendar} with date 2012-12-31\n     * (Gregorian) because Monday is the first day of a week with the \u003ca\n     * href\u003d\"GregorianCalendar.html#iso8601_compatible_setting\"\u003e ISO 8601\n     * compatible week parameters\u003c/a\u003e.\n     * \u003cpre\u003e\n     *   Calendar cal \u003d new Calendar.Builder().setCalendarType(\"iso8601\")\n     *                        .setWeekDate(2013, 1, MONDAY).build();\u003c/pre\u003e\n     * \u003cp\u003eThe following code produces a Japanese {@code Calendar} with date\n     * 1989-01-08 (Gregorian), assuming that the default {@link Calendar#ERA ERA}\n     * is \u003cem\u003eHeisei\u003c/em\u003e that started on that day.\n     * \u003cpre\u003e\n     *   Calendar cal \u003d new Calendar.Builder().setCalendarType(\"japanese\")\n     *                        .setFields(YEAR, 1, DAY_OF_YEAR, 1).build();\u003c/pre\u003e\n     *\n     * @since 1.8\n     * @see Calendar#getInstance(TimeZone, Locale)\n     * @see Calendar#fields\n     */\n    public static class Builder {\n        private static final int NFIELDS \u003d FIELD_COUNT + 1; // +1 for WEEK_YEAR\n        private static final int WEEK_YEAR \u003d FIELD_COUNT;\n\n        private long instant;\n        // Calendar.stamp[] (lower half) and Calendar.fields[] (upper half) combined\n        private int[] fields;\n        // Pseudo timestamp starting from MINIMUM_USER_STAMP.\n        // (COMPUTED is used to indicate that the instant has been set.)\n        private int nextStamp;\n        // maxFieldIndex keeps the max index of fields which have been set.\n        // (WEEK_YEAR is never included.)\n        private int maxFieldIndex;\n        private String type;\n        private TimeZone zone;\n        private boolean lenient \u003d true;\n        private Locale locale;\n        private int firstDayOfWeek, minimalDaysInFirstWeek;\n\n        /**\n         * Constructs a {@code Calendar.Builder}.\n         */\n        public Builder() {\n        }\n\n        /**\n         * Sets the instant parameter to the given {@code instant} value that is\n         * a millisecond offset from \u003ca href\u003d\"Calendar.html#Epoch\"\u003ethe\n         * Epoch\u003c/a\u003e.\n         *\n         * @param instant a millisecond offset from the Epoch\n         * @return this {@code Calendar.Builder}\n         * @throws IllegalStateException if any of the field parameters have\n         *                               already been set\n         * @see Calendar#setTime(Date)\n         * @see Calendar#setTimeInMillis(long)\n         * @see Calendar#time\n         */\n        public Builder setInstant(long instant) {\n            if (fields !\u003d null) {\n                throw new IllegalStateException();\n            }\n            this.instant \u003d instant;\n            nextStamp \u003d COMPUTED;\n            return this;\n        }\n\n        /**\n         * Sets the instant parameter to the {@code instant} value given by a\n         * {@link Date}. This method is equivalent to a call to\n         * {@link #setInstant(long) setInstant(instant.getTime())}.\n         *\n         * @param instant a {@code Date} representing a millisecond offset from\n         *                the Epoch\n         * @return this {@code Calendar.Builder}\n         * @throws NullPointerException  if {@code instant} is {@code null}\n         * @throws IllegalStateException if any of the field parameters have\n         *                               already been set\n         * @see Calendar#setTime(Date)\n         * @see Calendar#setTimeInMillis(long)\n         * @see Calendar#time\n         */\n        public Builder setInstant(Date instant) {\n            return setInstant(instant.getTime()); // NPE if instant \u003d\u003d null\n        }\n\n        /**\n         * Sets the {@code field} parameter to the given {@code value}.\n         * {@code field} is an index to the {@link Calendar#fields}, such as\n         * {@link Calendar#DAY_OF_MONTH DAY_OF_MONTH}. Field value validation is\n         * not performed in this method. Any out of range values are either\n         * normalized in lenient mode or detected as an invalid value in\n         * non-lenient mode when building a {@code Calendar}.\n         *\n         * @param field an index to the {@code Calendar} fields\n         * @param value the field value\n         * @return this {@code Calendar.Builder}\n         * @throws IllegalArgumentException if {@code field} is invalid\n         * @throws IllegalStateException if the instant value has already been set,\n         *                      or if fields have been set too many\n         *                      (approximately {@link Integer#MAX_VALUE}) times.\n         * @see Calendar#set(int, int)\n         */\n        public Builder set(int field, int value) {\n            // Note: WEEK_YEAR can\u0027t be set with this method.\n            if (field \u003c 0 || field \u003e\u003d FIELD_COUNT) {\n                throw new IllegalArgumentException(\"field is invalid\");\n            }\n            if (isInstantSet()) {\n                throw new IllegalStateException(\"instant has been set\");\n            }\n            allocateFields();\n            internalSet(field, value);\n            return this;\n        }\n\n        /**\n         * Sets field parameters to their values given by\n         * {@code fieldValuePairs} that are pairs of a field and its value.\n         * For example,\n         * \u003cpre\u003e\n         *   setFields(Calendar.YEAR, 2013,\n         *             Calendar.MONTH, Calendar.DECEMBER,\n         *             Calendar.DAY_OF_MONTH, 23);\u003c/pre\u003e\n         * is equivalent to the sequence of the following\n         * {@link #set(int, int) set} calls:\n         * \u003cpre\u003e\n         *   set(Calendar.YEAR, 2013)\n         *   .set(Calendar.MONTH, Calendar.DECEMBER)\n         *   .set(Calendar.DAY_OF_MONTH, 23);\u003c/pre\u003e\n         *\n         * @param fieldValuePairs field-value pairs\n         * @return this {@code Calendar.Builder}\n         * @throws NullPointerException if {@code fieldValuePairs} is {@code null}\n         * @throws IllegalArgumentException if any of fields are invalid,\n         *             or if {@code fieldValuePairs.length} is an odd number.\n         * @throws IllegalStateException    if the instant value has been set,\n         *             or if fields have been set too many (approximately\n         *             {@link Integer#MAX_VALUE}) times.\n         */\n        public Builder setFields(int... fieldValuePairs) {\n            int len \u003d fieldValuePairs.length;\n            if ((len % 2) !\u003d 0) {\n                throw new IllegalArgumentException();\n            }\n            if (isInstantSet()) {\n                throw new IllegalStateException(\"instant has been set\");\n            }\n            if ((nextStamp + len / 2) \u003c 0) {\n                throw new IllegalStateException(\"stamp counter overflow\");\n            }\n            allocateFields();\n            for (int i \u003d 0; i \u003c len; ) {\n                int field \u003d fieldValuePairs[i++];\n                // Note: WEEK_YEAR can\u0027t be set with this method.\n                if (field \u003c 0 || field \u003e\u003d FIELD_COUNT) {\n                    throw new IllegalArgumentException(\"field is invalid\");\n                }\n                internalSet(field, fieldValuePairs[i++]);\n            }\n            return this;\n        }\n\n        /**\n         * Sets the date field parameters to the values given by {@code year},\n         * {@code month}, and {@code dayOfMonth}. This method is equivalent to\n         * a call to:\n         * \u003cpre\u003e\n         *   setFields(Calendar.YEAR, year,\n         *             Calendar.MONTH, month,\n         *             Calendar.DAY_OF_MONTH, dayOfMonth);\u003c/pre\u003e\n         *\n         * @param year       the {@link Calendar#YEAR YEAR} value\n         * @param month      the {@link Calendar#MONTH MONTH} value\n         *                   (the month numbering is \u003cem\u003e0-based\u003c/em\u003e).\n         * @param dayOfMonth the {@link Calendar#DAY_OF_MONTH DAY_OF_MONTH} value\n         * @return this {@code Calendar.Builder}\n         */\n        public Builder setDate(int year, int month, int dayOfMonth) {\n            return setFields(YEAR, year, MONTH, month, DAY_OF_MONTH, dayOfMonth);\n        }\n\n        /**\n         * Sets the time of day field parameters to the values given by\n         * {@code hourOfDay}, {@code minute}, and {@code second}. This method is\n         * equivalent to a call to:\n         * \u003cpre\u003e\n         *   setTimeOfDay(hourOfDay, minute, second, 0);\u003c/pre\u003e\n         *\n         * @param hourOfDay the {@link Calendar#HOUR_OF_DAY HOUR_OF_DAY} value\n         *                  (24-hour clock)\n         * @param minute    the {@link Calendar#MINUTE MINUTE} value\n         * @param second    the {@link Calendar#SECOND SECOND} value\n         * @return this {@code Calendar.Builder}\n         */\n        public Builder setTimeOfDay(int hourOfDay, int minute, int second) {\n            return setTimeOfDay(hourOfDay, minute, second, 0);\n        }\n\n        /**\n         * Sets the time of day field parameters to the values given by\n         * {@code hourOfDay}, {@code minute}, {@code second}, and\n         * {@code millis}. This method is equivalent to a call to:\n         * \u003cpre\u003e\n         *   setFields(Calendar.HOUR_OF_DAY, hourOfDay,\n         *             Calendar.MINUTE, minute,\n         *             Calendar.SECOND, second,\n         *             Calendar.MILLISECOND, millis);\u003c/pre\u003e\n         *\n         * @param hourOfDay the {@link Calendar#HOUR_OF_DAY HOUR_OF_DAY} value\n         *                  (24-hour clock)\n         * @param minute    the {@link Calendar#MINUTE MINUTE} value\n         * @param second    the {@link Calendar#SECOND SECOND} value\n         * @param millis    the {@link Calendar#MILLISECOND MILLISECOND} value\n         * @return this {@code Calendar.Builder}\n         */\n        public Builder setTimeOfDay(int hourOfDay, int minute, int second, int millis) {\n            return setFields(HOUR_OF_DAY, hourOfDay, MINUTE, minute,\n                             SECOND, second, MILLISECOND, millis);\n        }\n\n        /**\n         * Sets the week-based date parameters to the values with the given\n         * date specifiers - week year, week of year, and day of week.\n         *\n         * \u003cp\u003eIf the specified calendar doesn\u0027t support week dates, the\n         * {@link #build() build} method will throw an {@link IllegalArgumentException}.\n         *\n         * @param weekYear   the week year\n         * @param weekOfYear the week number based on {@code weekYear}\n         * @param dayOfWeek  the day of week value: one of the constants\n         *     for the {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} field:\n         *     {@link Calendar#SUNDAY SUNDAY}, ..., {@link Calendar#SATURDAY SATURDAY}.\n         * @return this {@code Calendar.Builder}\n         * @see Calendar#setWeekDate(int, int, int)\n         * @see Calendar#isWeekDateSupported()\n         */\n        public Builder setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {\n            allocateFields();\n            internalSet(WEEK_YEAR, weekYear);\n            internalSet(WEEK_OF_YEAR, weekOfYear);\n            internalSet(DAY_OF_WEEK, dayOfWeek);\n            return this;\n        }\n\n        /**\n         * Sets the time zone parameter to the given {@code zone}. If no time\n         * zone parameter is given to this {@code Calendar.Builder}, the\n         * {@linkplain TimeZone#getDefault() default\n         * \u003ccode\u003eTimeZone\u003c/code\u003e} will be used in the {@link #build() build}\n         * method.\n         *\n         * @param zone the {@link TimeZone}\n         * @return this {@code Calendar.Builder}\n         * @throws NullPointerException if {@code zone} is {@code null}\n         * @see Calendar#setTimeZone(TimeZone)\n         */\n        public Builder setTimeZone(TimeZone zone) {\n            if (zone \u003d\u003d null) {\n                throw new NullPointerException();\n            }\n            this.zone \u003d zone;\n            return this;\n        }\n\n        /**\n         * Sets the lenient mode parameter to the value given by {@code lenient}.\n         * If no lenient parameter is given to this {@code Calendar.Builder},\n         * lenient mode will be used in the {@link #build() build} method.\n         *\n         * @param lenient {@code true} for lenient mode;\n         *                {@code false} for non-lenient mode\n         * @return this {@code Calendar.Builder}\n         * @see Calendar#setLenient(boolean)\n         */\n        public Builder setLenient(boolean lenient) {\n            this.lenient \u003d lenient;\n            return this;\n        }\n\n        /**\n         * Sets the calendar type parameter to the given {@code type}. The\n         * calendar type given by this method has precedence over any explicit\n         * or implicit calendar type given by the\n         * {@linkplain #setLocale(Locale) locale}.\n         *\n         * \u003cp\u003eIn addition to the available calendar types returned by the\n         * {@link Calendar#getAvailableCalendarTypes() Calendar.getAvailableCalendarTypes}\n         * method, {@code \"gregorian\"} and {@code \"iso8601\"} as aliases of\n         * {@code \"gregory\"} can be used with this method.\n         *\n         * @param type the calendar type\n         * @return this {@code Calendar.Builder}\n         * @throws NullPointerException if {@code type} is {@code null}\n         * @throws IllegalArgumentException if {@code type} is unknown\n         * @throws IllegalStateException if another calendar type has already been set\n         * @see Calendar#getCalendarType()\n         * @see Calendar#getAvailableCalendarTypes()\n         */\n        public Builder setCalendarType(String type) {\n            if (type.equals(\"gregorian\")) { // NPE if type \u003d\u003d null\n                type \u003d \"gregory\";\n            }\n            if (!Calendar.getAvailableCalendarTypes().contains(type)\n                    \u0026\u0026 !type.equals(\"iso8601\")) {\n                throw new IllegalArgumentException(\"unknown calendar type: \" + type);\n            }\n            if (this.type \u003d\u003d null) {\n                this.type \u003d type;\n            } else {\n                if (!this.type.equals(type)) {\n                    throw new IllegalStateException(\"calendar type override\");\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Sets the locale parameter to the given {@code locale}. If no locale\n         * is given to this {@code Calendar.Builder}, the {@linkplain\n         * Locale#getDefault(Locale.Category) default \u003ccode\u003eLocale\u003c/code\u003e}\n         * for {@link Locale.Category#FORMAT} will be used.\n         *\n         * \u003cp\u003eIf no calendar type is explicitly given by a call to the\n         * {@link #setCalendarType(String) setCalendarType} method,\n         * the {@code Locale} value is used to determine what type of\n         * {@code Calendar} to be built.\n         *\n         * \u003cp\u003eIf no week definition parameters are explicitly given by a call to\n         * the {@link #setWeekDefinition(int,int) setWeekDefinition} method, the\n         * {@code Locale}\u0027s default values are used.\n         *\n         * @param locale the {@link Locale}\n         * @throws NullPointerException if {@code locale} is {@code null}\n         * @return this {@code Calendar.Builder}\n         * @see Calendar#getInstance(Locale)\n         */\n        public Builder setLocale(Locale locale) {\n            if (locale \u003d\u003d null) {\n                throw new NullPointerException();\n            }\n            this.locale \u003d locale;\n            return this;\n        }\n\n        /**\n         * Sets the week definition parameters to the values given by\n         * {@code firstDayOfWeek} and {@code minimalDaysInFirstWeek} that are\n         * used to determine the \u003ca href\u003d\"Calendar.html#first_week\"\u003efirst\n         * week\u003c/a\u003e of a year. The parameters given by this method have\n         * precedence over the default values given by the\n         * {@linkplain #setLocale(Locale) locale}.\n         *\n         * @param firstDayOfWeek the first day of a week; one of\n         *                       {@link Calendar#SUNDAY} to {@link Calendar#SATURDAY}\n         * @param minimalDaysInFirstWeek the minimal number of days in the first\n         *                               week (1..7)\n         * @return this {@code Calendar.Builder}\n         * @throws IllegalArgumentException if {@code firstDayOfWeek} or\n         *                                  {@code minimalDaysInFirstWeek} is invalid\n         * @see Calendar#getFirstDayOfWeek()\n         * @see Calendar#getMinimalDaysInFirstWeek()\n         */\n        public Builder setWeekDefinition(int firstDayOfWeek, int minimalDaysInFirstWeek) {\n            if (!isValidWeekParameter(firstDayOfWeek)\n                    || !isValidWeekParameter(minimalDaysInFirstWeek)) {\n                throw new IllegalArgumentException();\n            }\n            this.firstDayOfWeek \u003d firstDayOfWeek;\n            this.minimalDaysInFirstWeek \u003d minimalDaysInFirstWeek;\n            return this;\n        }\n\n        /**\n         * Returns a {@code Calendar} built from the parameters set by the\n         * setter methods. The calendar type given by the {@link #setCalendarType(String)\n         * setCalendarType} method or the {@linkplain #setLocale(Locale) locale} is\n         * used to determine what {@code Calendar} to be created. If no explicit\n         * calendar type is given, the locale\u0027s default calendar is created.\n         *\n         * \u003cp\u003eIf the calendar type is {@code \"iso8601\"}, the\n         * {@linkplain GregorianCalendar#setGregorianChange(Date) Gregorian change date}\n         * of a {@link GregorianCalendar} is set to {@code Date(Long.MIN_VALUE)}\n         * to be the \u003cem\u003eproleptic\u003c/em\u003e Gregorian calendar. Its week definition\n         * parameters are also set to be \u003ca\n         * href\u003d\"GregorianCalendar.html#iso8601_compatible_setting\"\u003ecompatible\n         * with the ISO 8601 standard\u003c/a\u003e. Note that the\n         * {@link GregorianCalendar#getCalendarType() getCalendarType} method of\n         * a {@code GregorianCalendar} created with {@code \"iso8601\"} returns\n         * {@code \"gregory\"}.\n         *\n         * \u003cp\u003eThe default values are used for locale and time zone if these\n         * parameters haven\u0027t been given explicitly.\n         * \u003cp\u003e\n         * If the locale contains the time zone with \"tz\"\n         * \u003ca href\u003d\"Locale.html#def_locale_extension\"\u003eUnicode extension\u003c/a\u003e,\n         * and time zone hasn\u0027t been given explicitly, time zone in the locale\n         * is used.\n         *\n         * \u003cp\u003eAny out of range field values are either normalized in lenient\n         * mode or detected as an invalid value in non-lenient mode.\n         *\n         * @return a {@code Calendar} built with parameters of this {@code\n         *         Calendar.Builder}\n         * @throws IllegalArgumentException if the calendar type is unknown, or\n         *             if any invalid field values are given in non-lenient mode, or\n         *             if a week date is given for the calendar type that doesn\u0027t\n         *             support week dates.\n         * @see Calendar#getInstance(TimeZone, Locale)\n         * @see Locale#getDefault(Locale.Category)\n         * @see TimeZone#getDefault()\n         */\n        public Calendar build() {\n            if (locale \u003d\u003d null) {\n                locale \u003d Locale.getDefault();\n            }\n            if (zone \u003d\u003d null) {\n                zone \u003d defaultTimeZone(locale);\n            }\n            Calendar cal;\n            if (type \u003d\u003d null) {\n                type \u003d locale.getUnicodeLocaleType(\"ca\");\n            }\n            if (type \u003d\u003d null) {\n                if (locale.getCountry() \u003d\u003d \"TH\"\n                    \u0026\u0026 locale.getLanguage() \u003d\u003d \"th\") {\n                    type \u003d \"buddhist\";\n                } else {\n                    type \u003d \"gregory\";\n                }\n            }\n            switch (type) {\n            case \"gregory\":\n                cal \u003d new GregorianCalendar(zone, locale, true);\n                break;\n            case \"iso8601\":\n                GregorianCalendar gcal \u003d new GregorianCalendar(zone, locale, true);\n                // make gcal a proleptic Gregorian\n                gcal.setGregorianChange(new Date(Long.MIN_VALUE));\n                // and week definition to be compatible with ISO 8601\n                setWeekDefinition(MONDAY, 4);\n                cal \u003d gcal;\n                break;\n            case \"buddhist\":\n                cal \u003d new BuddhistCalendar(zone, locale);\n                cal.clear();\n                break;\n            case \"japanese\":\n                cal \u003d new JapaneseImperialCalendar(zone, locale, true);\n                break;\n            default:\n                throw new IllegalArgumentException(\"unknown calendar type: \" + type);\n            }\n            cal.setLenient(lenient);\n            if (firstDayOfWeek !\u003d 0) {\n                cal.setFirstDayOfWeek(firstDayOfWeek);\n                cal.setMinimalDaysInFirstWeek(minimalDaysInFirstWeek);\n            }\n            if (isInstantSet()) {\n                cal.setTimeInMillis(instant);\n                cal.complete();\n                return cal;\n            }\n\n            if (fields !\u003d null) {\n                boolean weekDate \u003d isSet(WEEK_YEAR)\n                                       \u0026\u0026 fields[WEEK_YEAR] \u003e fields[YEAR];\n                if (weekDate \u0026\u0026 !cal.isWeekDateSupported()) {\n                    throw new IllegalArgumentException(\"week date is unsupported by \" + type);\n                }\n\n                // Set the fields from the min stamp to the max stamp so that\n                // the fields resolution works in the Calendar.\n                for (int stamp \u003d MINIMUM_USER_STAMP; stamp \u003c nextStamp; stamp++) {\n                    for (int index \u003d 0; index \u003c\u003d maxFieldIndex; index++) {\n                        if (fields[index] \u003d\u003d stamp) {\n                            cal.set(index, fields[NFIELDS + index]);\n                            break;\n                        }\n                    }\n                }\n\n                if (weekDate) {\n                    int weekOfYear \u003d isSet(WEEK_OF_YEAR) ? fields[NFIELDS + WEEK_OF_YEAR] : 1;\n                    int dayOfWeek \u003d isSet(DAY_OF_WEEK)\n                                    ? fields[NFIELDS + DAY_OF_WEEK] : cal.getFirstDayOfWeek();\n                    cal.setWeekDate(fields[NFIELDS + WEEK_YEAR], weekOfYear, dayOfWeek);\n                }\n                cal.complete();\n            }\n\n            return cal;\n        }\n\n        private void allocateFields() {\n            if (fields \u003d\u003d null) {\n                fields \u003d new int[NFIELDS * 2];\n                nextStamp \u003d MINIMUM_USER_STAMP;\n                maxFieldIndex \u003d -1;\n            }\n        }\n\n        private void internalSet(int field, int value) {\n            fields[field] \u003d nextStamp++;\n            if (nextStamp \u003c 0) {\n                throw new IllegalStateException(\"stamp counter overflow\");\n            }\n            fields[NFIELDS + field] \u003d value;\n            if (field \u003e maxFieldIndex \u0026\u0026 field \u003c WEEK_YEAR) {\n                maxFieldIndex \u003d field;\n            }\n        }\n\n        private boolean isInstantSet() {\n            return nextStamp \u003d\u003d COMPUTED;\n        }\n\n        private boolean isSet(int index) {\n            return fields !\u003d null \u0026\u0026 fields[index] \u003e UNSET;\n        }\n\n        private boolean isValidWeekParameter(int value) {\n            return value \u003e 0 \u0026\u0026 value \u003c\u003d 7;\n        }\n    }\n\n    /**\n     * Constructs a Calendar with the default time zone\n     * and the default {@link java.util.Locale.Category#FORMAT FORMAT}\n     * locale.\n     * @see     TimeZone#getDefault\n     */\n    protected Calendar()\n    {\n        this(TimeZone.getDefaultRef(), Locale.getDefault(Locale.Category.FORMAT));\n        sharedZone \u003d true;\n    }\n\n    /**\n     * Constructs a calendar with the specified time zone and locale.\n     *\n     * @param zone the time zone to use\n     * @param aLocale the locale for the week data\n     */\n    protected Calendar(TimeZone zone, Locale aLocale)\n    {\n        fields \u003d new int[FIELD_COUNT];\n        isSet \u003d new boolean[FIELD_COUNT];\n        stamp \u003d new int[FIELD_COUNT];\n\n        this.zone \u003d zone;\n        setWeekCountData(aLocale);\n    }\n\n    /**\n     * Gets a calendar using the default time zone and locale. The\n     * \u003ccode\u003eCalendar\u003c/code\u003e returned is based on the current time\n     * in the default time zone with the default\n     * {@link Locale.Category#FORMAT FORMAT} locale.\n     * \u003cp\u003e\n     * If the locale contains the time zone with \"tz\"\n     * \u003ca href\u003d\"Locale.html#def_locale_extension\"\u003eUnicode extension\u003c/a\u003e,\n     * that time zone is used instead.\n     *\n     * @return a Calendar.\n     */\n    public static Calendar getInstance()\n    {\n        Locale aLocale \u003d Locale.getDefault(Locale.Category.FORMAT);\n        return createCalendar(defaultTimeZone(aLocale), aLocale);\n    }\n\n    /**\n     * Gets a calendar using the specified time zone and default locale.\n     * The \u003ccode\u003eCalendar\u003c/code\u003e returned is based on the current time\n     * in the given time zone with the default\n     * {@link Locale.Category#FORMAT FORMAT} locale.\n     *\n     * @param zone the time zone to use\n     * @return a Calendar.\n     */\n    public static Calendar getInstance(TimeZone zone)\n    {\n        return createCalendar(zone, Locale.getDefault(Locale.Category.FORMAT));\n    }\n\n    /**\n     * Gets a calendar using the default time zone and specified locale.\n     * The \u003ccode\u003eCalendar\u003c/code\u003e returned is based on the current time\n     * in the default time zone with the given locale.\n     * \u003cp\u003e\n     * If the locale contains the time zone with \"tz\"\n     * \u003ca href\u003d\"Locale.html#def_locale_extension\"\u003eUnicode extension\u003c/a\u003e,\n     * that time zone is used instead.\n     *\n     * @param aLocale the locale for the week data\n     * @return a Calendar.\n     */\n    public static Calendar getInstance(Locale aLocale)\n    {\n        return createCalendar(defaultTimeZone(aLocale), aLocale);\n    }\n\n    /**\n     * Gets a calendar with the specified time zone and locale.\n     * The \u003ccode\u003eCalendar\u003c/code\u003e returned is based on the current time\n     * in the given time zone with the given locale.\n     *\n     * @param zone the time zone to use\n     * @param aLocale the locale for the week data\n     * @return a Calendar.\n     */\n    public static Calendar getInstance(TimeZone zone,\n                                       Locale aLocale)\n    {\n        return createCalendar(zone, aLocale);\n    }\n\n    private static TimeZone defaultTimeZone(Locale l) {\n        TimeZone defaultTZ \u003d TimeZone.getDefault();\n        String shortTZID \u003d l.getUnicodeLocaleType(\"tz\");\n        return shortTZID !\u003d null ?\n            TimeZoneNameUtility.convertLDMLShortID(shortTZID)\n                .map(TimeZone::getTimeZone)\n                .orElse(defaultTZ) :\n            defaultTZ;\n    }\n\n    private static Calendar createCalendar(TimeZone zone,\n                                           Locale aLocale)\n    {\n        CalendarProvider provider \u003d\n            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)\n                                 .getCalendarProvider();\n        if (provider !\u003d null) {\n            try {\n                return provider.getInstance(zone, aLocale);\n            } catch (IllegalArgumentException iae) {\n                // fall back to the default instantiation\n            }\n        }\n\n        Calendar cal \u003d null;\n\n        if (aLocale.hasExtensions()) {\n            String caltype \u003d aLocale.getUnicodeLocaleType(\"ca\");\n            if (caltype !\u003d null) {\n                switch (caltype) {\n                case \"buddhist\":\n                cal \u003d new BuddhistCalendar(zone, aLocale);\n                    break;\n                case \"japanese\":\n                    cal \u003d new JapaneseImperialCalendar(zone, aLocale);\n                    break;\n                case \"gregory\":\n                    cal \u003d new GregorianCalendar(zone, aLocale);\n                    break;\n                }\n            }\n        }\n        if (cal \u003d\u003d null) {\n            // If no known calendar type is explicitly specified,\n            // perform the traditional way to create a Calendar:\n            // create a BuddhistCalendar for th_TH locale,\n            // a JapaneseImperialCalendar for ja_JP_JP locale, or\n            // a GregorianCalendar for any other locales.\n            // NOTE: The language, country and variant strings are interned.\n            if (aLocale.getLanguage() \u003d\u003d \"th\" \u0026\u0026 aLocale.getCountry() \u003d\u003d \"TH\") {\n                cal \u003d new BuddhistCalendar(zone, aLocale);\n            } else if (aLocale.getVariant() \u003d\u003d \"JP\" \u0026\u0026 aLocale.getLanguage() \u003d\u003d \"ja\"\n                       \u0026\u0026 aLocale.getCountry() \u003d\u003d \"JP\") {\n                cal \u003d new JapaneseImperialCalendar(zone, aLocale);\n            } else {\n                cal \u003d new GregorianCalendar(zone, aLocale);\n            }\n        }\n        return cal;\n    }\n\n    /**\n     * Returns an array of all locales for which the \u003ccode\u003egetInstance\u003c/code\u003e\n     * methods of this class can return localized instances.\n     * The array returned must contain at least a \u003ccode\u003eLocale\u003c/code\u003e\n     * instance equal to {@link java.util.Locale#US Locale.US}.\n     *\n     * @return An array of locales for which localized\n     *         \u003ccode\u003eCalendar\u003c/code\u003e instances are available.\n     */\n    public static synchronized Locale[] getAvailableLocales()\n    {\n        return DateFormat.getAvailableLocales();\n    }\n\n    /**\n     * Converts the current calendar field values in {@link #fields fields[]}\n     * to the millisecond time value\n     * {@link #time}.\n     *\n     * @see #complete()\n     * @see #computeFields()\n     */\n    protected abstract void computeTime();\n\n    /**\n     * Converts the current millisecond time value {@link #time}\n     * to calendar field values in {@link #fields fields[]}.\n     * This allows you to sync up the calendar field values with\n     * a new time that is set for the calendar.  The time is \u003cem\u003enot\u003c/em\u003e\n     * recomputed first; to recompute the time, then the fields, call the\n     * {@link #complete()} method.\n     *\n     * @see #computeTime()\n     */\n    protected abstract void computeFields();\n\n    /**\n     * Returns a \u003ccode\u003eDate\u003c/code\u003e object representing this\n     * \u003ccode\u003eCalendar\u003c/code\u003e\u0027s time value (millisecond offset from the \u003ca\n     * href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e\").\n     *\n     * @return a \u003ccode\u003eDate\u003c/code\u003e representing the time value.\n     * @see #setTime(Date)\n     * @see #getTimeInMillis()\n     */\n    public final Date getTime() {\n        return new Date(getTimeInMillis());\n    }\n\n    /**\n     * Sets this Calendar\u0027s time with the given \u003ccode\u003eDate\u003c/code\u003e.\n     * \u003cp\u003e\n     * Note: Calling \u003ccode\u003esetTime()\u003c/code\u003e with\n     * \u003ccode\u003eDate(Long.MAX_VALUE)\u003c/code\u003e or \u003ccode\u003eDate(Long.MIN_VALUE)\u003c/code\u003e\n     * may yield incorrect field values from \u003ccode\u003eget()\u003c/code\u003e.\n     *\n     * @param date the given Date.\n     * @see #getTime()\n     * @see #setTimeInMillis(long)\n     */\n    public final void setTime(Date date) {\n        setTimeInMillis(date.getTime());\n    }\n\n    /**\n     * Returns this Calendar\u0027s time value in milliseconds.\n     *\n     * @return the current time as UTC milliseconds from the epoch.\n     * @see #getTime()\n     * @see #setTimeInMillis(long)\n     */\n    public long getTimeInMillis() {\n        if (!isTimeSet) {\n            updateTime();\n        }\n        return time;\n    }\n\n    /**\n     * Sets this Calendar\u0027s current time from the given long value.\n     *\n     * @param millis the new time in UTC milliseconds from the epoch.\n     * @see #setTime(Date)\n     * @see #getTimeInMillis()\n     */\n    public void setTimeInMillis(long millis) {\n        // If we don\u0027t need to recalculate the calendar field values,\n        // do nothing.\n        if (time \u003d\u003d millis \u0026\u0026 isTimeSet \u0026\u0026 areFieldsSet \u0026\u0026 areAllFieldsSet\n            \u0026\u0026 (zone instanceof ZoneInfo) \u0026\u0026 !((ZoneInfo)zone).isDirty()) {\n            return;\n        }\n        time \u003d millis;\n        isTimeSet \u003d true;\n        areFieldsSet \u003d false;\n        computeFields();\n        areAllFieldsSet \u003d areFieldsSet \u003d true;\n    }\n\n    /**\n     * Returns the value of the given calendar field. In lenient mode,\n     * all calendar fields are normalized. In non-lenient mode, all\n     * calendar fields are validated and this method throws an\n     * exception if any calendar fields have out-of-range values. The\n     * normalization and validation are handled by the\n     * {@link #complete()} method, which process is calendar\n     * system dependent.\n     *\n     * @param field the given calendar field.\n     * @return the value for the given calendar field.\n     * @throws ArrayIndexOutOfBoundsException if the specified field is out of range\n     *             (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * @see #set(int,int)\n     * @see #complete()\n     */\n    public int get(int field)\n    {\n        complete();\n        return internalGet(field);\n    }\n\n    /**\n     * Returns the value of the given calendar field. This method does\n     * not involve normalization or validation of the field value.\n     *\n     * @param field the given calendar field.\n     * @return the value for the given calendar field.\n     * @see #get(int)\n     */\n    protected final int internalGet(int field)\n    {\n        return fields[field];\n    }\n\n    /**\n     * Sets the value of the given calendar field. This method does\n     * not affect any setting state of the field in this\n     * \u003ccode\u003eCalendar\u003c/code\u003e instance.\n     *\n     * @throws IndexOutOfBoundsException if the specified field is out of range\n     *             (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * @see #areFieldsSet\n     * @see #isTimeSet\n     * @see #areAllFieldsSet\n     * @see #set(int,int)\n     */\n    final void internalSet(int field, int value)\n    {\n        fields[field] \u003d value;\n    }\n\n    /**\n     * Sets the given calendar field to the given value. The value is not\n     * interpreted by this method regardless of the leniency mode.\n     *\n     * @param field the given calendar field.\n     * @param value the value to be set for the given calendar field.\n     * @throws ArrayIndexOutOfBoundsException if the specified field is out of range\n     *             (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * in non-lenient mode.\n     * @see #set(int,int,int)\n     * @see #set(int,int,int,int,int)\n     * @see #set(int,int,int,int,int,int)\n     * @see #get(int)\n     */\n    public void set(int field, int value)\n    {\n        // If the fields are partially normalized, calculate all the\n        // fields before changing any fields.\n        if (areFieldsSet \u0026\u0026 !areAllFieldsSet) {\n            computeFields();\n        }\n        internalSet(field, value);\n        isTimeSet \u003d false;\n        areFieldsSet \u003d false;\n        isSet[field] \u003d true;\n        stamp[field] \u003d nextStamp++;\n        if (nextStamp \u003d\u003d Integer.MAX_VALUE) {\n            adjustStamp();\n        }\n    }\n\n    /**\n     * Sets the values for the calendar fields \u003ccode\u003eYEAR\u003c/code\u003e,\n     * \u003ccode\u003eMONTH\u003c/code\u003e, and \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e.\n     * Previous values of other calendar fields are retained.  If this is not desired,\n     * call {@link #clear()} first.\n     *\n     * @param year the value used to set the \u003ccode\u003eYEAR\u003c/code\u003e calendar field.\n     * @param month the value used to set the \u003ccode\u003eMONTH\u003c/code\u003e calendar field.\n     * Month value is 0-based. e.g., 0 for January.\n     * @param date the value used to set the \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e calendar field.\n     * @see #set(int,int)\n     * @see #set(int,int,int,int,int)\n     * @see #set(int,int,int,int,int,int)\n     */\n    public final void set(int year, int month, int date)\n    {\n        set(YEAR, year);\n        set(MONTH, month);\n        set(DATE, date);\n    }\n\n    /**\n     * Sets the values for the calendar fields \u003ccode\u003eYEAR\u003c/code\u003e,\n     * \u003ccode\u003eMONTH\u003c/code\u003e, \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e,\n     * \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e, and \u003ccode\u003eMINUTE\u003c/code\u003e.\n     * Previous values of other fields are retained.  If this is not desired,\n     * call {@link #clear()} first.\n     *\n     * @param year the value used to set the \u003ccode\u003eYEAR\u003c/code\u003e calendar field.\n     * @param month the value used to set the \u003ccode\u003eMONTH\u003c/code\u003e calendar field.\n     * Month value is 0-based. e.g., 0 for January.\n     * @param date the value used to set the \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e calendar field.\n     * @param hourOfDay the value used to set the \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e calendar field.\n     * @param minute the value used to set the \u003ccode\u003eMINUTE\u003c/code\u003e calendar field.\n     * @see #set(int,int)\n     * @see #set(int,int,int)\n     * @see #set(int,int,int,int,int,int)\n     */\n    public final void set(int year, int month, int date, int hourOfDay, int minute)\n    {\n        set(YEAR, year);\n        set(MONTH, month);\n        set(DATE, date);\n        set(HOUR_OF_DAY, hourOfDay);\n        set(MINUTE, minute);\n    }\n\n    /**\n     * Sets the values for the fields \u003ccode\u003eYEAR\u003c/code\u003e, \u003ccode\u003eMONTH\u003c/code\u003e,\n     * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e, \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e, \u003ccode\u003eMINUTE\u003c/code\u003e, and\n     * \u003ccode\u003eSECOND\u003c/code\u003e.\n     * Previous values of other fields are retained.  If this is not desired,\n     * call {@link #clear()} first.\n     *\n     * @param year the value used to set the \u003ccode\u003eYEAR\u003c/code\u003e calendar field.\n     * @param month the value used to set the \u003ccode\u003eMONTH\u003c/code\u003e calendar field.\n     * Month value is 0-based. e.g., 0 for January.\n     * @param date the value used to set the \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e calendar field.\n     * @param hourOfDay the value used to set the \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e calendar field.\n     * @param minute the value used to set the \u003ccode\u003eMINUTE\u003c/code\u003e calendar field.\n     * @param second the value used to set the \u003ccode\u003eSECOND\u003c/code\u003e calendar field.\n     * @see #set(int,int)\n     * @see #set(int,int,int)\n     * @see #set(int,int,int,int,int)\n     */\n    public final void set(int year, int month, int date, int hourOfDay, int minute,\n                          int second)\n    {\n        set(YEAR, year);\n        set(MONTH, month);\n        set(DATE, date);\n        set(HOUR_OF_DAY, hourOfDay);\n        set(MINUTE, minute);\n        set(SECOND, second);\n    }\n\n    /**\n     * Sets all the calendar field values and the time value\n     * (millisecond offset from the \u003ca href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e) of\n     * this \u003ccode\u003eCalendar\u003c/code\u003e undefined. This means that {@link\n     * #isSet(int) isSet()} will return \u003ccode\u003efalse\u003c/code\u003e for all the\n     * calendar fields, and the date and time calculations will treat\n     * the fields as if they had never been set. A\n     * \u003ccode\u003eCalendar\u003c/code\u003e implementation class may use its specific\n     * default field values for date/time calculations. For example,\n     * \u003ccode\u003eGregorianCalendar\u003c/code\u003e uses 1970 if the\n     * \u003ccode\u003eYEAR\u003c/code\u003e field value is undefined.\n     *\n     * @see #clear(int)\n     */\n    public final void clear()\n    {\n        for (int i \u003d 0; i \u003c fields.length; ) {\n            stamp[i] \u003d fields[i] \u003d 0; // UNSET \u003d\u003d 0\n            isSet[i++] \u003d false;\n        }\n        areAllFieldsSet \u003d areFieldsSet \u003d false;\n        isTimeSet \u003d false;\n    }\n\n    /**\n     * Sets the given calendar field value and the time value\n     * (millisecond offset from the \u003ca href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e) of\n     * this \u003ccode\u003eCalendar\u003c/code\u003e undefined. This means that {@link\n     * #isSet(int) isSet(field)} will return \u003ccode\u003efalse\u003c/code\u003e, and\n     * the date and time calculations will treat the field as if it\n     * had never been set. A \u003ccode\u003eCalendar\u003c/code\u003e implementation\n     * class may use the field\u0027s specific default value for date and\n     * time calculations.\n     *\n     * \u003cp\u003eThe {@link #HOUR_OF_DAY}, {@link #HOUR} and {@link #AM_PM}\n     * fields are handled independently and the \u003ca\n     * href\u003d\"#time_resolution\"\u003ethe resolution rule for the time of\n     * day\u003c/a\u003e is applied. Clearing one of the fields doesn\u0027t reset\n     * the hour of day value of this \u003ccode\u003eCalendar\u003c/code\u003e. Use {@link\n     * #set(int,int) set(Calendar.HOUR_OF_DAY, 0)} to reset the hour\n     * value.\n     *\n     * @param field the calendar field to be cleared.\n     * @see #clear()\n     */\n    public final void clear(int field)\n    {\n        fields[field] \u003d 0;\n        stamp[field] \u003d UNSET;\n        isSet[field] \u003d false;\n\n        areAllFieldsSet \u003d areFieldsSet \u003d false;\n        isTimeSet \u003d false;\n    }\n\n    /**\n     * Determines if the given calendar field has a value set,\n     * including cases that the value has been set by internal fields\n     * calculations triggered by a \u003ccode\u003eget\u003c/code\u003e method call.\n     *\n     * @param field the calendar field to test\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the given calendar field has a value set;\n     * \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     */\n    public final boolean isSet(int field)\n    {\n        return stamp[field] !\u003d UNSET;\n    }\n\n    /**\n     * Returns the string representation of the calendar\n     * \u003ccode\u003efield\u003c/code\u003e value in the given \u003ccode\u003estyle\u003c/code\u003e and\n     * \u003ccode\u003elocale\u003c/code\u003e.  If no string representation is\n     * applicable, \u003ccode\u003enull\u003c/code\u003e is returned. This method calls\n     * {@link Calendar#get(int) get(field)} to get the calendar\n     * \u003ccode\u003efield\u003c/code\u003e value if the string representation is\n     * applicable to the given calendar \u003ccode\u003efield\u003c/code\u003e.\n     *\n     * \u003cp\u003eFor example, if this \u003ccode\u003eCalendar\u003c/code\u003e is a\n     * \u003ccode\u003eGregorianCalendar\u003c/code\u003e and its date is 2005-01-01, then\n     * the string representation of the {@link #MONTH} field would be\n     * \"January\" in the long style in an English locale or \"Jan\" in\n     * the short style. However, no string representation would be\n     * available for the {@link #DAY_OF_MONTH} field, and this method\n     * would return \u003ccode\u003enull\u003c/code\u003e.\n     *\n     * \u003cp\u003eThe default implementation supports the calendar fields for\n     * which a {@link DateFormatSymbols} has names in the given\n     * \u003ccode\u003elocale\u003c/code\u003e.\n     *\n     * @param field\n     *        the calendar field for which the string representation\n     *        is returned\n     * @param style\n     *        the style applied to the string representation; one of {@link\n     *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},\n     *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},\n     *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}.\n     * @param locale\n     *        the locale for the string representation\n     *        (any calendar types specified by {@code locale} are ignored)\n     * @return the string representation of the given\n     *        {@code field} in the given {@code style}, or\n     *        {@code null} if no string representation is\n     *        applicable.\n     * @exception IllegalArgumentException\n     *        if {@code field} or {@code style} is invalid,\n     *        or if this {@code Calendar} is non-lenient and any\n     *        of the calendar fields have invalid values\n     * @exception NullPointerException\n     *        if {@code locale} is null\n     * @since 1.6\n     */\n    public String getDisplayName(int field, int style, Locale locale) {\n        if (!checkDisplayNameParams(field, style, SHORT, NARROW_FORMAT, locale,\n                            ERA_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {\n            return null;\n        }\n\n        String calendarType \u003d getCalendarType();\n        int fieldValue \u003d get(field);\n        // the standalone/narrow styles and short era are supported only through\n        // CalendarNameProviders.\n        if (isStandaloneStyle(style) || isNarrowFormatStyle(style) ||\n            field \u003d\u003d ERA \u0026\u0026 (style \u0026 SHORT) \u003d\u003d SHORT) {\n            String val \u003d CalendarDataUtility.retrieveFieldValueName(calendarType,\n                                                                    field, fieldValue,\n                                                                    style, locale);\n            // Perform fallback here to follow the CLDR rules\n            if (val \u003d\u003d null) {\n                if (isNarrowFormatStyle(style)) {\n                    val \u003d CalendarDataUtility.retrieveFieldValueName(calendarType,\n                                                                     field, fieldValue,\n                                                                     toStandaloneStyle(style),\n                                                                     locale);\n                } else if (isStandaloneStyle(style)) {\n                    val \u003d CalendarDataUtility.retrieveFieldValueName(calendarType,\n                                                                     field, fieldValue,\n                                                                     getBaseStyle(style),\n                                                                     locale);\n                }\n            }\n            return val;\n        }\n\n        DateFormatSymbols symbols \u003d DateFormatSymbols.getInstance(locale);\n        String[] strings \u003d getFieldStrings(field, style, symbols);\n        if (strings !\u003d null) {\n            if (fieldValue \u003c strings.length) {\n                return strings[fieldValue];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns a {@code Map} containing all names of the calendar\n     * {@code field} in the given {@code style} and\n     * {@code locale} and their corresponding field values. For\n     * example, if this {@code Calendar} is a {@link\n     * GregorianCalendar}, the returned map would contain \"Jan\" to\n     * {@link #JANUARY}, \"Feb\" to {@link #FEBRUARY}, and so on, in the\n     * {@linkplain #SHORT short} style in an English locale.\n     *\n     * \u003cp\u003eNarrow names may not be unique due to use of single characters,\n     * such as \"S\" for Sunday and Saturday. In that case narrow names are not\n     * included in the returned {@code Map}.\n     *\n     * \u003cp\u003eThe values of other calendar fields may be taken into\n     * account to determine a set of display names. For example, if\n     * this {@code Calendar} is a lunisolar calendar system and\n     * the year value given by the {@link #YEAR} field has a leap\n     * month, this method would return month names containing the leap\n     * month name, and month names are mapped to their values specific\n     * for the year.\n     *\n     * \u003cp\u003eThe default implementation supports display names contained in\n     * a {@link DateFormatSymbols}. For example, if {@code field}\n     * is {@link #MONTH} and {@code style} is {@link\n     * #ALL_STYLES}, this method returns a {@code Map} containing\n     * all strings returned by {@link DateFormatSymbols#getShortMonths()}\n     * and {@link DateFormatSymbols#getMonths()}.\n     *\n     * @param field\n     *        the calendar field for which the display names are returned\n     * @param style\n     *        the style applied to the string representation; one of {@link\n     *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},\n     *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},\n     *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}\n     * @param locale\n     *        the locale for the display names\n     * @return a {@code Map} containing all display names in\n     *        {@code style} and {@code locale} and their\n     *        field values, or {@code null} if no display names\n     *        are defined for {@code field}\n     * @exception IllegalArgumentException\n     *        if {@code field} or {@code style} is invalid,\n     *        or if this {@code Calendar} is non-lenient and any\n     *        of the calendar fields have invalid values\n     * @exception NullPointerException\n     *        if {@code locale} is null\n     * @since 1.6\n     */\n    public Map\u003cString, Integer\u003e getDisplayNames(int field, int style, Locale locale) {\n        if (!checkDisplayNameParams(field, style, ALL_STYLES, NARROW_FORMAT, locale,\n                                    ERA_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {\n            return null;\n        }\n\n        String calendarType \u003d getCalendarType();\n        if (style \u003d\u003d ALL_STYLES || isStandaloneStyle(style) || isNarrowFormatStyle(style) ||\n            field \u003d\u003d ERA \u0026\u0026 (style \u0026 SHORT) \u003d\u003d SHORT) {\n            Map\u003cString, Integer\u003e map;\n            map \u003d CalendarDataUtility.retrieveFieldValueNames(calendarType, field, style, locale);\n\n            // Perform fallback here to follow the CLDR rules\n            if (map \u003d\u003d null) {\n                if (isNarrowFormatStyle(style)) {\n                    map \u003d CalendarDataUtility.retrieveFieldValueNames(calendarType, field,\n                                                                      toStandaloneStyle(style), locale);\n                } else if (style !\u003d ALL_STYLES) {\n                    map \u003d CalendarDataUtility.retrieveFieldValueNames(calendarType, field,\n                                                                      getBaseStyle(style), locale);\n                }\n            }\n            return map;\n        }\n\n        // SHORT or LONG\n        return getDisplayNamesImpl(field, style, locale);\n    }\n\n    private Map\u003cString,Integer\u003e getDisplayNamesImpl(int field, int style, Locale locale) {\n        DateFormatSymbols symbols \u003d DateFormatSymbols.getInstance(locale);\n        String[] strings \u003d getFieldStrings(field, style, symbols);\n        if (strings !\u003d null) {\n            Map\u003cString,Integer\u003e names \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c strings.length; i++) {\n                if (strings[i].isEmpty()) {\n                    continue;\n                }\n                names.put(strings[i], i);\n            }\n            return names;\n        }\n        return null;\n    }\n\n    boolean checkDisplayNameParams(int field, int style, int minStyle, int maxStyle,\n                                   Locale locale, int fieldMask) {\n        int baseStyle \u003d getBaseStyle(style); // Ignore the standalone mask\n        if (field \u003c 0 || field \u003e\u003d fields.length ||\n            baseStyle \u003c minStyle || baseStyle \u003e maxStyle || baseStyle \u003d\u003d 3) {\n            throw new IllegalArgumentException();\n        }\n        if (locale \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        return isFieldSet(fieldMask, field);\n    }\n\n    private String[] getFieldStrings(int field, int style, DateFormatSymbols symbols) {\n        int baseStyle \u003d getBaseStyle(style); // ignore the standalone mask\n\n        // DateFormatSymbols doesn\u0027t support any narrow names.\n        if (baseStyle \u003d\u003d NARROW_FORMAT) {\n            return null;\n        }\n\n        String[] strings \u003d null;\n        switch (field) {\n        case ERA:\n            strings \u003d symbols.getEras();\n            break;\n\n        case MONTH:\n            strings \u003d (baseStyle \u003d\u003d LONG) ? symbols.getMonths() : symbols.getShortMonths();\n            break;\n\n        case DAY_OF_WEEK:\n            strings \u003d (baseStyle \u003d\u003d LONG) ? symbols.getWeekdays() : symbols.getShortWeekdays();\n            break;\n\n        case AM_PM:\n            strings \u003d symbols.getAmPmStrings();\n            break;\n        }\n        return strings;\n    }\n\n    /**\n     * Fills in any unset fields in the calendar fields. First, the {@link\n     * #computeTime()} method is called if the time value (millisecond offset\n     * from the \u003ca href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e) has not been calculated from\n     * calendar field values. Then, the {@link #computeFields()} method is\n     * called to calculate all calendar field values.\n     */\n    protected void complete()\n    {\n        if (!isTimeSet) {\n            updateTime();\n        }\n        if (!areFieldsSet || !areAllFieldsSet) {\n            computeFields(); // fills in unset fields\n            areAllFieldsSet \u003d areFieldsSet \u003d true;\n        }\n    }\n\n    /**\n     * Returns whether the value of the specified calendar field has been set\n     * externally by calling one of the setter methods rather than by the\n     * internal time calculation.\n     *\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the field has been set externally,\n     * \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @exception IndexOutOfBoundsException if the specified\n     *                \u003ccode\u003efield\u003c/code\u003e is out of range\n     *               (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * @see #selectFields()\n     * @see #setFieldsComputed(int)\n     */\n    final boolean isExternallySet(int field) {\n        return stamp[field] \u003e\u003d MINIMUM_USER_STAMP;\n    }\n\n    /**\n     * Returns a field mask (bit mask) indicating all calendar fields that\n     * have the state of externally or internally set.\n     *\n     * @return a bit mask indicating set state fields\n     */\n    final int getSetStateFields() {\n        int mask \u003d 0;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            if (stamp[i] !\u003d UNSET) {\n                mask |\u003d 1 \u003c\u003c i;\n            }\n        }\n        return mask;\n    }\n\n    /**\n     * Sets the state of the specified calendar fields to\n     * \u003cem\u003ecomputed\u003c/em\u003e. This state means that the specified calendar fields\n     * have valid values that have been set by internal time calculation\n     * rather than by calling one of the setter methods.\n     *\n     * @param fieldMask the field to be marked as computed.\n     * @exception IndexOutOfBoundsException if the specified\n     *                \u003ccode\u003efield\u003c/code\u003e is out of range\n     *               (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * @see #isExternallySet(int)\n     * @see #selectFields()\n     */\n    final void setFieldsComputed(int fieldMask) {\n        if (fieldMask \u003d\u003d ALL_FIELDS) {\n            for (int i \u003d 0; i \u003c fields.length; i++) {\n                stamp[i] \u003d COMPUTED;\n                isSet[i] \u003d true;\n            }\n            areFieldsSet \u003d areAllFieldsSet \u003d true;\n        } else {\n            for (int i \u003d 0; i \u003c fields.length; i++) {\n                if ((fieldMask \u0026 1) \u003d\u003d 1) {\n                    stamp[i] \u003d COMPUTED;\n                    isSet[i] \u003d true;\n                } else {\n                    if (areAllFieldsSet \u0026\u0026 !isSet[i]) {\n                        areAllFieldsSet \u003d false;\n                    }\n                }\n                fieldMask \u003e\u003e\u003e\u003d 1;\n            }\n        }\n    }\n\n    /**\n     * Sets the state of the calendar fields that are \u003cem\u003enot\u003c/em\u003e specified\n     * by \u003ccode\u003efieldMask\u003c/code\u003e to \u003cem\u003eunset\u003c/em\u003e. If \u003ccode\u003efieldMask\u003c/code\u003e\n     * specifies all the calendar fields, then the state of this\n     * \u003ccode\u003eCalendar\u003c/code\u003e becomes that all the calendar fields are in sync\n     * with the time value (millisecond offset from the Epoch).\n     *\n     * @param fieldMask the field mask indicating which calendar fields are in\n     * sync with the time value.\n     * @exception IndexOutOfBoundsException if the specified\n     *                \u003ccode\u003efield\u003c/code\u003e is out of range\n     *               (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * @see #isExternallySet(int)\n     * @see #selectFields()\n     */\n    final void setFieldsNormalized(int fieldMask) {\n        if (fieldMask !\u003d ALL_FIELDS) {\n            for (int i \u003d 0; i \u003c fields.length; i++) {\n                if ((fieldMask \u0026 1) \u003d\u003d 0) {\n                    stamp[i] \u003d fields[i] \u003d 0; // UNSET \u003d\u003d 0\n                    isSet[i] \u003d false;\n                }\n                fieldMask \u003e\u003e\u003d 1;\n            }\n        }\n\n        // Some or all of the fields are in sync with the\n        // milliseconds, but the stamp values are not normalized yet.\n        areFieldsSet \u003d true;\n        areAllFieldsSet \u003d false;\n    }\n\n    /**\n     * Returns whether the calendar fields are partially in sync with the time\n     * value or fully in sync but not stamp values are not normalized yet.\n     */\n    final boolean isPartiallyNormalized() {\n        return areFieldsSet \u0026\u0026 !areAllFieldsSet;\n    }\n\n    /**\n     * Returns whether the calendar fields are fully in sync with the time\n     * value.\n     */\n    final boolean isFullyNormalized() {\n        return areFieldsSet \u0026\u0026 areAllFieldsSet;\n    }\n\n    /**\n     * Marks this Calendar as not sync\u0027d.\n     */\n    final void setUnnormalized() {\n        areFieldsSet \u003d areAllFieldsSet \u003d false;\n    }\n\n    /**\n     * Returns whether the specified \u003ccode\u003efield\u003c/code\u003e is on in the\n     * \u003ccode\u003efieldMask\u003c/code\u003e.\n     */\n    static boolean isFieldSet(int fieldMask, int field) {\n        return (fieldMask \u0026 (1 \u003c\u003c field)) !\u003d 0;\n    }\n\n    /**\n     * Returns a field mask indicating which calendar field values\n     * to be used to calculate the time value. The calendar fields are\n     * returned as a bit mask, each bit of which corresponds to a field, i.e.,\n     * the mask value of \u003ccode\u003efield\u003c/code\u003e is \u003ccode\u003e(1 \u0026lt;\u0026lt;\n     * field)\u003c/code\u003e. For example, 0x26 represents the \u003ccode\u003eYEAR\u003c/code\u003e,\n     * \u003ccode\u003eMONTH\u003c/code\u003e, and \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e fields (i.e., 0x26 is\n     * equal to\n     * \u003ccode\u003e(1\u0026lt;\u0026lt;YEAR)|(1\u0026lt;\u0026lt;MONTH)|(1\u0026lt;\u0026lt;DAY_OF_MONTH))\u003c/code\u003e.\n     *\n     * \u003cp\u003eThis method supports the calendar fields resolution as described in\n     * the class description. If the bit mask for a given field is on and its\n     * field has not been set (i.e., \u003ccode\u003eisSet(field)\u003c/code\u003e is\n     * \u003ccode\u003efalse\u003c/code\u003e), then the default value of the field has to be\n     * used, which case means that the field has been selected because the\n     * selected combination involves the field.\n     *\n     * @return a bit mask of selected fields\n     * @see #isExternallySet(int)\n     */\n    final int selectFields() {\n        // This implementation has been taken from the GregorianCalendar class.\n\n        // The YEAR field must always be used regardless of its SET\n        // state because YEAR is a mandatory field to determine the date\n        // and the default value (EPOCH_YEAR) may change through the\n        // normalization process.\n        int fieldMask \u003d YEAR_MASK;\n\n        if (stamp[ERA] !\u003d UNSET) {\n            fieldMask |\u003d ERA_MASK;\n        }\n        // Find the most recent group of fields specifying the day within\n        // the year.  These may be any of the following combinations:\n        //   MONTH + DAY_OF_MONTH\n        //   MONTH + WEEK_OF_MONTH + DAY_OF_WEEK\n        //   MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK\n        //   DAY_OF_YEAR\n        //   WEEK_OF_YEAR + DAY_OF_WEEK\n        // We look for the most recent of the fields in each group to determine\n        // the age of the group.  For groups involving a week-related field such\n        // as WEEK_OF_MONTH, DAY_OF_WEEK_IN_MONTH, or WEEK_OF_YEAR, both the\n        // week-related field and the DAY_OF_WEEK must be set for the group as a\n        // whole to be considered.  (See bug 4153860 - liu 7/24/98.)\n        int dowStamp \u003d stamp[DAY_OF_WEEK];\n        int monthStamp \u003d stamp[MONTH];\n        int domStamp \u003d stamp[DAY_OF_MONTH];\n        int womStamp \u003d aggregateStamp(stamp[WEEK_OF_MONTH], dowStamp);\n        int dowimStamp \u003d aggregateStamp(stamp[DAY_OF_WEEK_IN_MONTH], dowStamp);\n        int doyStamp \u003d stamp[DAY_OF_YEAR];\n        int woyStamp \u003d aggregateStamp(stamp[WEEK_OF_YEAR], dowStamp);\n\n        int bestStamp \u003d domStamp;\n        if (womStamp \u003e bestStamp) {\n            bestStamp \u003d womStamp;\n        }\n        if (dowimStamp \u003e bestStamp) {\n            bestStamp \u003d dowimStamp;\n        }\n        if (doyStamp \u003e bestStamp) {\n            bestStamp \u003d doyStamp;\n        }\n        if (woyStamp \u003e bestStamp) {\n            bestStamp \u003d woyStamp;\n        }\n\n        /* No complete combination exists.  Look for WEEK_OF_MONTH,\n         * DAY_OF_WEEK_IN_MONTH, or WEEK_OF_YEAR alone.  Treat DAY_OF_WEEK alone\n         * as DAY_OF_WEEK_IN_MONTH.\n         */\n        if (bestStamp \u003d\u003d UNSET) {\n            womStamp \u003d stamp[WEEK_OF_MONTH];\n            dowimStamp \u003d Math.max(stamp[DAY_OF_WEEK_IN_MONTH], dowStamp);\n            woyStamp \u003d stamp[WEEK_OF_YEAR];\n            bestStamp \u003d Math.max(Math.max(womStamp, dowimStamp), woyStamp);\n\n            /* Treat MONTH alone or no fields at all as DAY_OF_MONTH.  This may\n             * result in bestStamp \u003d domStamp \u003d UNSET if no fields are set,\n             * which indicates DAY_OF_MONTH.\n             */\n            if (bestStamp \u003d\u003d UNSET) {\n                bestStamp \u003d domStamp \u003d monthStamp;\n            }\n        }\n\n        if (bestStamp \u003d\u003d domStamp ||\n           (bestStamp \u003d\u003d womStamp \u0026\u0026 stamp[WEEK_OF_MONTH] \u003e\u003d stamp[WEEK_OF_YEAR]) ||\n           (bestStamp \u003d\u003d dowimStamp \u0026\u0026 stamp[DAY_OF_WEEK_IN_MONTH] \u003e\u003d stamp[WEEK_OF_YEAR])) {\n            fieldMask |\u003d MONTH_MASK;\n            if (bestStamp \u003d\u003d domStamp) {\n                fieldMask |\u003d DAY_OF_MONTH_MASK;\n            } else {\n                assert (bestStamp \u003d\u003d womStamp || bestStamp \u003d\u003d dowimStamp);\n                if (dowStamp !\u003d UNSET) {\n                    fieldMask |\u003d DAY_OF_WEEK_MASK;\n                }\n                if (womStamp \u003d\u003d dowimStamp) {\n                    // When they are equal, give the priority to\n                    // WEEK_OF_MONTH for compatibility.\n                    if (stamp[WEEK_OF_MONTH] \u003e\u003d stamp[DAY_OF_WEEK_IN_MONTH]) {\n                        fieldMask |\u003d WEEK_OF_MONTH_MASK;\n                    } else {\n                        fieldMask |\u003d DAY_OF_WEEK_IN_MONTH_MASK;\n                    }\n                } else {\n                    if (bestStamp \u003d\u003d womStamp) {\n                        fieldMask |\u003d WEEK_OF_MONTH_MASK;\n                    } else {\n                        assert (bestStamp \u003d\u003d dowimStamp);\n                        if (stamp[DAY_OF_WEEK_IN_MONTH] !\u003d UNSET) {\n                            fieldMask |\u003d DAY_OF_WEEK_IN_MONTH_MASK;\n                        }\n                    }\n                }\n            }\n        } else {\n            assert (bestStamp \u003d\u003d doyStamp || bestStamp \u003d\u003d woyStamp ||\n                    bestStamp \u003d\u003d UNSET);\n            if (bestStamp \u003d\u003d doyStamp) {\n                fieldMask |\u003d DAY_OF_YEAR_MASK;\n            } else {\n                assert (bestStamp \u003d\u003d woyStamp);\n                if (dowStamp !\u003d UNSET) {\n                    fieldMask |\u003d DAY_OF_WEEK_MASK;\n                }\n                fieldMask |\u003d WEEK_OF_YEAR_MASK;\n            }\n        }\n\n        // Find the best set of fields specifying the time of day.  There\n        // are only two possibilities here; the HOUR_OF_DAY or the\n        // AM_PM and the HOUR.\n        int hourOfDayStamp \u003d stamp[HOUR_OF_DAY];\n        int hourStamp \u003d aggregateStamp(stamp[HOUR], stamp[AM_PM]);\n        bestStamp \u003d (hourStamp \u003e hourOfDayStamp) ? hourStamp : hourOfDayStamp;\n\n        // if bestStamp is still UNSET, then take HOUR or AM_PM. (See 4846659)\n        if (bestStamp \u003d\u003d UNSET) {\n            bestStamp \u003d Math.max(stamp[HOUR], stamp[AM_PM]);\n        }\n\n        // Hours\n        if (bestStamp !\u003d UNSET) {\n            if (bestStamp \u003d\u003d hourOfDayStamp) {\n                fieldMask |\u003d HOUR_OF_DAY_MASK;\n            } else {\n                fieldMask |\u003d HOUR_MASK;\n                if (stamp[AM_PM] !\u003d UNSET) {\n                    fieldMask |\u003d AM_PM_MASK;\n                }\n            }\n        }\n        if (stamp[MINUTE] !\u003d UNSET) {\n            fieldMask |\u003d MINUTE_MASK;\n        }\n        if (stamp[SECOND] !\u003d UNSET) {\n            fieldMask |\u003d SECOND_MASK;\n        }\n        if (stamp[MILLISECOND] !\u003d UNSET) {\n            fieldMask |\u003d MILLISECOND_MASK;\n        }\n        if (stamp[ZONE_OFFSET] \u003e\u003d MINIMUM_USER_STAMP) {\n                fieldMask |\u003d ZONE_OFFSET_MASK;\n        }\n        if (stamp[DST_OFFSET] \u003e\u003d MINIMUM_USER_STAMP) {\n            fieldMask |\u003d DST_OFFSET_MASK;\n        }\n\n        return fieldMask;\n    }\n\n    int getBaseStyle(int style) {\n        return style \u0026 ~STANDALONE_MASK;\n    }\n\n    private int toStandaloneStyle(int style) {\n        return style | STANDALONE_MASK;\n    }\n\n    private boolean isStandaloneStyle(int style) {\n        return (style \u0026 STANDALONE_MASK) !\u003d 0;\n    }\n\n    private boolean isNarrowStyle(int style) {\n        return style \u003d\u003d NARROW_FORMAT || style \u003d\u003d NARROW_STANDALONE;\n    }\n\n    private boolean isNarrowFormatStyle(int style) {\n        return style \u003d\u003d NARROW_FORMAT;\n    }\n\n    /**\n     * Returns the pseudo-time-stamp for two fields, given their\n     * individual pseudo-time-stamps.  If either of the fields\n     * is unset, then the aggregate is unset.  Otherwise, the\n     * aggregate is the later of the two stamps.\n     */\n    private static int aggregateStamp(int stamp_a, int stamp_b) {\n        if (stamp_a \u003d\u003d UNSET || stamp_b \u003d\u003d UNSET) {\n            return UNSET;\n        }\n        return (stamp_a \u003e stamp_b) ? stamp_a : stamp_b;\n    }\n\n    /**\n     * Returns an unmodifiable {@code Set} containing all calendar types\n     * supported by {@code Calendar} in the runtime environment. The available\n     * calendar types can be used for the \u003ca\n     * href\u003d\"Locale.html#def_locale_extension\"\u003eUnicode locale extensions\u003c/a\u003e.\n     * The {@code Set} returned contains at least {@code \"gregory\"}. The\n     * calendar types don\u0027t include aliases, such as {@code \"gregorian\"} for\n     * {@code \"gregory\"}.\n     *\n     * @return an unmodifiable {@code Set} containing all available calendar types\n     * @since 1.8\n     * @see #getCalendarType()\n     * @see Calendar.Builder#setCalendarType(String)\n     * @see Locale#getUnicodeLocaleType(String)\n     */\n    public static Set\u003cString\u003e getAvailableCalendarTypes() {\n        return AvailableCalendarTypes.SET;\n    }\n\n    private static class AvailableCalendarTypes {\n        private static final Set\u003cString\u003e SET;\n        static {\n            Set\u003cString\u003e set \u003d new HashSet\u003c\u003e(3);\n            set.add(\"gregory\");\n            set.add(\"buddhist\");\n            set.add(\"japanese\");\n            SET \u003d Collections.unmodifiableSet(set);\n        }\n        private AvailableCalendarTypes() {\n        }\n    }\n\n    /**\n     * Returns the calendar type of this {@code Calendar}. Calendar types are\n     * defined by the \u003cem\u003eUnicode Locale Data Markup Language (LDML)\u003c/em\u003e\n     * specification.\n     *\n     * \u003cp\u003eThe default implementation of this method returns the class name of\n     * this {@code Calendar} instance. Any subclasses that implement\n     * LDML-defined calendar systems should override this method to return\n     * appropriate calendar types.\n     *\n     * @return the LDML-defined calendar type or the class name of this\n     *         {@code Calendar} instance\n     * @since 1.8\n     * @see \u003ca href\u003d\"Locale.html#def_extensions\"\u003eLocale extensions\u003c/a\u003e\n     * @see Locale.Builder#setLocale(Locale)\n     * @see Locale.Builder#setUnicodeLocaleKeyword(String, String)\n     */\n    public String getCalendarType() {\n        return this.getClass().getName();\n    }\n\n    /**\n     * Compares this \u003ccode\u003eCalendar\u003c/code\u003e to the specified\n     * \u003ccode\u003eObject\u003c/code\u003e.  The result is \u003ccode\u003etrue\u003c/code\u003e if and only if\n     * the argument is a \u003ccode\u003eCalendar\u003c/code\u003e object of the same calendar\n     * system that represents the same time value (millisecond offset from the\n     * \u003ca href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e) under the same\n     * \u003ccode\u003eCalendar\u003c/code\u003e parameters as this object.\n     *\n     * \u003cp\u003eThe \u003ccode\u003eCalendar\u003c/code\u003e parameters are the values represented\n     * by the \u003ccode\u003eisLenient\u003c/code\u003e, \u003ccode\u003egetFirstDayOfWeek\u003c/code\u003e,\n     * \u003ccode\u003egetMinimalDaysInFirstWeek\u003c/code\u003e and \u003ccode\u003egetTimeZone\u003c/code\u003e\n     * methods. If there is any difference in those parameters\n     * between the two \u003ccode\u003eCalendar\u003c/code\u003es, this method returns\n     * \u003ccode\u003efalse\u003c/code\u003e.\n     *\n     * \u003cp\u003eUse the {@link #compareTo(Calendar) compareTo} method to\n     * compare only the time values.\n     *\n     * @param obj the object to compare with.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if this object is equal to \u003ccode\u003eobj\u003c/code\u003e;\n     * \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     */\n    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        try {\n            Calendar that \u003d (Calendar)obj;\n            return compareTo(getMillisOf(that)) \u003d\u003d 0 \u0026\u0026\n                lenient \u003d\u003d that.lenient \u0026\u0026\n                firstDayOfWeek \u003d\u003d that.firstDayOfWeek \u0026\u0026\n                minimalDaysInFirstWeek \u003d\u003d that.minimalDaysInFirstWeek \u0026\u0026\n                (zone instanceof ZoneInfo ?\n                    zone.equals(that.zone) :\n                    zone.equals(that.getTimeZone()));\n        } catch (Exception e) {\n            // Note: GregorianCalendar.computeTime throws\n            // IllegalArgumentException if the ERA value is invalid\n            // even it\u0027s in lenient mode.\n        }\n        return false;\n    }\n\n    /**\n     * Returns a hash code for this calendar.\n     *\n     * @return a hash code value for this object.\n     * @since 1.2\n     */\n    @Override\n    public int hashCode() {\n        // \u0027otheritems\u0027 represents the hash code for the previous versions.\n        int otheritems \u003d (lenient ? 1 : 0)\n            | (firstDayOfWeek \u003c\u003c 1)\n            | (minimalDaysInFirstWeek \u003c\u003c 4)\n            | (zone.hashCode() \u003c\u003c 7);\n        long t \u003d getMillisOf(this);\n        return (int) t ^ (int)(t \u003e\u003e 32) ^ otheritems;\n    }\n\n    /**\n     * Returns whether this \u003ccode\u003eCalendar\u003c/code\u003e represents a time\n     * before the time represented by the specified\n     * \u003ccode\u003eObject\u003c/code\u003e. This method is equivalent to:\n     * \u003cpre\u003e{@code\n     *         compareTo(when) \u003c 0\n     * }\u003c/pre\u003e\n     * if and only if \u003ccode\u003ewhen\u003c/code\u003e is a \u003ccode\u003eCalendar\u003c/code\u003e\n     * instance. Otherwise, the method returns \u003ccode\u003efalse\u003c/code\u003e.\n     *\n     * @param when the \u003ccode\u003eObject\u003c/code\u003e to be compared\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the time of this\n     * \u003ccode\u003eCalendar\u003c/code\u003e is before the time represented by\n     * \u003ccode\u003ewhen\u003c/code\u003e; \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @see     #compareTo(Calendar)\n     */\n    public boolean before(Object when) {\n        return when instanceof Calendar\n            \u0026\u0026 compareTo((Calendar)when) \u003c 0;\n    }\n\n    /**\n     * Returns whether this \u003ccode\u003eCalendar\u003c/code\u003e represents a time\n     * after the time represented by the specified\n     * \u003ccode\u003eObject\u003c/code\u003e. This method is equivalent to:\n     * \u003cpre\u003e{@code\n     *         compareTo(when) \u003e 0\n     * }\u003c/pre\u003e\n     * if and only if \u003ccode\u003ewhen\u003c/code\u003e is a \u003ccode\u003eCalendar\u003c/code\u003e\n     * instance. Otherwise, the method returns \u003ccode\u003efalse\u003c/code\u003e.\n     *\n     * @param when the \u003ccode\u003eObject\u003c/code\u003e to be compared\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the time of this \u003ccode\u003eCalendar\u003c/code\u003e is\n     * after the time represented by \u003ccode\u003ewhen\u003c/code\u003e; \u003ccode\u003efalse\u003c/code\u003e\n     * otherwise.\n     * @see     #compareTo(Calendar)\n     */\n    public boolean after(Object when) {\n        return when instanceof Calendar\n            \u0026\u0026 compareTo((Calendar)when) \u003e 0;\n    }\n\n    /**\n     * Compares the time values (millisecond offsets from the \u003ca\n     * href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e) represented by two\n     * \u003ccode\u003eCalendar\u003c/code\u003e objects.\n     *\n     * @param anotherCalendar the \u003ccode\u003eCalendar\u003c/code\u003e to be compared.\n     * @return the value \u003ccode\u003e0\u003c/code\u003e if the time represented by the argument\n     * is equal to the time represented by this \u003ccode\u003eCalendar\u003c/code\u003e; a value\n     * less than \u003ccode\u003e0\u003c/code\u003e if the time of this \u003ccode\u003eCalendar\u003c/code\u003e is\n     * before the time represented by the argument; and a value greater than\n     * \u003ccode\u003e0\u003c/code\u003e if the time of this \u003ccode\u003eCalendar\u003c/code\u003e is after the\n     * time represented by the argument.\n     * @exception NullPointerException if the specified \u003ccode\u003eCalendar\u003c/code\u003e is\n     *            \u003ccode\u003enull\u003c/code\u003e.\n     * @exception IllegalArgumentException if the time value of the\n     * specified \u003ccode\u003eCalendar\u003c/code\u003e object can\u0027t be obtained due to\n     * any invalid calendar values.\n     * @since   1.5\n     */\n    @Override\n    public int compareTo(Calendar anotherCalendar) {\n        return compareTo(getMillisOf(anotherCalendar));\n    }\n\n    /**\n     * Adds or subtracts the specified amount of time to the given calendar field,\n     * based on the calendar\u0027s rules. For example, to subtract 5 days from\n     * the current time of the calendar, you can achieve it by calling:\n     * \u003cp\u003e\u003ccode\u003eadd(Calendar.DAY_OF_MONTH, -5)\u003c/code\u003e.\n     *\n     * @param field the calendar field.\n     * @param amount the amount of date or time to be added to the field.\n     * @see #roll(int,int)\n     * @see #set(int,int)\n     */\n    public abstract void add(int field, int amount);\n\n    /**\n     * Adds or subtracts (up/down) a single unit of time on the given time\n     * field without changing larger fields. For example, to roll the current\n     * date up by one day, you can achieve it by calling:\n     * \u003cp\u003eroll(Calendar.DATE, true).\n     * When rolling on the year or Calendar.YEAR field, it will roll the year\n     * value in the range between 1 and the value returned by calling\n     * \u003ccode\u003egetMaximum(Calendar.YEAR)\u003c/code\u003e.\n     * When rolling on the month or Calendar.MONTH field, other fields like\n     * date might conflict and, need to be changed. For instance,\n     * rolling the month on the date 01/31/96 will result in 02/29/96.\n     * When rolling on the hour-in-day or Calendar.HOUR_OF_DAY field, it will\n     * roll the hour value in the range between 0 and 23, which is zero-based.\n     *\n     * @param field the time field.\n     * @param up indicates if the value of the specified time field is to be\n     * rolled up or rolled down. Use true if rolling up, false otherwise.\n     * @see Calendar#add(int,int)\n     * @see Calendar#set(int,int)\n     */\n    public abstract void roll(int field, boolean up);\n\n    /**\n     * Adds the specified (signed) amount to the specified calendar field\n     * without changing larger fields.  A negative amount means to roll\n     * down.\n     *\n     * \u003cp\u003eNOTE:  This default implementation on \u003ccode\u003eCalendar\u003c/code\u003e just repeatedly calls the\n     * version of {@link #roll(int,boolean) roll()} that rolls by one unit.  This may not\n     * always do the right thing.  For example, if the \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e field is 31,\n     * rolling through February will leave it set to 28.  The \u003ccode\u003eGregorianCalendar\u003c/code\u003e\n     * version of this function takes care of this problem.  Other subclasses\n     * should also provide overrides of this function that do the right thing.\n     *\n     * @param field the calendar field.\n     * @param amount the signed amount to add to the calendar \u003ccode\u003efield\u003c/code\u003e.\n     * @since 1.2\n     * @see #roll(int,boolean)\n     * @see #add(int,int)\n     * @see #set(int,int)\n     */\n    public void roll(int field, int amount)\n    {\n        while (amount \u003e 0) {\n            roll(field, true);\n            amount--;\n        }\n        while (amount \u003c 0) {\n            roll(field, false);\n            amount++;\n        }\n    }\n\n    /**\n     * Sets the time zone with the given time zone value.\n     *\n     * @param value the given time zone.\n     */\n    public void setTimeZone(TimeZone value)\n    {\n        zone \u003d value;\n        sharedZone \u003d false;\n        /* Recompute the fields from the time using the new zone.  This also\n         * works if isTimeSet is false (after a call to set()).  In that case\n         * the time will be computed from the fields using the new zone, then\n         * the fields will get recomputed from that.  Consider the sequence of\n         * calls: cal.setTimeZone(EST); cal.set(HOUR, 1); cal.setTimeZone(PST).\n         * Is cal set to 1 o\u0027clock EST or 1 o\u0027clock PST?  Answer: PST.  More\n         * generally, a call to setTimeZone() affects calls to set() BEFORE AND\n         * AFTER it up to the next call to complete().\n         */\n        areAllFieldsSet \u003d areFieldsSet \u003d false;\n    }\n\n    /**\n     * Gets the time zone.\n     *\n     * @return the time zone object associated with this calendar.\n     */\n    public TimeZone getTimeZone()\n    {\n        // If the TimeZone object is shared by other Calendar instances, then\n        // create a clone.\n        if (sharedZone) {\n            zone \u003d (TimeZone) zone.clone();\n            sharedZone \u003d false;\n        }\n        return zone;\n    }\n\n    /**\n     * Returns the time zone (without cloning).\n     */\n    TimeZone getZone() {\n        return zone;\n    }\n\n    /**\n     * Sets the sharedZone flag to \u003ccode\u003eshared\u003c/code\u003e.\n     */\n    void setZoneShared(boolean shared) {\n        sharedZone \u003d shared;\n    }\n\n    /**\n     * Specifies whether or not date/time interpretation is to be lenient.  With\n     * lenient interpretation, a date such as \"February 942, 1996\" will be\n     * treated as being equivalent to the 941st day after February 1, 1996.\n     * With strict (non-lenient) interpretation, such dates will cause an exception to be\n     * thrown. The default is lenient.\n     *\n     * @param lenient \u003ccode\u003etrue\u003c/code\u003e if the lenient mode is to be turned\n     * on; \u003ccode\u003efalse\u003c/code\u003e if it is to be turned off.\n     * @see #isLenient()\n     * @see java.text.DateFormat#setLenient\n     */\n    public void setLenient(boolean lenient)\n    {\n        this.lenient \u003d lenient;\n    }\n\n    /**\n     * Tells whether date/time interpretation is to be lenient.\n     *\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the interpretation mode of this calendar is lenient;\n     * \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @see #setLenient(boolean)\n     */\n    public boolean isLenient()\n    {\n        return lenient;\n    }\n\n    /**\n     * Sets what the first day of the week is; e.g., \u003ccode\u003eSUNDAY\u003c/code\u003e in the U.S.,\n     * \u003ccode\u003eMONDAY\u003c/code\u003e in France.\n     *\n     * @param value the given first day of the week.\n     * @see #getFirstDayOfWeek()\n     * @see #getMinimalDaysInFirstWeek()\n     */\n    public void setFirstDayOfWeek(int value)\n    {\n        if (firstDayOfWeek \u003d\u003d value) {\n            return;\n        }\n        firstDayOfWeek \u003d value;\n        invalidateWeekFields();\n    }\n\n    /**\n     * Gets what the first day of the week is; e.g., \u003ccode\u003eSUNDAY\u003c/code\u003e in the U.S.,\n     * \u003ccode\u003eMONDAY\u003c/code\u003e in France.\n     *\n     * @return the first day of the week.\n     * @see #setFirstDayOfWeek(int)\n     * @see #getMinimalDaysInFirstWeek()\n     */\n    public int getFirstDayOfWeek()\n    {\n        return firstDayOfWeek;\n    }\n\n    /**\n     * Sets what the minimal days required in the first week of the year are;\n     * For example, if the first week is defined as one that contains the first\n     * day of the first month of a year, call this method with value 1. If it\n     * must be a full week, use value 7.\n     *\n     * @param value the given minimal days required in the first week\n     * of the year.\n     * @see #getMinimalDaysInFirstWeek()\n     */\n    public void setMinimalDaysInFirstWeek(int value)\n    {\n        if (minimalDaysInFirstWeek \u003d\u003d value) {\n            return;\n        }\n        minimalDaysInFirstWeek \u003d value;\n        invalidateWeekFields();\n    }\n\n    /**\n     * Gets what the minimal days required in the first week of the year are;\n     * e.g., if the first week is defined as one that contains the first day\n     * of the first month of a year, this method returns 1. If\n     * the minimal days required must be a full week, this method\n     * returns 7.\n     *\n     * @return the minimal days required in the first week of the year.\n     * @see #setMinimalDaysInFirstWeek(int)\n     */\n    public int getMinimalDaysInFirstWeek()\n    {\n        return minimalDaysInFirstWeek;\n    }\n\n    /**\n     * Returns whether this {@code Calendar} supports week dates.\n     *\n     * \u003cp\u003eThe default implementation of this method returns {@code false}.\n     *\n     * @return {@code true} if this {@code Calendar} supports week dates;\n     *         {@code false} otherwise.\n     * @see #getWeekYear()\n     * @see #setWeekDate(int,int,int)\n     * @see #getWeeksInWeekYear()\n     * @since 1.7\n     */\n    public boolean isWeekDateSupported() {\n        return false;\n    }\n\n    /**\n     * Returns the week year represented by this {@code Calendar}. The\n     * week year is in sync with the week cycle. The {@linkplain\n     * #getFirstDayOfWeek() first day of the first week} is the first\n     * day of the week year.\n     *\n     * \u003cp\u003eThe default implementation of this method throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @return the week year of this {@code Calendar}\n     * @exception UnsupportedOperationException\n     *            if any week year numbering isn\u0027t supported\n     *            in this {@code Calendar}.\n     * @see #isWeekDateSupported()\n     * @see #getFirstDayOfWeek()\n     * @see #getMinimalDaysInFirstWeek()\n     * @since 1.7\n     */\n    public int getWeekYear() {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Sets the date of this {@code Calendar} with the given date\n     * specifiers - week year, week of year, and day of week.\n     *\n     * \u003cp\u003eUnlike the {@code set} method, all of the calendar fields\n     * and {@code time} values are calculated upon return.\n     *\n     * \u003cp\u003eIf {@code weekOfYear} is out of the valid week-of-year range\n     * in {@code weekYear}, the {@code weekYear} and {@code\n     * weekOfYear} values are adjusted in lenient mode, or an {@code\n     * IllegalArgumentException} is thrown in non-lenient mode.\n     *\n     * \u003cp\u003eThe default implementation of this method throws an\n     * {@code UnsupportedOperationException}.\n     *\n     * @param weekYear   the week year\n     * @param weekOfYear the week number based on {@code weekYear}\n     * @param dayOfWeek  the day of week value: one of the constants\n     *                   for the {@link #DAY_OF_WEEK} field: {@link\n     *                   #SUNDAY}, ..., {@link #SATURDAY}.\n     * @exception IllegalArgumentException\n     *            if any of the given date specifiers is invalid\n     *            or any of the calendar fields are inconsistent\n     *            with the given date specifiers in non-lenient mode\n     * @exception UnsupportedOperationException\n     *            if any week year numbering isn\u0027t supported in this\n     *            {@code Calendar}.\n     * @see #isWeekDateSupported()\n     * @see #getFirstDayOfWeek()\n     * @see #getMinimalDaysInFirstWeek()\n     * @since 1.7\n     */\n    public void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Returns the number of weeks in the week year represented by this\n     * {@code Calendar}.\n     *\n     * \u003cp\u003eThe default implementation of this method throws an\n     * {@code UnsupportedOperationException}.\n     *\n     * @return the number of weeks in the week year.\n     * @exception UnsupportedOperationException\n     *            if any week year numbering isn\u0027t supported in this\n     *            {@code Calendar}.\n     * @see #WEEK_OF_YEAR\n     * @see #isWeekDateSupported()\n     * @see #getWeekYear()\n     * @see #getActualMaximum(int)\n     * @since 1.7\n     */\n    public int getWeeksInWeekYear() {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Returns the minimum value for the given calendar field of this\n     * \u003ccode\u003eCalendar\u003c/code\u003e instance. The minimum value is defined as\n     * the smallest value returned by the {@link #get(int) get} method\n     * for any possible time value.  The minimum value depends on\n     * calendar system specific parameters of the instance.\n     *\n     * @param field the calendar field.\n     * @return the minimum value for the given calendar field.\n     * @see #getMaximum(int)\n     * @see #getGreatestMinimum(int)\n     * @see #getLeastMaximum(int)\n     * @see #getActualMinimum(int)\n     * @see #getActualMaximum(int)\n     */\n    public abstract int getMinimum(int field);\n\n    /**\n     * Returns the maximum value for the given calendar field of this\n     * \u003ccode\u003eCalendar\u003c/code\u003e instance. The maximum value is defined as\n     * the largest value returned by the {@link #get(int) get} method\n     * for any possible time value. The maximum value depends on\n     * calendar system specific parameters of the instance.\n     *\n     * @param field the calendar field.\n     * @return the maximum value for the given calendar field.\n     * @see #getMinimum(int)\n     * @see #getGreatestMinimum(int)\n     * @see #getLeastMaximum(int)\n     * @see #getActualMinimum(int)\n     * @see #getActualMaximum(int)\n     */\n    public abstract int getMaximum(int field);\n\n    /**\n     * Returns the highest minimum value for the given calendar field\n     * of this \u003ccode\u003eCalendar\u003c/code\u003e instance. The highest minimum\n     * value is defined as the largest value returned by {@link\n     * #getActualMinimum(int)} for any possible time value. The\n     * greatest minimum value depends on calendar system specific\n     * parameters of the instance.\n     *\n     * @param field the calendar field.\n     * @return the highest minimum value for the given calendar field.\n     * @see #getMinimum(int)\n     * @see #getMaximum(int)\n     * @see #getLeastMaximum(int)\n     * @see #getActualMinimum(int)\n     * @see #getActualMaximum(int)\n     */\n    public abstract int getGreatestMinimum(int field);\n\n    /**\n     * Returns the lowest maximum value for the given calendar field\n     * of this \u003ccode\u003eCalendar\u003c/code\u003e instance. The lowest maximum\n     * value is defined as the smallest value returned by {@link\n     * #getActualMaximum(int)} for any possible time value. The least\n     * maximum value depends on calendar system specific parameters of\n     * the instance. For example, a \u003ccode\u003eCalendar\u003c/code\u003e for the\n     * Gregorian calendar system returns 28 for the\n     * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e field, because the 28th is the last\n     * day of the shortest month of this calendar, February in a\n     * common year.\n     *\n     * @param field the calendar field.\n     * @return the lowest maximum value for the given calendar field.\n     * @see #getMinimum(int)\n     * @see #getMaximum(int)\n     * @see #getGreatestMinimum(int)\n     * @see #getActualMinimum(int)\n     * @see #getActualMaximum(int)\n     */\n    public abstract int getLeastMaximum(int field);\n\n    /**\n     * Returns the minimum value that the specified calendar field\n     * could have, given the time value of this \u003ccode\u003eCalendar\u003c/code\u003e.\n     *\n     * \u003cp\u003eThe default implementation of this method uses an iterative\n     * algorithm to determine the actual minimum value for the\n     * calendar field. Subclasses should, if possible, override this\n     * with a more efficient implementation - in many cases, they can\n     * simply return \u003ccode\u003egetMinimum()\u003c/code\u003e.\n     *\n     * @param field the calendar field\n     * @return the minimum of the given calendar field for the time\n     * value of this \u003ccode\u003eCalendar\u003c/code\u003e\n     * @see #getMinimum(int)\n     * @see #getMaximum(int)\n     * @see #getGreatestMinimum(int)\n     * @see #getLeastMaximum(int)\n     * @see #getActualMaximum(int)\n     * @since 1.2\n     */\n    public int getActualMinimum(int field) {\n        int fieldValue \u003d getGreatestMinimum(field);\n        int endValue \u003d getMinimum(field);\n\n        // if we know that the minimum value is always the same, just return it\n        if (fieldValue \u003d\u003d endValue) {\n            return fieldValue;\n        }\n\n        // clone the calendar so we don\u0027t mess with the real one, and set it to\n        // accept anything for the field values\n        Calendar work \u003d (Calendar)this.clone();\n        work.setLenient(true);\n\n        // now try each value from getLeastMaximum() to getMaximum() one by one until\n        // we get a value that normalizes to another value.  The last value that\n        // normalizes to itself is the actual minimum for the current date\n        int result \u003d fieldValue;\n\n        do {\n            work.set(field, fieldValue);\n            if (work.get(field) !\u003d fieldValue) {\n                break;\n            } else {\n                result \u003d fieldValue;\n                fieldValue--;\n            }\n        } while (fieldValue \u003e\u003d endValue);\n\n        return result;\n    }\n\n    /**\n     * Returns the maximum value that the specified calendar field\n     * could have, given the time value of this\n     * \u003ccode\u003eCalendar\u003c/code\u003e. For example, the actual maximum value of\n     * the \u003ccode\u003eMONTH\u003c/code\u003e field is 12 in some years, and 13 in\n     * other years in the Hebrew calendar system.\n     *\n     * \u003cp\u003eThe default implementation of this method uses an iterative\n     * algorithm to determine the actual maximum value for the\n     * calendar field. Subclasses should, if possible, override this\n     * with a more efficient implementation.\n     *\n     * @param field the calendar field\n     * @return the maximum of the given calendar field for the time\n     * value of this \u003ccode\u003eCalendar\u003c/code\u003e\n     * @see #getMinimum(int)\n     * @see #getMaximum(int)\n     * @see #getGreatestMinimum(int)\n     * @see #getLeastMaximum(int)\n     * @see #getActualMinimum(int)\n     * @since 1.2\n     */\n    public int getActualMaximum(int field) {\n        int fieldValue \u003d getLeastMaximum(field);\n        int endValue \u003d getMaximum(field);\n\n        // if we know that the maximum value is always the same, just return it.\n        if (fieldValue \u003d\u003d endValue) {\n            return fieldValue;\n        }\n\n        // clone the calendar so we don\u0027t mess with the real one, and set it to\n        // accept anything for the field values.\n        Calendar work \u003d (Calendar)this.clone();\n        work.setLenient(true);\n\n        // if we\u0027re counting weeks, set the day of the week to Sunday.  We know the\n        // last week of a month or year will contain the first day of the week.\n        if (field \u003d\u003d WEEK_OF_YEAR || field \u003d\u003d WEEK_OF_MONTH) {\n            work.set(DAY_OF_WEEK, firstDayOfWeek);\n        }\n\n        // now try each value from getLeastMaximum() to getMaximum() one by one until\n        // we get a value that normalizes to another value.  The last value that\n        // normalizes to itself is the actual maximum for the current date\n        int result \u003d fieldValue;\n\n        do {\n            work.set(field, fieldValue);\n            if (work.get(field) !\u003d fieldValue) {\n                break;\n            } else {\n                result \u003d fieldValue;\n                fieldValue++;\n            }\n        } while (fieldValue \u003c\u003d endValue);\n\n        return result;\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     *\n     * @return a copy of this object.\n     */\n    @Override\n    public Object clone()\n    {\n        try {\n            Calendar other \u003d (Calendar) super.clone();\n\n            other.fields \u003d new int[FIELD_COUNT];\n            other.isSet \u003d new boolean[FIELD_COUNT];\n            other.stamp \u003d new int[FIELD_COUNT];\n            for (int i \u003d 0; i \u003c FIELD_COUNT; i++) {\n                other.fields[i] \u003d fields[i];\n                other.stamp[i] \u003d stamp[i];\n                other.isSet[i] \u003d isSet[i];\n            }\n            other.zone \u003d (TimeZone) zone.clone();\n            return other;\n        }\n        catch (CloneNotSupportedException e) {\n            // this shouldn\u0027t happen, since we are Cloneable\n            throw new InternalError(e);\n        }\n    }\n\n    private static final String[] FIELD_NAME \u003d {\n        \"ERA\", \"YEAR\", \"MONTH\", \"WEEK_OF_YEAR\", \"WEEK_OF_MONTH\", \"DAY_OF_MONTH\",\n        \"DAY_OF_YEAR\", \"DAY_OF_WEEK\", \"DAY_OF_WEEK_IN_MONTH\", \"AM_PM\", \"HOUR\",\n        \"HOUR_OF_DAY\", \"MINUTE\", \"SECOND\", \"MILLISECOND\", \"ZONE_OFFSET\",\n        \"DST_OFFSET\"\n    };\n\n    /**\n     * Returns the name of the specified calendar field.\n     *\n     * @param field the calendar field\n     * @return the calendar field name\n     * @exception IndexOutOfBoundsException if \u003ccode\u003efield\u003c/code\u003e is negative,\n     * equal to or greater than {@code FIELD_COUNT}.\n     */\n    static String getFieldName(int field) {\n        return FIELD_NAME[field];\n    }\n\n    /**\n     * Return a string representation of this calendar. This method\n     * is intended to be used only for debugging purposes, and the\n     * format of the returned string may vary between implementations.\n     * The returned string may be empty but may not be \u003ccode\u003enull\u003c/code\u003e.\n     *\n     * @return  a string representation of this calendar.\n     */\n    @Override\n    public String toString() {\n        // NOTE: BuddhistCalendar.toString() interprets the string\n        // produced by this method so that the Gregorian year number\n        // is substituted by its B.E. year value. It relies on\n        // \"...,YEAR\u003d\u003cyear\u003e,...\" or \"...,YEAR\u003d?,...\".\n        StringBuilder buffer \u003d new StringBuilder(800);\n        buffer.append(getClass().getName()).append(\u0027[\u0027);\n        appendValue(buffer, \"time\", isTimeSet, time);\n        buffer.append(\",areFieldsSet\u003d\").append(areFieldsSet);\n        buffer.append(\",areAllFieldsSet\u003d\").append(areAllFieldsSet);\n        buffer.append(\",lenient\u003d\").append(lenient);\n        buffer.append(\",zone\u003d\").append(zone);\n        appendValue(buffer, \",firstDayOfWeek\", true, (long) firstDayOfWeek);\n        appendValue(buffer, \",minimalDaysInFirstWeek\", true, (long) minimalDaysInFirstWeek);\n        for (int i \u003d 0; i \u003c FIELD_COUNT; ++i) {\n            buffer.append(\u0027,\u0027);\n            appendValue(buffer, FIELD_NAME[i], isSet(i), (long) fields[i]);\n        }\n        buffer.append(\u0027]\u0027);\n        return buffer.toString();\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003dprivates\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n    private static void appendValue(StringBuilder sb, String item, boolean valid, long value) {\n        sb.append(item).append(\u0027\u003d\u0027);\n        if (valid) {\n            sb.append(value);\n        } else {\n            sb.append(\u0027?\u0027);\n        }\n    }\n\n    /**\n     * Both firstDayOfWeek and minimalDaysInFirstWeek are locale-dependent.\n     * They are used to figure out the week count for a specific date for\n     * a given locale. These must be set when a Calendar is constructed.\n     * @param desiredLocale the given locale.\n     */\n    private void setWeekCountData(Locale desiredLocale)\n    {\n        /* try to get the Locale data from the cache */\n        int[] data \u003d cachedLocaleData.get(desiredLocale);\n        if (data \u003d\u003d null) {  /* cache miss */\n            data \u003d new int[2];\n            data[0] \u003d CalendarDataUtility.retrieveFirstDayOfWeek(desiredLocale);\n            data[1] \u003d CalendarDataUtility.retrieveMinimalDaysInFirstWeek(desiredLocale);\n            cachedLocaleData.putIfAbsent(desiredLocale, data);\n        }\n        firstDayOfWeek \u003d data[0];\n        minimalDaysInFirstWeek \u003d data[1];\n    }\n\n    /**\n     * Recomputes the time and updates the status fields isTimeSet\n     * and areFieldsSet.  Callers should check isTimeSet and only\n     * call this method if isTimeSet is false.\n     */\n    private void updateTime() {\n        computeTime();\n        // The areFieldsSet and areAllFieldsSet values are no longer\n        // controlled here (as of 1.5).\n        isTimeSet \u003d true;\n    }\n\n    private int compareTo(long t) {\n        long thisTime \u003d getMillisOf(this);\n        return (thisTime \u003e t) ? 1 : (thisTime \u003d\u003d t) ? 0 : -1;\n    }\n\n    private static long getMillisOf(Calendar calendar) {\n        if (calendar.isTimeSet) {\n            return calendar.time;\n        }\n        Calendar cal \u003d (Calendar) calendar.clone();\n        cal.setLenient(true);\n        return cal.getTimeInMillis();\n    }\n\n    /**\n     * Adjusts the stamp[] values before nextStamp overflow. nextStamp\n     * is set to the next stamp value upon the return.\n     */\n    private void adjustStamp() {\n        int max \u003d MINIMUM_USER_STAMP;\n        int newStamp \u003d MINIMUM_USER_STAMP;\n\n        for (;;) {\n            int min \u003d Integer.MAX_VALUE;\n            for (int v : stamp) {\n                if (v \u003e\u003d newStamp \u0026\u0026 min \u003e v) {\n                    min \u003d v;\n                }\n                if (max \u003c v) {\n                    max \u003d v;\n                }\n            }\n            if (max !\u003d min \u0026\u0026 min \u003d\u003d Integer.MAX_VALUE) {\n                break;\n            }\n            for (int i \u003d 0; i \u003c stamp.length; i++) {\n                if (stamp[i] \u003d\u003d min) {\n                    stamp[i] \u003d newStamp;\n                }\n            }\n            newStamp++;\n            if (min \u003d\u003d max) {\n                break;\n            }\n        }\n        nextStamp \u003d newStamp;\n    }\n\n    /**\n     * Sets the WEEK_OF_MONTH and WEEK_OF_YEAR fields to new values with the\n     * new parameter value if they have been calculated internally.\n     */\n    private void invalidateWeekFields()\n    {\n        if (stamp[WEEK_OF_MONTH] !\u003d COMPUTED \u0026\u0026\n            stamp[WEEK_OF_YEAR] !\u003d COMPUTED) {\n            return;\n        }\n\n        // We have to check the new values of these fields after changing\n        // firstDayOfWeek and/or minimalDaysInFirstWeek. If the field values\n        // have been changed, then set the new values. (4822110)\n        Calendar cal \u003d (Calendar) clone();\n        cal.setLenient(true);\n        cal.clear(WEEK_OF_MONTH);\n        cal.clear(WEEK_OF_YEAR);\n\n        if (stamp[WEEK_OF_MONTH] \u003d\u003d COMPUTED) {\n            int weekOfMonth \u003d cal.get(WEEK_OF_MONTH);\n            if (fields[WEEK_OF_MONTH] !\u003d weekOfMonth) {\n                fields[WEEK_OF_MONTH] \u003d weekOfMonth;\n            }\n        }\n\n        if (stamp[WEEK_OF_YEAR] \u003d\u003d COMPUTED) {\n            int weekOfYear \u003d cal.get(WEEK_OF_YEAR);\n            if (fields[WEEK_OF_YEAR] !\u003d weekOfYear) {\n                fields[WEEK_OF_YEAR] \u003d weekOfYear;\n            }\n        }\n    }\n\n    /**\n     * Save the state of this object to a stream (i.e., serialize it).\n     *\n     * Ideally, \u003ccode\u003eCalendar\u003c/code\u003e would only write out its state data and\n     * the current time, and not write any field data out, such as\n     * \u003ccode\u003efields[]\u003c/code\u003e, \u003ccode\u003eisTimeSet\u003c/code\u003e, \u003ccode\u003eareFieldsSet\u003c/code\u003e,\n     * and \u003ccode\u003eisSet[]\u003c/code\u003e.  \u003ccode\u003enextStamp\u003c/code\u003e also should not be part\n     * of the persistent state. Unfortunately, this didn\u0027t happen before JDK 1.1\n     * shipped. To be compatible with JDK 1.1, we will always have to write out\n     * the field values and state flags.  However, \u003ccode\u003enextStamp\u003c/code\u003e can be\n     * removed from the serialization stream; this will probably happen in the\n     * near future.\n     */\n    private synchronized void writeObject(ObjectOutputStream stream)\n         throws IOException\n    {\n        // Try to compute the time correctly, for the future (stream\n        // version 2) in which we don\u0027t write out fields[] or isSet[].\n        if (!isTimeSet) {\n            try {\n                updateTime();\n            }\n            catch (IllegalArgumentException e) {}\n        }\n\n        // If this Calendar has a ZoneInfo, save it and set a\n        // SimpleTimeZone equivalent (as a single DST schedule) for\n        // backward compatibility.\n        TimeZone savedZone \u003d null;\n        if (zone instanceof ZoneInfo) {\n            SimpleTimeZone stz \u003d ((ZoneInfo)zone).getLastRuleInstance();\n            if (stz \u003d\u003d null) {\n                stz \u003d new SimpleTimeZone(zone.getRawOffset(), zone.getID());\n            }\n            savedZone \u003d zone;\n            zone \u003d stz;\n        }\n\n        // Write out the 1.1 FCS object.\n        stream.defaultWriteObject();\n\n        // Write out the ZoneInfo object\n        // 4802409: we write out even if it is null, a temporary workaround\n        // the real fix for bug 4844924 in corba-iiop\n        stream.writeObject(savedZone);\n        if (savedZone !\u003d null) {\n            zone \u003d savedZone;\n        }\n    }\n\n    private static class CalendarAccessControlContext {\n        private static final AccessControlContext INSTANCE;\n        static {\n            RuntimePermission perm \u003d new RuntimePermission(\"accessClassInPackage.sun.util.calendar\");\n            PermissionCollection perms \u003d perm.newPermissionCollection();\n            perms.add(perm);\n            INSTANCE \u003d new AccessControlContext(new ProtectionDomain[] {\n                                                    new ProtectionDomain(null, perms)\n                                                });\n        }\n        private CalendarAccessControlContext() {\n        }\n    }\n\n    /**\n     * Reconstitutes this object from a stream (i.e., deserialize it).\n     */\n    private void readObject(ObjectInputStream stream)\n         throws IOException, ClassNotFoundException\n    {\n        final ObjectInputStream input \u003d stream;\n        input.defaultReadObject();\n\n        stamp \u003d new int[FIELD_COUNT];\n\n        // Starting with version 2 (not implemented yet), we expect that\n        // fields[], isSet[], isTimeSet, and areFieldsSet may not be\n        // streamed out anymore.  We expect \u0027time\u0027 to be correct.\n        if (serialVersionOnStream \u003e\u003d 2)\n        {\n            isTimeSet \u003d true;\n            if (fields \u003d\u003d null) {\n                fields \u003d new int[FIELD_COUNT];\n            }\n            if (isSet \u003d\u003d null) {\n                isSet \u003d new boolean[FIELD_COUNT];\n            }\n        }\n        else if (serialVersionOnStream \u003e\u003d 0)\n        {\n            for (int i\u003d0; i\u003cFIELD_COUNT; ++i) {\n                stamp[i] \u003d isSet[i] ? COMPUTED : UNSET;\n            }\n        }\n\n        serialVersionOnStream \u003d currentSerialVersion;\n\n        // If there\u0027s a ZoneInfo object, use it for zone.\n        ZoneInfo zi \u003d null;\n        try {\n            zi \u003d AccessController.doPrivileged(\n                    new PrivilegedExceptionAction\u003c\u003e() {\n                        @Override\n                        public ZoneInfo run() throws Exception {\n                            return (ZoneInfo) input.readObject();\n                        }\n                    },\n                    CalendarAccessControlContext.INSTANCE);\n        } catch (PrivilegedActionException pae) {\n            Exception e \u003d pae.getException();\n            if (!(e instanceof OptionalDataException)) {\n                if (e instanceof RuntimeException) {\n                    throw (RuntimeException) e;\n                } else if (e instanceof IOException) {\n                    throw (IOException) e;\n                } else if (e instanceof ClassNotFoundException) {\n                    throw (ClassNotFoundException) e;\n                }\n                throw new RuntimeException(e);\n            }\n        }\n        if (zi !\u003d null) {\n            zone \u003d zi;\n        }\n\n        // If the deserialized object has a SimpleTimeZone, try to\n        // replace it with a ZoneInfo equivalent (as of 1.4) in order\n        // to be compatible with the SimpleTimeZone-based\n        // implementation as much as possible.\n        if (zone instanceof SimpleTimeZone) {\n            String id \u003d zone.getID();\n            TimeZone tz \u003d TimeZone.getTimeZone(id);\n            if (tz !\u003d null \u0026\u0026 tz.hasSameRules(zone) \u0026\u0026 tz.getID().equals(id)) {\n                zone \u003d tz;\n            }\n        }\n    }\n\n    /**\n     * Converts this object to an {@link Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the\n     * same point on the time-line as this {@code Calendar}.\n     *\n     * @return the instant representing the same point on the time-line\n     * @since 1.8\n     */\n    public final Instant toInstant() {\n        return Instant.ofEpochMilli(getTimeInMillis());\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/util/Calendar.java
	at java.base/java.net.URI.create(URI.java:883)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:137)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:135)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:617)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:614)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:1040)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/util/Calendar.java
	at java.base/java.net.URI$Parser.fail(URI.java:2913)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3084)
	at java.base/java.net.URI$Parser.parse(URI.java:3120)
	at java.base/java.net.URI.<init>(URI.java:600)
	at java.base/java.net.URI.create(URI.java:881)
	... 21 more

Jun 02, 2022 8:48:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11.0.14/lib/src.zip%21/java.base/java/util/Calendar.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/util/Calendar.java
	at java.base/java.net.URI.create(URI.java:883)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:137)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:135)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:617)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:614)
	at scala.meta.internal.metals.MetalsLanguageServer.didClose(MetalsLanguageServer.scala:1209)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/util/Calendar.java
	at java.base/java.net.URI$Parser.fail(URI.java:2913)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3084)
	at java.base/java.net.URI$Parser.parse(URI.java:3120)
	at java.base/java.net.URI.<init>(URI.java:600)
	at java.base/java.net.URI.create(URI.java:881)
	... 21 more

Jun 02, 2022 8:48:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11.0.14/lib/src.zip%21/java.base/java/util/Calendar.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2017, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\n/*\n * (C) Copyright Taligent, Inc. 1996-1998 - All Rights Reserved\n * (C) Copyright IBM Corp. 1996-1998 - All Rights Reserved\n *\n *   The original version of this source code and documentation is copyrighted\n * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These\n * materials are provided under terms of a License Agreement between Taligent\n * and Sun. This technology is protected by multiple US and International\n * patents. This notice and attribution to Taligent may not be removed.\n *   Taligent is a registered trademark of Taligent, Inc.\n *\n */\n\npackage java.util;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OptionalDataException;\nimport java.io.Serializable;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.PermissionCollection;\nimport java.security.PrivilegedActionException;\nimport java.security.PrivilegedExceptionAction;\nimport java.security.ProtectionDomain;\nimport java.text.DateFormat;\nimport java.text.DateFormatSymbols;\nimport java.time.Instant;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport sun.util.BuddhistCalendar;\nimport sun.util.calendar.ZoneInfo;\nimport sun.util.locale.provider.CalendarDataUtility;\nimport sun.util.locale.provider.LocaleProviderAdapter;\nimport sun.util.locale.provider.TimeZoneNameUtility;\nimport sun.util.spi.CalendarProvider;\n\n/**\n * The \u003ccode\u003eCalendar\u003c/code\u003e class is an abstract class that provides methods\n * for converting between a specific instant in time and a set of {@link\n * #fields calendar fields} such as \u003ccode\u003eYEAR\u003c/code\u003e, \u003ccode\u003eMONTH\u003c/code\u003e,\n * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e, \u003ccode\u003eHOUR\u003c/code\u003e, and so on, and for\n * manipulating the calendar fields, such as getting the date of the next\n * week. An instant in time can be represented by a millisecond value that is\n * an offset from the \u003ca id\u003d\"Epoch\"\u003e\u003cem\u003eEpoch\u003c/em\u003e\u003c/a\u003e, January 1, 1970\n * 00:00:00.000 GMT (Gregorian).\n *\n * \u003cp\u003eThe class also provides additional fields and methods for\n * implementing a concrete calendar system outside the package. Those\n * fields and methods are defined as \u003ccode\u003eprotected\u003c/code\u003e.\n *\n * \u003cp\u003e\n * Like other locale-sensitive classes, \u003ccode\u003eCalendar\u003c/code\u003e provides a\n * class method, \u003ccode\u003egetInstance\u003c/code\u003e, for getting a generally useful\n * object of this type. \u003ccode\u003eCalendar\u003c/code\u003e\u0027s \u003ccode\u003egetInstance\u003c/code\u003e method\n * returns a \u003ccode\u003eCalendar\u003c/code\u003e object whose\n * calendar fields have been initialized with the current date and time:\n * \u003cblockquote\u003e\n * \u003cpre\u003e\n *     Calendar rightNow \u003d Calendar.getInstance();\n * \u003c/pre\u003e\n * \u003c/blockquote\u003e\n *\n * \u003cp\u003eA \u003ccode\u003eCalendar\u003c/code\u003e object can produce all the calendar field values\n * needed to implement the date-time formatting for a particular language and\n * calendar style (for example, Japanese-Gregorian, Japanese-Traditional).\n * \u003ccode\u003eCalendar\u003c/code\u003e defines the range of values returned by\n * certain calendar fields, as well as their meaning.  For example,\n * the first month of the calendar system has value \u003ccode\u003eMONTH \u003d\u003d\n * JANUARY\u003c/code\u003e for all calendars.  Other values are defined by the\n * concrete subclass, such as \u003ccode\u003eERA\u003c/code\u003e.  See individual field\n * documentation and subclass documentation for details.\n *\n * \u003ch3\u003eGetting and Setting Calendar Field Values\u003c/h3\u003e\n *\n * \u003cp\u003eThe calendar field values can be set by calling the \u003ccode\u003eset\u003c/code\u003e\n * methods. Any field values set in a \u003ccode\u003eCalendar\u003c/code\u003e will not be\n * interpreted until it needs to calculate its time value (milliseconds from\n * the Epoch) or values of the calendar fields. Calling the\n * \u003ccode\u003eget\u003c/code\u003e, \u003ccode\u003egetTimeInMillis\u003c/code\u003e, \u003ccode\u003egetTime\u003c/code\u003e,\n * \u003ccode\u003eadd\u003c/code\u003e and \u003ccode\u003eroll\u003c/code\u003e involves such calculation.\n *\n * \u003ch4\u003eLeniency\u003c/h4\u003e\n *\n * \u003cp\u003e\u003ccode\u003eCalendar\u003c/code\u003e has two modes for interpreting the calendar\n * fields, \u003cem\u003elenient\u003c/em\u003e and \u003cem\u003enon-lenient\u003c/em\u003e.  When a\n * \u003ccode\u003eCalendar\u003c/code\u003e is in lenient mode, it accepts a wider range of\n * calendar field values than it produces.  When a \u003ccode\u003eCalendar\u003c/code\u003e\n * recomputes calendar field values for return by \u003ccode\u003eget()\u003c/code\u003e, all of\n * the calendar fields are normalized. For example, a lenient\n * \u003ccode\u003eGregorianCalendar\u003c/code\u003e interprets \u003ccode\u003eMONTH \u003d\u003d JANUARY\u003c/code\u003e,\n * \u003ccode\u003eDAY_OF_MONTH \u003d\u003d 32\u003c/code\u003e as February 1.\n\n * \u003cp\u003eWhen a \u003ccode\u003eCalendar\u003c/code\u003e is in non-lenient mode, it throws an\n * exception if there is any inconsistency in its calendar fields. For\n * example, a \u003ccode\u003eGregorianCalendar\u003c/code\u003e always produces\n * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e values between 1 and the length of the month. A\n * non-lenient \u003ccode\u003eGregorianCalendar\u003c/code\u003e throws an exception upon\n * calculating its time or calendar field values if any out-of-range field\n * value has been set.\n *\n * \u003ch4\u003e\u003ca id\u003d\"first_week\"\u003eFirst Week\u003c/a\u003e\u003c/h4\u003e\n *\n * \u003ccode\u003eCalendar\u003c/code\u003e defines a locale-specific seven day week using two\n * parameters: the first day of the week and the minimal days in first week\n * (from 1 to 7).  These numbers are taken from the locale resource data or the\n * locale itself when a {@code Calendar} is constructed. If the designated\n * locale contains \"fw\" and/or \"rg\" \u003ca href\u003d\"./Locale.html#def_locale_extension\"\u003e\n * Unicode extensions\u003c/a\u003e, the first day of the week will be obtained according to\n * those extensions. If both \"fw\" and \"rg\" are specified, the value from the \"fw\"\n * extension supersedes the implicit one from the \"rg\" extension.\n * They may also be specified explicitly through the methods for setting their\n * values.\n *\n * \u003cp\u003eWhen setting or getting the \u003ccode\u003eWEEK_OF_MONTH\u003c/code\u003e or\n * \u003ccode\u003eWEEK_OF_YEAR\u003c/code\u003e fields, \u003ccode\u003eCalendar\u003c/code\u003e must determine the\n * first week of the month or year as a reference point.  The first week of a\n * month or year is defined as the earliest seven day period beginning on\n * \u003ccode\u003egetFirstDayOfWeek()\u003c/code\u003e and containing at least\n * \u003ccode\u003egetMinimalDaysInFirstWeek()\u003c/code\u003e days of that month or year.  Weeks\n * numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow\n * it.  Note that the normalized numbering returned by \u003ccode\u003eget()\u003c/code\u003e may be\n * different.  For example, a specific \u003ccode\u003eCalendar\u003c/code\u003e subclass may\n * designate the week before week 1 of a year as week \u003ccode\u003e\u003ci\u003en\u003c/i\u003e\u003c/code\u003e of\n * the previous year.\n *\n * \u003ch4\u003eCalendar Fields Resolution\u003c/h4\u003e\n *\n * When computing a date and time from the calendar fields, there\n * may be insufficient information for the computation (such as only\n * year and month with no day of month), or there may be inconsistent\n * information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15,\n * 1996 is actually a Monday). \u003ccode\u003eCalendar\u003c/code\u003e will resolve\n * calendar field values to determine the date and time in the\n * following way.\n *\n * \u003cp\u003e\u003ca id\u003d\"resolution\"\u003eIf there is any conflict in calendar field values,\n * \u003ccode\u003eCalendar\u003c/code\u003e gives priorities to calendar fields that have been set\n * more recently.\u003c/a\u003e The following are the default combinations of the\n * calendar fields. The most recent combination, as determined by the\n * most recently set single field, will be used.\n *\n * \u003cp\u003e\u003ca id\u003d\"date_resolution\"\u003eFor the date fields\u003c/a\u003e:\n * \u003cblockquote\u003e\n * \u003cpre\u003e\n * YEAR + MONTH + DAY_OF_MONTH\n * YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK\n * YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK\n * YEAR + DAY_OF_YEAR\n * YEAR + DAY_OF_WEEK + WEEK_OF_YEAR\n * \u003c/pre\u003e\u003c/blockquote\u003e\n *\n * \u003ca id\u003d\"time_resolution\"\u003eFor the time of day fields\u003c/a\u003e:\n * \u003cblockquote\u003e\n * \u003cpre\u003e\n * HOUR_OF_DAY\n * AM_PM + HOUR\n * \u003c/pre\u003e\u003c/blockquote\u003e\n *\n * \u003cp\u003eIf there are any calendar fields whose values haven\u0027t been set in the selected\n * field combination, \u003ccode\u003eCalendar\u003c/code\u003e uses their default values. The default\n * value of each field may vary by concrete calendar systems. For example, in\n * \u003ccode\u003eGregorianCalendar\u003c/code\u003e, the default of a field is the same as that\n * of the start of the Epoch: i.e., \u003ccode\u003eYEAR \u003d 1970\u003c/code\u003e, \u003ccode\u003eMONTH \u003d\n * JANUARY\u003c/code\u003e, \u003ccode\u003eDAY_OF_MONTH \u003d 1\u003c/code\u003e, etc.\n *\n * \u003cp\u003e\n * \u003cstrong\u003eNote:\u003c/strong\u003e There are certain possible ambiguities in\n * interpretation of certain singular times, which are resolved in the\n * following ways:\n * \u003col\u003e\n *     \u003cli\u003e 23:59 is the last minute of the day and 00:00 is the first\n *          minute of the next day. Thus, 23:59 on Dec 31, 1999 \u0026lt; 00:00 on\n *          Jan 1, 2000 \u0026lt; 00:01 on Jan 1, 2000.\n *\n *     \u003cli\u003e Although historically not precise, midnight also belongs to \"am\",\n *          and noon belongs to \"pm\", so on the same day,\n *          12:00 am (midnight) \u0026lt; 12:01 am, and 12:00 pm (noon) \u0026lt; 12:01 pm\n * \u003c/ol\u003e\n *\n * \u003cp\u003e\n * The date or time format strings are not part of the definition of a\n * calendar, as those must be modifiable or overridable by the user at\n * runtime. Use {@link DateFormat}\n * to format dates.\n *\n * \u003ch4\u003eField Manipulation\u003c/h4\u003e\n *\n * The calendar fields can be changed using three methods:\n * \u003ccode\u003eset()\u003c/code\u003e, \u003ccode\u003eadd()\u003c/code\u003e, and \u003ccode\u003eroll()\u003c/code\u003e.\n *\n * \u003cp\u003e\u003cstrong\u003e\u003ccode\u003eset(f, value)\u003c/code\u003e\u003c/strong\u003e changes calendar field\n * \u003ccode\u003ef\u003c/code\u003e to \u003ccode\u003evalue\u003c/code\u003e.  In addition, it sets an\n * internal member variable to indicate that calendar field \u003ccode\u003ef\u003c/code\u003e has\n * been changed. Although calendar field \u003ccode\u003ef\u003c/code\u003e is changed immediately,\n * the calendar\u0027s time value in milliseconds is not recomputed until the next call to\n * \u003ccode\u003eget()\u003c/code\u003e, \u003ccode\u003egetTime()\u003c/code\u003e, \u003ccode\u003egetTimeInMillis()\u003c/code\u003e,\n * \u003ccode\u003eadd()\u003c/code\u003e, or \u003ccode\u003eroll()\u003c/code\u003e is made. Thus, multiple calls to\n * \u003ccode\u003eset()\u003c/code\u003e do not trigger multiple, unnecessary\n * computations. As a result of changing a calendar field using\n * \u003ccode\u003eset()\u003c/code\u003e, other calendar fields may also change, depending on the\n * calendar field, the calendar field value, and the calendar system. In addition,\n * \u003ccode\u003eget(f)\u003c/code\u003e will not necessarily return \u003ccode\u003evalue\u003c/code\u003e set by\n * the call to the \u003ccode\u003eset\u003c/code\u003e method\n * after the calendar fields have been recomputed. The specifics are determined by\n * the concrete calendar class.\u003c/p\u003e\n *\n * \u003cp\u003e\u003cem\u003eExample\u003c/em\u003e: Consider a \u003ccode\u003eGregorianCalendar\u003c/code\u003e\n * originally set to August 31, 1999. Calling \u003ccode\u003eset(Calendar.MONTH,\n * Calendar.SEPTEMBER)\u003c/code\u003e sets the date to September 31,\n * 1999. This is a temporary internal representation that resolves to\n * October 1, 1999 if \u003ccode\u003egetTime()\u003c/code\u003eis then called. However, a\n * call to \u003ccode\u003eset(Calendar.DAY_OF_MONTH, 30)\u003c/code\u003e before the call to\n * \u003ccode\u003egetTime()\u003c/code\u003e sets the date to September 30, 1999, since\n * no recomputation occurs after \u003ccode\u003eset()\u003c/code\u003e itself.\u003c/p\u003e\n *\n * \u003cp\u003e\u003cstrong\u003e\u003ccode\u003eadd(f, delta)\u003c/code\u003e\u003c/strong\u003e adds \u003ccode\u003edelta\u003c/code\u003e\n * to field \u003ccode\u003ef\u003c/code\u003e.  This is equivalent to calling \u003ccode\u003eset(f,\n * get(f) + delta)\u003c/code\u003e with two adjustments:\u003c/p\u003e\n *\n * \u003cblockquote\u003e\n *   \u003cp\u003e\u003cstrong\u003eAdd rule 1\u003c/strong\u003e. The value of field \u003ccode\u003ef\u003c/code\u003e\n *   after the call minus the value of field \u003ccode\u003ef\u003c/code\u003e before the\n *   call is \u003ccode\u003edelta\u003c/code\u003e, modulo any overflow that has occurred in\n *   field \u003ccode\u003ef\u003c/code\u003e. Overflow occurs when a field value exceeds its\n *   range and, as a result, the next larger field is incremented or\n *   decremented and the field value is adjusted back into its range.\u003c/p\u003e\n *\n *   \u003cp\u003e\u003cstrong\u003eAdd rule 2\u003c/strong\u003e. If a smaller field is expected to be\n *   invariant, but it is impossible for it to be equal to its\n *   prior value because of changes in its minimum or maximum after field\n *   \u003ccode\u003ef\u003c/code\u003e is changed or other constraints, such as time zone\n *   offset changes, then its value is adjusted to be as close\n *   as possible to its expected value. A smaller field represents a\n *   smaller unit of time. \u003ccode\u003eHOUR\u003c/code\u003e is a smaller field than\n *   \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e. No adjustment is made to smaller fields\n *   that are not expected to be invariant. The calendar system\n *   determines what fields are expected to be invariant.\u003c/p\u003e\n * \u003c/blockquote\u003e\n *\n * \u003cp\u003eIn addition, unlike \u003ccode\u003eset()\u003c/code\u003e, \u003ccode\u003eadd()\u003c/code\u003e forces\n * an immediate recomputation of the calendar\u0027s milliseconds and all\n * fields.\u003c/p\u003e\n *\n * \u003cp\u003e\u003cem\u003eExample\u003c/em\u003e: Consider a \u003ccode\u003eGregorianCalendar\u003c/code\u003e\n * originally set to August 31, 1999. Calling \u003ccode\u003eadd(Calendar.MONTH,\n * 13)\u003c/code\u003e sets the calendar to September 30, 2000. \u003cstrong\u003eAdd rule\n * 1\u003c/strong\u003e sets the \u003ccode\u003eMONTH\u003c/code\u003e field to September, since\n * adding 13 months to August gives September of the next year. Since\n * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e cannot be 31 in September in a\n * \u003ccode\u003eGregorianCalendar\u003c/code\u003e, \u003cstrong\u003eadd rule 2\u003c/strong\u003e sets the\n * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e to 30, the closest possible value. Although\n * it is a smaller field, \u003ccode\u003eDAY_OF_WEEK\u003c/code\u003e is not adjusted by\n * rule 2, since it is expected to change when the month changes in a\n * \u003ccode\u003eGregorianCalendar\u003c/code\u003e.\u003c/p\u003e\n *\n * \u003cp\u003e\u003cstrong\u003e\u003ccode\u003eroll(f, delta)\u003c/code\u003e\u003c/strong\u003e adds\n * \u003ccode\u003edelta\u003c/code\u003e to field \u003ccode\u003ef\u003c/code\u003e without changing larger\n * fields. This is equivalent to calling \u003ccode\u003eadd(f, delta)\u003c/code\u003e with\n * the following adjustment:\u003c/p\u003e\n *\n * \u003cblockquote\u003e\n *   \u003cp\u003e\u003cstrong\u003eRoll rule\u003c/strong\u003e. Larger fields are unchanged after the\n *   call. A larger field represents a larger unit of\n *   time. \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e is a larger field than\n *   \u003ccode\u003eHOUR\u003c/code\u003e.\u003c/p\u003e\n * \u003c/blockquote\u003e\n *\n * \u003cp\u003e\u003cem\u003eExample\u003c/em\u003e: See {@link java.util.GregorianCalendar#roll(int, int)}.\n *\n * \u003cp\u003e\u003cstrong\u003eUsage model\u003c/strong\u003e. To motivate the behavior of\n * \u003ccode\u003eadd()\u003c/code\u003e and \u003ccode\u003eroll()\u003c/code\u003e, consider a user interface\n * component with increment and decrement buttons for the month, day, and\n * year, and an underlying \u003ccode\u003eGregorianCalendar\u003c/code\u003e. If the\n * interface reads January 31, 1999 and the user presses the month\n * increment button, what should it read? If the underlying\n * implementation uses \u003ccode\u003eset()\u003c/code\u003e, it might read March 3, 1999. A\n * better result would be February 28, 1999. Furthermore, if the user\n * presses the month increment button again, it should read March 31,\n * 1999, not March 28, 1999. By saving the original date and using either\n * \u003ccode\u003eadd()\u003c/code\u003e or \u003ccode\u003eroll()\u003c/code\u003e, depending on whether larger\n * fields should be affected, the user interface can behave as most users\n * will intuitively expect.\u003c/p\u003e\n *\n * @see          java.lang.System#currentTimeMillis()\n * @see          Date\n * @see          GregorianCalendar\n * @see          TimeZone\n * @see          java.text.DateFormat\n * @author Mark Davis, David Goldsmith, Chen-Lieh Huang, Alan Liu\n * @since 1.1\n */\npublic abstract class Calendar implements Serializable, Cloneable, Comparable\u003cCalendar\u003e {\n\n    // Data flow in Calendar\n    // ---------------------\n\n    // The current time is represented in two ways by Calendar: as UTC\n    // milliseconds from the epoch (1 January 1970 0:00 UTC), and as local\n    // fields such as MONTH, HOUR, AM_PM, etc.  It is possible to compute the\n    // millis from the fields, and vice versa.  The data needed to do this\n    // conversion is encapsulated by a TimeZone object owned by the Calendar.\n    // The data provided by the TimeZone object may also be overridden if the\n    // user sets the ZONE_OFFSET and/or DST_OFFSET fields directly. The class\n    // keeps track of what information was most recently set by the caller, and\n    // uses that to compute any other information as needed.\n\n    // If the user sets the fields using set(), the data flow is as follows.\n    // This is implemented by the Calendar subclass\u0027s computeTime() method.\n    // During this process, certain fields may be ignored.  The disambiguation\n    // algorithm for resolving which fields to pay attention to is described\n    // in the class documentation.\n\n    //   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)\n    //           |\n    //           | Using Calendar-specific algorithm\n    //           V\n    //   local standard millis\n    //           |\n    //           | Using TimeZone or user-set ZONE_OFFSET / DST_OFFSET\n    //           V\n    //   UTC millis (in time data member)\n\n    // If the user sets the UTC millis using setTime() or setTimeInMillis(),\n    // the data flow is as follows.  This is implemented by the Calendar\n    // subclass\u0027s computeFields() method.\n\n    //   UTC millis (in time data member)\n    //           |\n    //           | Using TimeZone getOffset()\n    //           V\n    //   local standard millis\n    //           |\n    //           | Using Calendar-specific algorithm\n    //           V\n    //   local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)\n\n    // In general, a round trip from fields, through local and UTC millis, and\n    // back out to fields is made when necessary.  This is implemented by the\n    // complete() method.  Resolving a partial set of fields into a UTC millis\n    // value allows all remaining fields to be generated from that value.  If\n    // the Calendar is lenient, the fields are also renormalized to standard\n    // ranges when they are regenerated.\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * era, e.g., AD or BC in the Julian calendar. This is a calendar-specific\n     * value; see subclass documentation.\n     *\n     * @see GregorianCalendar#AD\n     * @see GregorianCalendar#BC\n     */\n    public static final int ERA \u003d 0;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * year. This is a calendar-specific value; see subclass documentation.\n     */\n    public static final int YEAR \u003d 1;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * month. This is a calendar-specific value. The first month of\n     * the year in the Gregorian and Julian calendars is\n     * \u003ccode\u003eJANUARY\u003c/code\u003e which is 0; the last depends on the number\n     * of months in a year.\n     *\n     * @see #JANUARY\n     * @see #FEBRUARY\n     * @see #MARCH\n     * @see #APRIL\n     * @see #MAY\n     * @see #JUNE\n     * @see #JULY\n     * @see #AUGUST\n     * @see #SEPTEMBER\n     * @see #OCTOBER\n     * @see #NOVEMBER\n     * @see #DECEMBER\n     * @see #UNDECIMBER\n     */\n    public static final int MONTH \u003d 2;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * week number within the current year.  The first week of the year, as\n     * defined by \u003ccode\u003egetFirstDayOfWeek()\u003c/code\u003e and\n     * \u003ccode\u003egetMinimalDaysInFirstWeek()\u003c/code\u003e, has value 1.  Subclasses define\n     * the value of \u003ccode\u003eWEEK_OF_YEAR\u003c/code\u003e for days before the first week of\n     * the year.\n     *\n     * @see #getFirstDayOfWeek\n     * @see #getMinimalDaysInFirstWeek\n     */\n    public static final int WEEK_OF_YEAR \u003d 3;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * week number within the current month.  The first week of the month, as\n     * defined by \u003ccode\u003egetFirstDayOfWeek()\u003c/code\u003e and\n     * \u003ccode\u003egetMinimalDaysInFirstWeek()\u003c/code\u003e, has value 1.  Subclasses define\n     * the value of \u003ccode\u003eWEEK_OF_MONTH\u003c/code\u003e for days before the first week of\n     * the month.\n     *\n     * @see #getFirstDayOfWeek\n     * @see #getMinimalDaysInFirstWeek\n     */\n    public static final int WEEK_OF_MONTH \u003d 4;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * day of the month. This is a synonym for \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e.\n     * The first day of the month has value 1.\n     *\n     * @see #DAY_OF_MONTH\n     */\n    public static final int DATE \u003d 5;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * day of the month. This is a synonym for \u003ccode\u003eDATE\u003c/code\u003e.\n     * The first day of the month has value 1.\n     *\n     * @see #DATE\n     */\n    public static final int DAY_OF_MONTH \u003d 5;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the day\n     * number within the current year.  The first day of the year has value 1.\n     */\n    public static final int DAY_OF_YEAR \u003d 6;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the day\n     * of the week.  This field takes values \u003ccode\u003eSUNDAY\u003c/code\u003e,\n     * \u003ccode\u003eMONDAY\u003c/code\u003e, \u003ccode\u003eTUESDAY\u003c/code\u003e, \u003ccode\u003eWEDNESDAY\u003c/code\u003e,\n     * \u003ccode\u003eTHURSDAY\u003c/code\u003e, \u003ccode\u003eFRIDAY\u003c/code\u003e, and \u003ccode\u003eSATURDAY\u003c/code\u003e.\n     *\n     * @see #SUNDAY\n     * @see #MONDAY\n     * @see #TUESDAY\n     * @see #WEDNESDAY\n     * @see #THURSDAY\n     * @see #FRIDAY\n     * @see #SATURDAY\n     */\n    public static final int DAY_OF_WEEK \u003d 7;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * ordinal number of the day of the week within the current month. Together\n     * with the \u003ccode\u003eDAY_OF_WEEK\u003c/code\u003e field, this uniquely specifies a day\n     * within a month.  Unlike \u003ccode\u003eWEEK_OF_MONTH\u003c/code\u003e and\n     * \u003ccode\u003eWEEK_OF_YEAR\u003c/code\u003e, this field\u0027s value does \u003cem\u003enot\u003c/em\u003e depend on\n     * \u003ccode\u003egetFirstDayOfWeek()\u003c/code\u003e or\n     * \u003ccode\u003egetMinimalDaysInFirstWeek()\u003c/code\u003e.  \u003ccode\u003eDAY_OF_MONTH 1\u003c/code\u003e\n     * through \u003ccode\u003e7\u003c/code\u003e always correspond to \u003ccode\u003eDAY_OF_WEEK_IN_MONTH\n     * 1\u003c/code\u003e; \u003ccode\u003e8\u003c/code\u003e through \u003ccode\u003e14\u003c/code\u003e correspond to\n     * \u003ccode\u003eDAY_OF_WEEK_IN_MONTH 2\u003c/code\u003e, and so on.\n     * \u003ccode\u003eDAY_OF_WEEK_IN_MONTH 0\u003c/code\u003e indicates the week before\n     * \u003ccode\u003eDAY_OF_WEEK_IN_MONTH 1\u003c/code\u003e.  Negative values count back from the\n     * end of the month, so the last Sunday of a month is specified as\n     * \u003ccode\u003eDAY_OF_WEEK \u003d SUNDAY, DAY_OF_WEEK_IN_MONTH \u003d -1\u003c/code\u003e.  Because\n     * negative values count backward they will usually be aligned differently\n     * within the month than positive values.  For example, if a month has 31\n     * days, \u003ccode\u003eDAY_OF_WEEK_IN_MONTH -1\u003c/code\u003e will overlap\n     * \u003ccode\u003eDAY_OF_WEEK_IN_MONTH 5\u003c/code\u003e and the end of \u003ccode\u003e4\u003c/code\u003e.\n     *\n     * @see #DAY_OF_WEEK\n     * @see #WEEK_OF_MONTH\n     */\n    public static final int DAY_OF_WEEK_IN_MONTH \u003d 8;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating\n     * whether the \u003ccode\u003eHOUR\u003c/code\u003e is before or after noon.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eAM_PM\u003c/code\u003e is \u003ccode\u003ePM\u003c/code\u003e.\n     *\n     * @see #AM\n     * @see #PM\n     * @see #HOUR\n     */\n    public static final int AM_PM \u003d 9;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * hour of the morning or afternoon. \u003ccode\u003eHOUR\u003c/code\u003e is used for the\n     * 12-hour clock (0 - 11). Noon and midnight are represented by 0, not by 12.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eHOUR\u003c/code\u003e is 10.\n     *\n     * @see #AM_PM\n     * @see #HOUR_OF_DAY\n     */\n    public static final int HOUR \u003d 10;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * hour of the day. \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e is used for the 24-hour clock.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e is 22.\n     *\n     * @see #HOUR\n     */\n    public static final int HOUR_OF_DAY \u003d 11;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * minute within the hour.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eMINUTE\u003c/code\u003e is 4.\n     */\n    public static final int MINUTE \u003d 12;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * second within the minute.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eSECOND\u003c/code\u003e is 15.\n     */\n    public static final int SECOND \u003d 13;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * millisecond within the second.\n     * E.g., at 10:04:15.250 PM the \u003ccode\u003eMILLISECOND\u003c/code\u003e is 250.\n     */\n    public static final int MILLISECOND \u003d 14;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e\n     * indicating the raw offset from GMT in milliseconds.\n     * \u003cp\u003e\n     * This field reflects the correct GMT offset value of the time\n     * zone of this \u003ccode\u003eCalendar\u003c/code\u003e if the\n     * \u003ccode\u003eTimeZone\u003c/code\u003e implementation subclass supports\n     * historical GMT offset changes.\n     */\n    public static final int ZONE_OFFSET \u003d 15;\n\n    /**\n     * Field number for \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e indicating the\n     * daylight saving offset in milliseconds.\n     * \u003cp\u003e\n     * This field reflects the correct daylight saving offset value of\n     * the time zone of this \u003ccode\u003eCalendar\u003c/code\u003e if the\n     * \u003ccode\u003eTimeZone\u003c/code\u003e implementation subclass supports\n     * historical Daylight Saving Time schedule changes.\n     */\n    public static final int DST_OFFSET \u003d 16;\n\n    /**\n     * The number of distinct fields recognized by \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eset\u003c/code\u003e.\n     * Field numbers range from \u003ccode\u003e0..FIELD_COUNT-1\u003c/code\u003e.\n     */\n    public static final int FIELD_COUNT \u003d 17;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Sunday.\n     */\n    public static final int SUNDAY \u003d 1;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Monday.\n     */\n    public static final int MONDAY \u003d 2;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Tuesday.\n     */\n    public static final int TUESDAY \u003d 3;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Wednesday.\n     */\n    public static final int WEDNESDAY \u003d 4;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Thursday.\n     */\n    public static final int THURSDAY \u003d 5;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Friday.\n     */\n    public static final int FRIDAY \u003d 6;\n\n    /**\n     * Value of the {@link #DAY_OF_WEEK} field indicating\n     * Saturday.\n     */\n    public static final int SATURDAY \u003d 7;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * first month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int JANUARY \u003d 0;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * second month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int FEBRUARY \u003d 1;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * third month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int MARCH \u003d 2;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * fourth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int APRIL \u003d 3;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * fifth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int MAY \u003d 4;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * sixth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int JUNE \u003d 5;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * seventh month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int JULY \u003d 6;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * eighth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int AUGUST \u003d 7;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * ninth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int SEPTEMBER \u003d 8;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * tenth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int OCTOBER \u003d 9;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * eleventh month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int NOVEMBER \u003d 10;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * twelfth month of the year in the Gregorian and Julian calendars.\n     */\n    public static final int DECEMBER \u003d 11;\n\n    /**\n     * Value of the {@link #MONTH} field indicating the\n     * thirteenth month of the year. Although \u003ccode\u003eGregorianCalendar\u003c/code\u003e\n     * does not use this value, lunar calendars do.\n     */\n    public static final int UNDECIMBER \u003d 12;\n\n    /**\n     * Value of the {@link #AM_PM} field indicating the\n     * period of the day from midnight to just before noon.\n     */\n    public static final int AM \u003d 0;\n\n    /**\n     * Value of the {@link #AM_PM} field indicating the\n     * period of the day from noon to just before midnight.\n     */\n    public static final int PM \u003d 1;\n\n    /**\n     * A style specifier for {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating names in all styles, such as\n     * \"January\" and \"Jan\".\n     *\n     * @see #SHORT_FORMAT\n     * @see #LONG_FORMAT\n     * @see #SHORT_STANDALONE\n     * @see #LONG_STANDALONE\n     * @see #SHORT\n     * @see #LONG\n     * @since 1.6\n     */\n    public static final int ALL_STYLES \u003d 0;\n\n    static final int STANDALONE_MASK \u003d 0x8000;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} equivalent to {@link #SHORT_FORMAT}.\n     *\n     * @see #SHORT_STANDALONE\n     * @see #LONG\n     * @since 1.6\n     */\n    public static final int SHORT \u003d 1;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} equivalent to {@link #LONG_FORMAT}.\n     *\n     * @see #LONG_STANDALONE\n     * @see #SHORT\n     * @since 1.6\n     */\n    public static final int LONG \u003d 2;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a narrow name used for format. Narrow names\n     * are typically single character strings, such as \"M\" for Monday.\n     *\n     * @see #NARROW_STANDALONE\n     * @see #SHORT_FORMAT\n     * @see #LONG_FORMAT\n     * @since 1.8\n     */\n    public static final int NARROW_FORMAT \u003d 4;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a narrow name independently. Narrow names\n     * are typically single character strings, such as \"M\" for Monday.\n     *\n     * @see #NARROW_FORMAT\n     * @see #SHORT_STANDALONE\n     * @see #LONG_STANDALONE\n     * @since 1.8\n     */\n    public static final int NARROW_STANDALONE \u003d NARROW_FORMAT | STANDALONE_MASK;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a short name used for format.\n     *\n     * @see #SHORT_STANDALONE\n     * @see #LONG_FORMAT\n     * @see #LONG_STANDALONE\n     * @since 1.8\n     */\n    public static final int SHORT_FORMAT \u003d 1;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a long name used for format.\n     *\n     * @see #LONG_STANDALONE\n     * @see #SHORT_FORMAT\n     * @see #SHORT_STANDALONE\n     * @since 1.8\n     */\n    public static final int LONG_FORMAT \u003d 2;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a short name used independently,\n     * such as a month abbreviation as calendar headers.\n     *\n     * @see #SHORT_FORMAT\n     * @see #LONG_FORMAT\n     * @see #LONG_STANDALONE\n     * @since 1.8\n     */\n    public static final int SHORT_STANDALONE \u003d SHORT | STANDALONE_MASK;\n\n    /**\n     * A style specifier for {@link #getDisplayName(int, int, Locale)\n     * getDisplayName} and {@link #getDisplayNames(int, int, Locale)\n     * getDisplayNames} indicating a long name used independently,\n     * such as a month name as calendar headers.\n     *\n     * @see #LONG_FORMAT\n     * @see #SHORT_FORMAT\n     * @see #SHORT_STANDALONE\n     * @since 1.8\n     */\n    public static final int LONG_STANDALONE \u003d LONG | STANDALONE_MASK;\n\n    // Internal notes:\n    // Calendar contains two kinds of time representations: current \"time\" in\n    // milliseconds, and a set of calendar \"fields\" representing the current time.\n    // The two representations are usually in sync, but can get out of sync\n    // as follows.\n    // 1. Initially, no fields are set, and the time is invalid.\n    // 2. If the time is set, all fields are computed and in sync.\n    // 3. If a single field is set, the time is invalid.\n    // Recomputation of the time and fields happens when the object needs\n    // to return a result to the user, or use a result for a computation.\n\n    /**\n     * The calendar field values for the currently set time for this calendar.\n     * This is an array of \u003ccode\u003eFIELD_COUNT\u003c/code\u003e integers, with index values\n     * \u003ccode\u003eERA\u003c/code\u003e through \u003ccode\u003eDST_OFFSET\u003c/code\u003e.\n     * @serial\n     */\n    @SuppressWarnings(\"ProtectedField\")\n    protected int           fields[];\n\n    /**\n     * The flags which tell if a specified calendar field for the calendar is set.\n     * A new object has no fields set.  After the first call to a method\n     * which generates the fields, they all remain set after that.\n     * This is an array of \u003ccode\u003eFIELD_COUNT\u003c/code\u003e booleans, with index values\n     * \u003ccode\u003eERA\u003c/code\u003e through \u003ccode\u003eDST_OFFSET\u003c/code\u003e.\n     * @serial\n     */\n    @SuppressWarnings(\"ProtectedField\")\n    protected boolean       isSet[];\n\n    /**\n     * Pseudo-time-stamps which specify when each field was set. There\n     * are two special values, UNSET and COMPUTED. Values from\n     * MINIMUM_USER_SET to Integer.MAX_VALUE are legal user set values.\n     */\n    private transient int   stamp[];\n\n    /**\n     * The currently set time for this calendar, expressed in milliseconds after\n     * January 1, 1970, 0:00:00 GMT.\n     * @see #isTimeSet\n     * @serial\n     */\n    @SuppressWarnings(\"ProtectedField\")\n    protected long          time;\n\n    /**\n     * True if then the value of \u003ccode\u003etime\u003c/code\u003e is valid.\n     * The time is made invalid by a change to an item of \u003ccode\u003efield[]\u003c/code\u003e.\n     * @see #time\n     * @serial\n     */\n    @SuppressWarnings(\"ProtectedField\")\n    protected boolean       isTimeSet;\n\n    /**\n     * True if \u003ccode\u003efields[]\u003c/code\u003e are in sync with the currently set time.\n     * If false, then the next attempt to get the value of a field will\n     * force a recomputation of all fields from the current value of\n     * \u003ccode\u003etime\u003c/code\u003e.\n     * @serial\n     */\n    @SuppressWarnings(\"ProtectedField\")\n    protected boolean       areFieldsSet;\n\n    /**\n     * True if all fields have been set.\n     * @serial\n     */\n    transient boolean       areAllFieldsSet;\n\n    /**\n     * \u003ccode\u003eTrue\u003c/code\u003e if this calendar allows out-of-range field values during computation\n     * of \u003ccode\u003etime\u003c/code\u003e from \u003ccode\u003efields[]\u003c/code\u003e.\n     * @see #setLenient\n     * @see #isLenient\n     * @serial\n     */\n    private boolean         lenient \u003d true;\n\n    /**\n     * The \u003ccode\u003eTimeZone\u003c/code\u003e used by this calendar. \u003ccode\u003eCalendar\u003c/code\u003e\n     * uses the time zone data to translate between locale and GMT time.\n     * @serial\n     */\n    private TimeZone        zone;\n\n    /**\n     * \u003ccode\u003eTrue\u003c/code\u003e if zone references to a shared TimeZone object.\n     */\n    private transient boolean sharedZone \u003d false;\n\n    /**\n     * The first day of the week, with possible values \u003ccode\u003eSUNDAY\u003c/code\u003e,\n     * \u003ccode\u003eMONDAY\u003c/code\u003e, etc.  This is a locale-dependent value.\n     * @serial\n     */\n    private int             firstDayOfWeek;\n\n    /**\n     * The number of days required for the first week in a month or year,\n     * with possible values from 1 to 7.  This is a locale-dependent value.\n     * @serial\n     */\n    private int             minimalDaysInFirstWeek;\n\n    /**\n     * Cache to hold the firstDayOfWeek and minimalDaysInFirstWeek\n     * of a Locale.\n     */\n    private static final ConcurrentMap\u003cLocale, int[]\u003e cachedLocaleData\n        \u003d new ConcurrentHashMap\u003c\u003e(3);\n\n    // Special values of stamp[]\n    /**\n     * The corresponding fields[] has no value.\n     */\n    private static final int        UNSET \u003d 0;\n\n    /**\n     * The value of the corresponding fields[] has been calculated internally.\n     */\n    private static final int        COMPUTED \u003d 1;\n\n    /**\n     * The value of the corresponding fields[] has been set externally. Stamp\n     * values which are greater than 1 represents the (pseudo) time when the\n     * corresponding fields[] value was set.\n     */\n    private static final int        MINIMUM_USER_STAMP \u003d 2;\n\n    /**\n     * The mask value that represents all of the fields.\n     */\n    static final int ALL_FIELDS \u003d (1 \u003c\u003c FIELD_COUNT) - 1;\n\n    /**\n     * The next available value for \u003ccode\u003estamp[]\u003c/code\u003e, an internal array.\n     * This actually should not be written out to the stream, and will probably\n     * be removed from the stream in the near future.  In the meantime,\n     * a value of \u003ccode\u003eMINIMUM_USER_STAMP\u003c/code\u003e should be used.\n     * @serial\n     */\n    private int             nextStamp \u003d MINIMUM_USER_STAMP;\n\n    // the internal serial version which says which version was written\n    // - 0 (default) for version up to JDK 1.1.5\n    // - 1 for version from JDK 1.1.6, which writes a correct \u0027time\u0027 value\n    //     as well as compatible values for other fields.  This is a\n    //     transitional format.\n    // - 2 (not implemented yet) a future version, in which fields[],\n    //     areFieldsSet, and isTimeSet become transient, and isSet[] is\n    //     removed. In JDK 1.1.6 we write a format compatible with version 2.\n    static final int        currentSerialVersion \u003d 1;\n\n    /**\n     * The version of the serialized data on the stream.  Possible values:\n     * \u003cdl\u003e\n     * \u003cdt\u003e\u003cb\u003e0\u003c/b\u003e or not present on stream\u003c/dt\u003e\n     * \u003cdd\u003e\n     * JDK 1.1.5 or earlier.\n     * \u003c/dd\u003e\n     * \u003cdt\u003e\u003cb\u003e1\u003c/b\u003e\u003c/dt\u003e\n     * \u003cdd\u003e\n     * JDK 1.1.6 or later.  Writes a correct \u0027time\u0027 value\n     * as well as compatible values for other fields.  This is a\n     * transitional format.\n     * \u003c/dd\u003e\n     * \u003c/dl\u003e\n     * When streaming out this class, the most recent format\n     * and the highest allowable \u003ccode\u003eserialVersionOnStream\u003c/code\u003e\n     * is written.\n     * @serial\n     * @since 1.1.6\n     */\n    private int             serialVersionOnStream \u003d currentSerialVersion;\n\n    // Proclaim serialization compatibility with JDK 1.1\n    static final long       serialVersionUID \u003d -1807547505821590642L;\n\n    // Mask values for calendar fields\n    @SuppressWarnings(\"PointlessBitwiseExpression\")\n    static final int ERA_MASK           \u003d (1 \u003c\u003c ERA);\n    static final int YEAR_MASK          \u003d (1 \u003c\u003c YEAR);\n    static final int MONTH_MASK         \u003d (1 \u003c\u003c MONTH);\n    static final int WEEK_OF_YEAR_MASK  \u003d (1 \u003c\u003c WEEK_OF_YEAR);\n    static final int WEEK_OF_MONTH_MASK \u003d (1 \u003c\u003c WEEK_OF_MONTH);\n    static final int DAY_OF_MONTH_MASK  \u003d (1 \u003c\u003c DAY_OF_MONTH);\n    static final int DATE_MASK          \u003d DAY_OF_MONTH_MASK;\n    static final int DAY_OF_YEAR_MASK   \u003d (1 \u003c\u003c DAY_OF_YEAR);\n    static final int DAY_OF_WEEK_MASK   \u003d (1 \u003c\u003c DAY_OF_WEEK);\n    static final int DAY_OF_WEEK_IN_MONTH_MASK  \u003d (1 \u003c\u003c DAY_OF_WEEK_IN_MONTH);\n    static final int AM_PM_MASK         \u003d (1 \u003c\u003c AM_PM);\n    static final int HOUR_MASK          \u003d (1 \u003c\u003c HOUR);\n    static final int HOUR_OF_DAY_MASK   \u003d (1 \u003c\u003c HOUR_OF_DAY);\n    static final int MINUTE_MASK        \u003d (1 \u003c\u003c MINUTE);\n    static final int SECOND_MASK        \u003d (1 \u003c\u003c SECOND);\n    static final int MILLISECOND_MASK   \u003d (1 \u003c\u003c MILLISECOND);\n    static final int ZONE_OFFSET_MASK   \u003d (1 \u003c\u003c ZONE_OFFSET);\n    static final int DST_OFFSET_MASK    \u003d (1 \u003c\u003c DST_OFFSET);\n\n    /**\n     * {@code Calendar.Builder} is used for creating a {@code Calendar} from\n     * various date-time parameters.\n     *\n     * \u003cp\u003eThere are two ways to set a {@code Calendar} to a date-time value. One\n     * is to set the instant parameter to a millisecond offset from the \u003ca\n     * href\u003d\"Calendar.html#Epoch\"\u003eEpoch\u003c/a\u003e. The other is to set individual\n     * field parameters, such as {@link Calendar#YEAR YEAR}, to their desired\n     * values. These two ways can\u0027t be mixed. Trying to set both the instant and\n     * individual fields will cause an {@link IllegalStateException} to be\n     * thrown. However, it is permitted to override previous values of the\n     * instant or field parameters.\n     *\n     * \u003cp\u003eIf no enough field parameters are given for determining date and/or\n     * time, calendar specific default values are used when building a\n     * {@code Calendar}. For example, if the {@link Calendar#YEAR YEAR} value\n     * isn\u0027t given for the Gregorian calendar, 1970 will be used. If there are\n     * any conflicts among field parameters, the \u003ca\n     * href\u003d\"Calendar.html#resolution\"\u003e resolution rules\u003c/a\u003e are applied.\n     * Therefore, the order of field setting matters.\n     *\n     * \u003cp\u003eIn addition to the date-time parameters,\n     * the {@linkplain #setLocale(Locale) locale},\n     * {@linkplain #setTimeZone(TimeZone) time zone},\n     * {@linkplain #setWeekDefinition(int, int) week definition}, and\n     * {@linkplain #setLenient(boolean) leniency mode} parameters can be set.\n     *\n     * \u003cp\u003e\u003cb\u003eExamples\u003c/b\u003e\n     * \u003cp\u003eThe following are sample usages. Sample code assumes that the\n     * {@code Calendar} constants are statically imported.\n     *\n     * \u003cp\u003eThe following code produces a {@code Calendar} with date 2012-12-31\n     * (Gregorian) because Monday is the first day of a week with the \u003ca\n     * href\u003d\"GregorianCalendar.html#iso8601_compatible_setting\"\u003e ISO 8601\n     * compatible week parameters\u003c/a\u003e.\n     * \u003cpre\u003e\n     *   Calendar cal \u003d new Calendar.Builder().setCalendarType(\"iso8601\")\n     *                        .setWeekDate(2013, 1, MONDAY).build();\u003c/pre\u003e\n     * \u003cp\u003eThe following code produces a Japanese {@code Calendar} with date\n     * 1989-01-08 (Gregorian), assuming that the default {@link Calendar#ERA ERA}\n     * is \u003cem\u003eHeisei\u003c/em\u003e that started on that day.\n     * \u003cpre\u003e\n     *   Calendar cal \u003d new Calendar.Builder().setCalendarType(\"japanese\")\n     *                        .setFields(YEAR, 1, DAY_OF_YEAR, 1).build();\u003c/pre\u003e\n     *\n     * @since 1.8\n     * @see Calendar#getInstance(TimeZone, Locale)\n     * @see Calendar#fields\n     */\n    public static class Builder {\n        private static final int NFIELDS \u003d FIELD_COUNT + 1; // +1 for WEEK_YEAR\n        private static final int WEEK_YEAR \u003d FIELD_COUNT;\n\n        private long instant;\n        // Calendar.stamp[] (lower half) and Calendar.fields[] (upper half) combined\n        private int[] fields;\n        // Pseudo timestamp starting from MINIMUM_USER_STAMP.\n        // (COMPUTED is used to indicate that the instant has been set.)\n        private int nextStamp;\n        // maxFieldIndex keeps the max index of fields which have been set.\n        // (WEEK_YEAR is never included.)\n        private int maxFieldIndex;\n        private String type;\n        private TimeZone zone;\n        private boolean lenient \u003d true;\n        private Locale locale;\n        private int firstDayOfWeek, minimalDaysInFirstWeek;\n\n        /**\n         * Constructs a {@code Calendar.Builder}.\n         */\n        public Builder() {\n        }\n\n        /**\n         * Sets the instant parameter to the given {@code instant} value that is\n         * a millisecond offset from \u003ca href\u003d\"Calendar.html#Epoch\"\u003ethe\n         * Epoch\u003c/a\u003e.\n         *\n         * @param instant a millisecond offset from the Epoch\n         * @return this {@code Calendar.Builder}\n         * @throws IllegalStateException if any of the field parameters have\n         *                               already been set\n         * @see Calendar#setTime(Date)\n         * @see Calendar#setTimeInMillis(long)\n         * @see Calendar#time\n         */\n        public Builder setInstant(long instant) {\n            if (fields !\u003d null) {\n                throw new IllegalStateException();\n            }\n            this.instant \u003d instant;\n            nextStamp \u003d COMPUTED;\n            return this;\n        }\n\n        /**\n         * Sets the instant parameter to the {@code instant} value given by a\n         * {@link Date}. This method is equivalent to a call to\n         * {@link #setInstant(long) setInstant(instant.getTime())}.\n         *\n         * @param instant a {@code Date} representing a millisecond offset from\n         *                the Epoch\n         * @return this {@code Calendar.Builder}\n         * @throws NullPointerException  if {@code instant} is {@code null}\n         * @throws IllegalStateException if any of the field parameters have\n         *                               already been set\n         * @see Calendar#setTime(Date)\n         * @see Calendar#setTimeInMillis(long)\n         * @see Calendar#time\n         */\n        public Builder setInstant(Date instant) {\n            return setInstant(instant.getTime()); // NPE if instant \u003d\u003d null\n        }\n\n        /**\n         * Sets the {@code field} parameter to the given {@code value}.\n         * {@code field} is an index to the {@link Calendar#fields}, such as\n         * {@link Calendar#DAY_OF_MONTH DAY_OF_MONTH}. Field value validation is\n         * not performed in this method. Any out of range values are either\n         * normalized in lenient mode or detected as an invalid value in\n         * non-lenient mode when building a {@code Calendar}.\n         *\n         * @param field an index to the {@code Calendar} fields\n         * @param value the field value\n         * @return this {@code Calendar.Builder}\n         * @throws IllegalArgumentException if {@code field} is invalid\n         * @throws IllegalStateException if the instant value has already been set,\n         *                      or if fields have been set too many\n         *                      (approximately {@link Integer#MAX_VALUE}) times.\n         * @see Calendar#set(int, int)\n         */\n        public Builder set(int field, int value) {\n            // Note: WEEK_YEAR can\u0027t be set with this method.\n            if (field \u003c 0 || field \u003e\u003d FIELD_COUNT) {\n                throw new IllegalArgumentException(\"field is invalid\");\n            }\n            if (isInstantSet()) {\n                throw new IllegalStateException(\"instant has been set\");\n            }\n            allocateFields();\n            internalSet(field, value);\n            return this;\n        }\n\n        /**\n         * Sets field parameters to their values given by\n         * {@code fieldValuePairs} that are pairs of a field and its value.\n         * For example,\n         * \u003cpre\u003e\n         *   setFields(Calendar.YEAR, 2013,\n         *             Calendar.MONTH, Calendar.DECEMBER,\n         *             Calendar.DAY_OF_MONTH, 23);\u003c/pre\u003e\n         * is equivalent to the sequence of the following\n         * {@link #set(int, int) set} calls:\n         * \u003cpre\u003e\n         *   set(Calendar.YEAR, 2013)\n         *   .set(Calendar.MONTH, Calendar.DECEMBER)\n         *   .set(Calendar.DAY_OF_MONTH, 23);\u003c/pre\u003e\n         *\n         * @param fieldValuePairs field-value pairs\n         * @return this {@code Calendar.Builder}\n         * @throws NullPointerException if {@code fieldValuePairs} is {@code null}\n         * @throws IllegalArgumentException if any of fields are invalid,\n         *             or if {@code fieldValuePairs.length} is an odd number.\n         * @throws IllegalStateException    if the instant value has been set,\n         *             or if fields have been set too many (approximately\n         *             {@link Integer#MAX_VALUE}) times.\n         */\n        public Builder setFields(int... fieldValuePairs) {\n            int len \u003d fieldValuePairs.length;\n            if ((len % 2) !\u003d 0) {\n                throw new IllegalArgumentException();\n            }\n            if (isInstantSet()) {\n                throw new IllegalStateException(\"instant has been set\");\n            }\n            if ((nextStamp + len / 2) \u003c 0) {\n                throw new IllegalStateException(\"stamp counter overflow\");\n            }\n            allocateFields();\n            for (int i \u003d 0; i \u003c len; ) {\n                int field \u003d fieldValuePairs[i++];\n                // Note: WEEK_YEAR can\u0027t be set with this method.\n                if (field \u003c 0 || field \u003e\u003d FIELD_COUNT) {\n                    throw new IllegalArgumentException(\"field is invalid\");\n                }\n                internalSet(field, fieldValuePairs[i++]);\n            }\n            return this;\n        }\n\n        /**\n         * Sets the date field parameters to the values given by {@code year},\n         * {@code month}, and {@code dayOfMonth}. This method is equivalent to\n         * a call to:\n         * \u003cpre\u003e\n         *   setFields(Calendar.YEAR, year,\n         *             Calendar.MONTH, month,\n         *             Calendar.DAY_OF_MONTH, dayOfMonth);\u003c/pre\u003e\n         *\n         * @param year       the {@link Calendar#YEAR YEAR} value\n         * @param month      the {@link Calendar#MONTH MONTH} value\n         *                   (the month numbering is \u003cem\u003e0-based\u003c/em\u003e).\n         * @param dayOfMonth the {@link Calendar#DAY_OF_MONTH DAY_OF_MONTH} value\n         * @return this {@code Calendar.Builder}\n         */\n        public Builder setDate(int year, int month, int dayOfMonth) {\n            return setFields(YEAR, year, MONTH, month, DAY_OF_MONTH, dayOfMonth);\n        }\n\n        /**\n         * Sets the time of day field parameters to the values given by\n         * {@code hourOfDay}, {@code minute}, and {@code second}. This method is\n         * equivalent to a call to:\n         * \u003cpre\u003e\n         *   setTimeOfDay(hourOfDay, minute, second, 0);\u003c/pre\u003e\n         *\n         * @param hourOfDay the {@link Calendar#HOUR_OF_DAY HOUR_OF_DAY} value\n         *                  (24-hour clock)\n         * @param minute    the {@link Calendar#MINUTE MINUTE} value\n         * @param second    the {@link Calendar#SECOND SECOND} value\n         * @return this {@code Calendar.Builder}\n         */\n        public Builder setTimeOfDay(int hourOfDay, int minute, int second) {\n            return setTimeOfDay(hourOfDay, minute, second, 0);\n        }\n\n        /**\n         * Sets the time of day field parameters to the values given by\n         * {@code hourOfDay}, {@code minute}, {@code second}, and\n         * {@code millis}. This method is equivalent to a call to:\n         * \u003cpre\u003e\n         *   setFields(Calendar.HOUR_OF_DAY, hourOfDay,\n         *             Calendar.MINUTE, minute,\n         *             Calendar.SECOND, second,\n         *             Calendar.MILLISECOND, millis);\u003c/pre\u003e\n         *\n         * @param hourOfDay the {@link Calendar#HOUR_OF_DAY HOUR_OF_DAY} value\n         *                  (24-hour clock)\n         * @param minute    the {@link Calendar#MINUTE MINUTE} value\n         * @param second    the {@link Calendar#SECOND SECOND} value\n         * @param millis    the {@link Calendar#MILLISECOND MILLISECOND} value\n         * @return this {@code Calendar.Builder}\n         */\n        public Builder setTimeOfDay(int hourOfDay, int minute, int second, int millis) {\n            return setFields(HOUR_OF_DAY, hourOfDay, MINUTE, minute,\n                             SECOND, second, MILLISECOND, millis);\n        }\n\n        /**\n         * Sets the week-based date parameters to the values with the given\n         * date specifiers - week year, week of year, and day of week.\n         *\n         * \u003cp\u003eIf the specified calendar doesn\u0027t support week dates, the\n         * {@link #build() build} method will throw an {@link IllegalArgumentException}.\n         *\n         * @param weekYear   the week year\n         * @param weekOfYear the week number based on {@code weekYear}\n         * @param dayOfWeek  the day of week value: one of the constants\n         *     for the {@link Calendar#DAY_OF_WEEK DAY_OF_WEEK} field:\n         *     {@link Calendar#SUNDAY SUNDAY}, ..., {@link Calendar#SATURDAY SATURDAY}.\n         * @return this {@code Calendar.Builder}\n         * @see Calendar#setWeekDate(int, int, int)\n         * @see Calendar#isWeekDateSupported()\n         */\n        public Builder setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {\n            allocateFields();\n            internalSet(WEEK_YEAR, weekYear);\n            internalSet(WEEK_OF_YEAR, weekOfYear);\n            internalSet(DAY_OF_WEEK, dayOfWeek);\n            return this;\n        }\n\n        /**\n         * Sets the time zone parameter to the given {@code zone}. If no time\n         * zone parameter is given to this {@code Calendar.Builder}, the\n         * {@linkplain TimeZone#getDefault() default\n         * \u003ccode\u003eTimeZone\u003c/code\u003e} will be used in the {@link #build() build}\n         * method.\n         *\n         * @param zone the {@link TimeZone}\n         * @return this {@code Calendar.Builder}\n         * @throws NullPointerException if {@code zone} is {@code null}\n         * @see Calendar#setTimeZone(TimeZone)\n         */\n        public Builder setTimeZone(TimeZone zone) {\n            if (zone \u003d\u003d null) {\n                throw new NullPointerException();\n            }\n            this.zone \u003d zone;\n            return this;\n        }\n\n        /**\n         * Sets the lenient mode parameter to the value given by {@code lenient}.\n         * If no lenient parameter is given to this {@code Calendar.Builder},\n         * lenient mode will be used in the {@link #build() build} method.\n         *\n         * @param lenient {@code true} for lenient mode;\n         *                {@code false} for non-lenient mode\n         * @return this {@code Calendar.Builder}\n         * @see Calendar#setLenient(boolean)\n         */\n        public Builder setLenient(boolean lenient) {\n            this.lenient \u003d lenient;\n            return this;\n        }\n\n        /**\n         * Sets the calendar type parameter to the given {@code type}. The\n         * calendar type given by this method has precedence over any explicit\n         * or implicit calendar type given by the\n         * {@linkplain #setLocale(Locale) locale}.\n         *\n         * \u003cp\u003eIn addition to the available calendar types returned by the\n         * {@link Calendar#getAvailableCalendarTypes() Calendar.getAvailableCalendarTypes}\n         * method, {@code \"gregorian\"} and {@code \"iso8601\"} as aliases of\n         * {@code \"gregory\"} can be used with this method.\n         *\n         * @param type the calendar type\n         * @return this {@code Calendar.Builder}\n         * @throws NullPointerException if {@code type} is {@code null}\n         * @throws IllegalArgumentException if {@code type} is unknown\n         * @throws IllegalStateException if another calendar type has already been set\n         * @see Calendar#getCalendarType()\n         * @see Calendar#getAvailableCalendarTypes()\n         */\n        public Builder setCalendarType(String type) {\n            if (type.equals(\"gregorian\")) { // NPE if type \u003d\u003d null\n                type \u003d \"gregory\";\n            }\n            if (!Calendar.getAvailableCalendarTypes().contains(type)\n                    \u0026\u0026 !type.equals(\"iso8601\")) {\n                throw new IllegalArgumentException(\"unknown calendar type: \" + type);\n            }\n            if (this.type \u003d\u003d null) {\n                this.type \u003d type;\n            } else {\n                if (!this.type.equals(type)) {\n                    throw new IllegalStateException(\"calendar type override\");\n                }\n            }\n            return this;\n        }\n\n        /**\n         * Sets the locale parameter to the given {@code locale}. If no locale\n         * is given to this {@code Calendar.Builder}, the {@linkplain\n         * Locale#getDefault(Locale.Category) default \u003ccode\u003eLocale\u003c/code\u003e}\n         * for {@link Locale.Category#FORMAT} will be used.\n         *\n         * \u003cp\u003eIf no calendar type is explicitly given by a call to the\n         * {@link #setCalendarType(String) setCalendarType} method,\n         * the {@code Locale} value is used to determine what type of\n         * {@code Calendar} to be built.\n         *\n         * \u003cp\u003eIf no week definition parameters are explicitly given by a call to\n         * the {@link #setWeekDefinition(int,int) setWeekDefinition} method, the\n         * {@code Locale}\u0027s default values are used.\n         *\n         * @param locale the {@link Locale}\n         * @throws NullPointerException if {@code locale} is {@code null}\n         * @return this {@code Calendar.Builder}\n         * @see Calendar#getInstance(Locale)\n         */\n        public Builder setLocale(Locale locale) {\n            if (locale \u003d\u003d null) {\n                throw new NullPointerException();\n            }\n            this.locale \u003d locale;\n            return this;\n        }\n\n        /**\n         * Sets the week definition parameters to the values given by\n         * {@code firstDayOfWeek} and {@code minimalDaysInFirstWeek} that are\n         * used to determine the \u003ca href\u003d\"Calendar.html#first_week\"\u003efirst\n         * week\u003c/a\u003e of a year. The parameters given by this method have\n         * precedence over the default values given by the\n         * {@linkplain #setLocale(Locale) locale}.\n         *\n         * @param firstDayOfWeek the first day of a week; one of\n         *                       {@link Calendar#SUNDAY} to {@link Calendar#SATURDAY}\n         * @param minimalDaysInFirstWeek the minimal number of days in the first\n         *                               week (1..7)\n         * @return this {@code Calendar.Builder}\n         * @throws IllegalArgumentException if {@code firstDayOfWeek} or\n         *                                  {@code minimalDaysInFirstWeek} is invalid\n         * @see Calendar#getFirstDayOfWeek()\n         * @see Calendar#getMinimalDaysInFirstWeek()\n         */\n        public Builder setWeekDefinition(int firstDayOfWeek, int minimalDaysInFirstWeek) {\n            if (!isValidWeekParameter(firstDayOfWeek)\n                    || !isValidWeekParameter(minimalDaysInFirstWeek)) {\n                throw new IllegalArgumentException();\n            }\n            this.firstDayOfWeek \u003d firstDayOfWeek;\n            this.minimalDaysInFirstWeek \u003d minimalDaysInFirstWeek;\n            return this;\n        }\n\n        /**\n         * Returns a {@code Calendar} built from the parameters set by the\n         * setter methods. The calendar type given by the {@link #setCalendarType(String)\n         * setCalendarType} method or the {@linkplain #setLocale(Locale) locale} is\n         * used to determine what {@code Calendar} to be created. If no explicit\n         * calendar type is given, the locale\u0027s default calendar is created.\n         *\n         * \u003cp\u003eIf the calendar type is {@code \"iso8601\"}, the\n         * {@linkplain GregorianCalendar#setGregorianChange(Date) Gregorian change date}\n         * of a {@link GregorianCalendar} is set to {@code Date(Long.MIN_VALUE)}\n         * to be the \u003cem\u003eproleptic\u003c/em\u003e Gregorian calendar. Its week definition\n         * parameters are also set to be \u003ca\n         * href\u003d\"GregorianCalendar.html#iso8601_compatible_setting\"\u003ecompatible\n         * with the ISO 8601 standard\u003c/a\u003e. Note that the\n         * {@link GregorianCalendar#getCalendarType() getCalendarType} method of\n         * a {@code GregorianCalendar} created with {@code \"iso8601\"} returns\n         * {@code \"gregory\"}.\n         *\n         * \u003cp\u003eThe default values are used for locale and time zone if these\n         * parameters haven\u0027t been given explicitly.\n         * \u003cp\u003e\n         * If the locale contains the time zone with \"tz\"\n         * \u003ca href\u003d\"Locale.html#def_locale_extension\"\u003eUnicode extension\u003c/a\u003e,\n         * and time zone hasn\u0027t been given explicitly, time zone in the locale\n         * is used.\n         *\n         * \u003cp\u003eAny out of range field values are either normalized in lenient\n         * mode or detected as an invalid value in non-lenient mode.\n         *\n         * @return a {@code Calendar} built with parameters of this {@code\n         *         Calendar.Builder}\n         * @throws IllegalArgumentException if the calendar type is unknown, or\n         *             if any invalid field values are given in non-lenient mode, or\n         *             if a week date is given for the calendar type that doesn\u0027t\n         *             support week dates.\n         * @see Calendar#getInstance(TimeZone, Locale)\n         * @see Locale#getDefault(Locale.Category)\n         * @see TimeZone#getDefault()\n         */\n        public Calendar build() {\n            if (locale \u003d\u003d null) {\n                locale \u003d Locale.getDefault();\n            }\n            if (zone \u003d\u003d null) {\n                zone \u003d defaultTimeZone(locale);\n            }\n            Calendar cal;\n            if (type \u003d\u003d null) {\n                type \u003d locale.getUnicodeLocaleType(\"ca\");\n            }\n            if (type \u003d\u003d null) {\n                if (locale.getCountry() \u003d\u003d \"TH\"\n                    \u0026\u0026 locale.getLanguage() \u003d\u003d \"th\") {\n                    type \u003d \"buddhist\";\n                } else {\n                    type \u003d \"gregory\";\n                }\n            }\n            switch (type) {\n            case \"gregory\":\n                cal \u003d new GregorianCalendar(zone, locale, true);\n                break;\n            case \"iso8601\":\n                GregorianCalendar gcal \u003d new GregorianCalendar(zone, locale, true);\n                // make gcal a proleptic Gregorian\n                gcal.setGregorianChange(new Date(Long.MIN_VALUE));\n                // and week definition to be compatible with ISO 8601\n                setWeekDefinition(MONDAY, 4);\n                cal \u003d gcal;\n                break;\n            case \"buddhist\":\n                cal \u003d new BuddhistCalendar(zone, locale);\n                cal.clear();\n                break;\n            case \"japanese\":\n                cal \u003d new JapaneseImperialCalendar(zone, locale, true);\n                break;\n            default:\n                throw new IllegalArgumentException(\"unknown calendar type: \" + type);\n            }\n            cal.setLenient(lenient);\n            if (firstDayOfWeek !\u003d 0) {\n                cal.setFirstDayOfWeek(firstDayOfWeek);\n                cal.setMinimalDaysInFirstWeek(minimalDaysInFirstWeek);\n            }\n            if (isInstantSet()) {\n                cal.setTimeInMillis(instant);\n                cal.complete();\n                return cal;\n            }\n\n            if (fields !\u003d null) {\n                boolean weekDate \u003d isSet(WEEK_YEAR)\n                                       \u0026\u0026 fields[WEEK_YEAR] \u003e fields[YEAR];\n                if (weekDate \u0026\u0026 !cal.isWeekDateSupported()) {\n                    throw new IllegalArgumentException(\"week date is unsupported by \" + type);\n                }\n\n                // Set the fields from the min stamp to the max stamp so that\n                // the fields resolution works in the Calendar.\n                for (int stamp \u003d MINIMUM_USER_STAMP; stamp \u003c nextStamp; stamp++) {\n                    for (int index \u003d 0; index \u003c\u003d maxFieldIndex; index++) {\n                        if (fields[index] \u003d\u003d stamp) {\n                            cal.set(index, fields[NFIELDS + index]);\n                            break;\n                        }\n                    }\n                }\n\n                if (weekDate) {\n                    int weekOfYear \u003d isSet(WEEK_OF_YEAR) ? fields[NFIELDS + WEEK_OF_YEAR] : 1;\n                    int dayOfWeek \u003d isSet(DAY_OF_WEEK)\n                                    ? fields[NFIELDS + DAY_OF_WEEK] : cal.getFirstDayOfWeek();\n                    cal.setWeekDate(fields[NFIELDS + WEEK_YEAR], weekOfYear, dayOfWeek);\n                }\n                cal.complete();\n            }\n\n            return cal;\n        }\n\n        private void allocateFields() {\n            if (fields \u003d\u003d null) {\n                fields \u003d new int[NFIELDS * 2];\n                nextStamp \u003d MINIMUM_USER_STAMP;\n                maxFieldIndex \u003d -1;\n            }\n        }\n\n        private void internalSet(int field, int value) {\n            fields[field] \u003d nextStamp++;\n            if (nextStamp \u003c 0) {\n                throw new IllegalStateException(\"stamp counter overflow\");\n            }\n            fields[NFIELDS + field] \u003d value;\n            if (field \u003e maxFieldIndex \u0026\u0026 field \u003c WEEK_YEAR) {\n                maxFieldIndex \u003d field;\n            }\n        }\n\n        private boolean isInstantSet() {\n            return nextStamp \u003d\u003d COMPUTED;\n        }\n\n        private boolean isSet(int index) {\n            return fields !\u003d null \u0026\u0026 fields[index] \u003e UNSET;\n        }\n\n        private boolean isValidWeekParameter(int value) {\n            return value \u003e 0 \u0026\u0026 value \u003c\u003d 7;\n        }\n    }\n\n    /**\n     * Constructs a Calendar with the default time zone\n     * and the default {@link java.util.Locale.Category#FORMAT FORMAT}\n     * locale.\n     * @see     TimeZone#getDefault\n     */\n    protected Calendar()\n    {\n        this(TimeZone.getDefaultRef(), Locale.getDefault(Locale.Category.FORMAT));\n        sharedZone \u003d true;\n    }\n\n    /**\n     * Constructs a calendar with the specified time zone and locale.\n     *\n     * @param zone the time zone to use\n     * @param aLocale the locale for the week data\n     */\n    protected Calendar(TimeZone zone, Locale aLocale)\n    {\n        fields \u003d new int[FIELD_COUNT];\n        isSet \u003d new boolean[FIELD_COUNT];\n        stamp \u003d new int[FIELD_COUNT];\n\n        this.zone \u003d zone;\n        setWeekCountData(aLocale);\n    }\n\n    /**\n     * Gets a calendar using the default time zone and locale. The\n     * \u003ccode\u003eCalendar\u003c/code\u003e returned is based on the current time\n     * in the default time zone with the default\n     * {@link Locale.Category#FORMAT FORMAT} locale.\n     * \u003cp\u003e\n     * If the locale contains the time zone with \"tz\"\n     * \u003ca href\u003d\"Locale.html#def_locale_extension\"\u003eUnicode extension\u003c/a\u003e,\n     * that time zone is used instead.\n     *\n     * @return a Calendar.\n     */\n    public static Calendar getInstance()\n    {\n        Locale aLocale \u003d Locale.getDefault(Locale.Category.FORMAT);\n        return createCalendar(defaultTimeZone(aLocale), aLocale);\n    }\n\n    /**\n     * Gets a calendar using the specified time zone and default locale.\n     * The \u003ccode\u003eCalendar\u003c/code\u003e returned is based on the current time\n     * in the given time zone with the default\n     * {@link Locale.Category#FORMAT FORMAT} locale.\n     *\n     * @param zone the time zone to use\n     * @return a Calendar.\n     */\n    public static Calendar getInstance(TimeZone zone)\n    {\n        return createCalendar(zone, Locale.getDefault(Locale.Category.FORMAT));\n    }\n\n    /**\n     * Gets a calendar using the default time zone and specified locale.\n     * The \u003ccode\u003eCalendar\u003c/code\u003e returned is based on the current time\n     * in the default time zone with the given locale.\n     * \u003cp\u003e\n     * If the locale contains the time zone with \"tz\"\n     * \u003ca href\u003d\"Locale.html#def_locale_extension\"\u003eUnicode extension\u003c/a\u003e,\n     * that time zone is used instead.\n     *\n     * @param aLocale the locale for the week data\n     * @return a Calendar.\n     */\n    public static Calendar getInstance(Locale aLocale)\n    {\n        return createCalendar(defaultTimeZone(aLocale), aLocale);\n    }\n\n    /**\n     * Gets a calendar with the specified time zone and locale.\n     * The \u003ccode\u003eCalendar\u003c/code\u003e returned is based on the current time\n     * in the given time zone with the given locale.\n     *\n     * @param zone the time zone to use\n     * @param aLocale the locale for the week data\n     * @return a Calendar.\n     */\n    public static Calendar getInstance(TimeZone zone,\n                                       Locale aLocale)\n    {\n        return createCalendar(zone, aLocale);\n    }\n\n    private static TimeZone defaultTimeZone(Locale l) {\n        TimeZone defaultTZ \u003d TimeZone.getDefault();\n        String shortTZID \u003d l.getUnicodeLocaleType(\"tz\");\n        return shortTZID !\u003d null ?\n            TimeZoneNameUtility.convertLDMLShortID(shortTZID)\n                .map(TimeZone::getTimeZone)\n                .orElse(defaultTZ) :\n            defaultTZ;\n    }\n\n    private static Calendar createCalendar(TimeZone zone,\n                                           Locale aLocale)\n    {\n        CalendarProvider provider \u003d\n            LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)\n                                 .getCalendarProvider();\n        if (provider !\u003d null) {\n            try {\n                return provider.getInstance(zone, aLocale);\n            } catch (IllegalArgumentException iae) {\n                // fall back to the default instantiation\n            }\n        }\n\n        Calendar cal \u003d null;\n\n        if (aLocale.hasExtensions()) {\n            String caltype \u003d aLocale.getUnicodeLocaleType(\"ca\");\n            if (caltype !\u003d null) {\n                switch (caltype) {\n                case \"buddhist\":\n                cal \u003d new BuddhistCalendar(zone, aLocale);\n                    break;\n                case \"japanese\":\n                    cal \u003d new JapaneseImperialCalendar(zone, aLocale);\n                    break;\n                case \"gregory\":\n                    cal \u003d new GregorianCalendar(zone, aLocale);\n                    break;\n                }\n            }\n        }\n        if (cal \u003d\u003d null) {\n            // If no known calendar type is explicitly specified,\n            // perform the traditional way to create a Calendar:\n            // create a BuddhistCalendar for th_TH locale,\n            // a JapaneseImperialCalendar for ja_JP_JP locale, or\n            // a GregorianCalendar for any other locales.\n            // NOTE: The language, country and variant strings are interned.\n            if (aLocale.getLanguage() \u003d\u003d \"th\" \u0026\u0026 aLocale.getCountry() \u003d\u003d \"TH\") {\n                cal \u003d new BuddhistCalendar(zone, aLocale);\n            } else if (aLocale.getVariant() \u003d\u003d \"JP\" \u0026\u0026 aLocale.getLanguage() \u003d\u003d \"ja\"\n                       \u0026\u0026 aLocale.getCountry() \u003d\u003d \"JP\") {\n                cal \u003d new JapaneseImperialCalendar(zone, aLocale);\n            } else {\n                cal \u003d new GregorianCalendar(zone, aLocale);\n            }\n        }\n        return cal;\n    }\n\n    /**\n     * Returns an array of all locales for which the \u003ccode\u003egetInstance\u003c/code\u003e\n     * methods of this class can return localized instances.\n     * The array returned must contain at least a \u003ccode\u003eLocale\u003c/code\u003e\n     * instance equal to {@link java.util.Locale#US Locale.US}.\n     *\n     * @return An array of locales for which localized\n     *         \u003ccode\u003eCalendar\u003c/code\u003e instances are available.\n     */\n    public static synchronized Locale[] getAvailableLocales()\n    {\n        return DateFormat.getAvailableLocales();\n    }\n\n    /**\n     * Converts the current calendar field values in {@link #fields fields[]}\n     * to the millisecond time value\n     * {@link #time}.\n     *\n     * @see #complete()\n     * @see #computeFields()\n     */\n    protected abstract void computeTime();\n\n    /**\n     * Converts the current millisecond time value {@link #time}\n     * to calendar field values in {@link #fields fields[]}.\n     * This allows you to sync up the calendar field values with\n     * a new time that is set for the calendar.  The time is \u003cem\u003enot\u003c/em\u003e\n     * recomputed first; to recompute the time, then the fields, call the\n     * {@link #complete()} method.\n     *\n     * @see #computeTime()\n     */\n    protected abstract void computeFields();\n\n    /**\n     * Returns a \u003ccode\u003eDate\u003c/code\u003e object representing this\n     * \u003ccode\u003eCalendar\u003c/code\u003e\u0027s time value (millisecond offset from the \u003ca\n     * href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e\").\n     *\n     * @return a \u003ccode\u003eDate\u003c/code\u003e representing the time value.\n     * @see #setTime(Date)\n     * @see #getTimeInMillis()\n     */\n    public final Date getTime() {\n        return new Date(getTimeInMillis());\n    }\n\n    /**\n     * Sets this Calendar\u0027s time with the given \u003ccode\u003eDate\u003c/code\u003e.\n     * \u003cp\u003e\n     * Note: Calling \u003ccode\u003esetTime()\u003c/code\u003e with\n     * \u003ccode\u003eDate(Long.MAX_VALUE)\u003c/code\u003e or \u003ccode\u003eDate(Long.MIN_VALUE)\u003c/code\u003e\n     * may yield incorrect field values from \u003ccode\u003eget()\u003c/code\u003e.\n     *\n     * @param date the given Date.\n     * @see #getTime()\n     * @see #setTimeInMillis(long)\n     */\n    public final void setTime(Date date) {\n        setTimeInMillis(date.getTime());\n    }\n\n    /**\n     * Returns this Calendar\u0027s time value in milliseconds.\n     *\n     * @return the current time as UTC milliseconds from the epoch.\n     * @see #getTime()\n     * @see #setTimeInMillis(long)\n     */\n    public long getTimeInMillis() {\n        if (!isTimeSet) {\n            updateTime();\n        }\n        return time;\n    }\n\n    /**\n     * Sets this Calendar\u0027s current time from the given long value.\n     *\n     * @param millis the new time in UTC milliseconds from the epoch.\n     * @see #setTime(Date)\n     * @see #getTimeInMillis()\n     */\n    public void setTimeInMillis(long millis) {\n        // If we don\u0027t need to recalculate the calendar field values,\n        // do nothing.\n        if (time \u003d\u003d millis \u0026\u0026 isTimeSet \u0026\u0026 areFieldsSet \u0026\u0026 areAllFieldsSet\n            \u0026\u0026 (zone instanceof ZoneInfo) \u0026\u0026 !((ZoneInfo)zone).isDirty()) {\n            return;\n        }\n        time \u003d millis;\n        isTimeSet \u003d true;\n        areFieldsSet \u003d false;\n        computeFields();\n        areAllFieldsSet \u003d areFieldsSet \u003d true;\n    }\n\n    /**\n     * Returns the value of the given calendar field. In lenient mode,\n     * all calendar fields are normalized. In non-lenient mode, all\n     * calendar fields are validated and this method throws an\n     * exception if any calendar fields have out-of-range values. The\n     * normalization and validation are handled by the\n     * {@link #complete()} method, which process is calendar\n     * system dependent.\n     *\n     * @param field the given calendar field.\n     * @return the value for the given calendar field.\n     * @throws ArrayIndexOutOfBoundsException if the specified field is out of range\n     *             (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * @see #set(int,int)\n     * @see #complete()\n     */\n    public int get(int field)\n    {\n        complete();\n        return internalGet(field);\n    }\n\n    /**\n     * Returns the value of the given calendar field. This method does\n     * not involve normalization or validation of the field value.\n     *\n     * @param field the given calendar field.\n     * @return the value for the given calendar field.\n     * @see #get(int)\n     */\n    protected final int internalGet(int field)\n    {\n        return fields[field];\n    }\n\n    /**\n     * Sets the value of the given calendar field. This method does\n     * not affect any setting state of the field in this\n     * \u003ccode\u003eCalendar\u003c/code\u003e instance.\n     *\n     * @throws IndexOutOfBoundsException if the specified field is out of range\n     *             (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * @see #areFieldsSet\n     * @see #isTimeSet\n     * @see #areAllFieldsSet\n     * @see #set(int,int)\n     */\n    final void internalSet(int field, int value)\n    {\n        fields[field] \u003d value;\n    }\n\n    /**\n     * Sets the given calendar field to the given value. The value is not\n     * interpreted by this method regardless of the leniency mode.\n     *\n     * @param field the given calendar field.\n     * @param value the value to be set for the given calendar field.\n     * @throws ArrayIndexOutOfBoundsException if the specified field is out of range\n     *             (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * in non-lenient mode.\n     * @see #set(int,int,int)\n     * @see #set(int,int,int,int,int)\n     * @see #set(int,int,int,int,int,int)\n     * @see #get(int)\n     */\n    public void set(int field, int value)\n    {\n        // If the fields are partially normalized, calculate all the\n        // fields before changing any fields.\n        if (areFieldsSet \u0026\u0026 !areAllFieldsSet) {\n            computeFields();\n        }\n        internalSet(field, value);\n        isTimeSet \u003d false;\n        areFieldsSet \u003d false;\n        isSet[field] \u003d true;\n        stamp[field] \u003d nextStamp++;\n        if (nextStamp \u003d\u003d Integer.MAX_VALUE) {\n            adjustStamp();\n        }\n    }\n\n    /**\n     * Sets the values for the calendar fields \u003ccode\u003eYEAR\u003c/code\u003e,\n     * \u003ccode\u003eMONTH\u003c/code\u003e, and \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e.\n     * Previous values of other calendar fields are retained.  If this is not desired,\n     * call {@link #clear()} first.\n     *\n     * @param year the value used to set the \u003ccode\u003eYEAR\u003c/code\u003e calendar field.\n     * @param month the value used to set the \u003ccode\u003eMONTH\u003c/code\u003e calendar field.\n     * Month value is 0-based. e.g., 0 for January.\n     * @param date the value used to set the \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e calendar field.\n     * @see #set(int,int)\n     * @see #set(int,int,int,int,int)\n     * @see #set(int,int,int,int,int,int)\n     */\n    public final void set(int year, int month, int date)\n    {\n        set(YEAR, year);\n        set(MONTH, month);\n        set(DATE, date);\n    }\n\n    /**\n     * Sets the values for the calendar fields \u003ccode\u003eYEAR\u003c/code\u003e,\n     * \u003ccode\u003eMONTH\u003c/code\u003e, \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e,\n     * \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e, and \u003ccode\u003eMINUTE\u003c/code\u003e.\n     * Previous values of other fields are retained.  If this is not desired,\n     * call {@link #clear()} first.\n     *\n     * @param year the value used to set the \u003ccode\u003eYEAR\u003c/code\u003e calendar field.\n     * @param month the value used to set the \u003ccode\u003eMONTH\u003c/code\u003e calendar field.\n     * Month value is 0-based. e.g., 0 for January.\n     * @param date the value used to set the \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e calendar field.\n     * @param hourOfDay the value used to set the \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e calendar field.\n     * @param minute the value used to set the \u003ccode\u003eMINUTE\u003c/code\u003e calendar field.\n     * @see #set(int,int)\n     * @see #set(int,int,int)\n     * @see #set(int,int,int,int,int,int)\n     */\n    public final void set(int year, int month, int date, int hourOfDay, int minute)\n    {\n        set(YEAR, year);\n        set(MONTH, month);\n        set(DATE, date);\n        set(HOUR_OF_DAY, hourOfDay);\n        set(MINUTE, minute);\n    }\n\n    /**\n     * Sets the values for the fields \u003ccode\u003eYEAR\u003c/code\u003e, \u003ccode\u003eMONTH\u003c/code\u003e,\n     * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e, \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e, \u003ccode\u003eMINUTE\u003c/code\u003e, and\n     * \u003ccode\u003eSECOND\u003c/code\u003e.\n     * Previous values of other fields are retained.  If this is not desired,\n     * call {@link #clear()} first.\n     *\n     * @param year the value used to set the \u003ccode\u003eYEAR\u003c/code\u003e calendar field.\n     * @param month the value used to set the \u003ccode\u003eMONTH\u003c/code\u003e calendar field.\n     * Month value is 0-based. e.g., 0 for January.\n     * @param date the value used to set the \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e calendar field.\n     * @param hourOfDay the value used to set the \u003ccode\u003eHOUR_OF_DAY\u003c/code\u003e calendar field.\n     * @param minute the value used to set the \u003ccode\u003eMINUTE\u003c/code\u003e calendar field.\n     * @param second the value used to set the \u003ccode\u003eSECOND\u003c/code\u003e calendar field.\n     * @see #set(int,int)\n     * @see #set(int,int,int)\n     * @see #set(int,int,int,int,int)\n     */\n    public final void set(int year, int month, int date, int hourOfDay, int minute,\n                          int second)\n    {\n        set(YEAR, year);\n        set(MONTH, month);\n        set(DATE, date);\n        set(HOUR_OF_DAY, hourOfDay);\n        set(MINUTE, minute);\n        set(SECOND, second);\n    }\n\n    /**\n     * Sets all the calendar field values and the time value\n     * (millisecond offset from the \u003ca href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e) of\n     * this \u003ccode\u003eCalendar\u003c/code\u003e undefined. This means that {@link\n     * #isSet(int) isSet()} will return \u003ccode\u003efalse\u003c/code\u003e for all the\n     * calendar fields, and the date and time calculations will treat\n     * the fields as if they had never been set. A\n     * \u003ccode\u003eCalendar\u003c/code\u003e implementation class may use its specific\n     * default field values for date/time calculations. For example,\n     * \u003ccode\u003eGregorianCalendar\u003c/code\u003e uses 1970 if the\n     * \u003ccode\u003eYEAR\u003c/code\u003e field value is undefined.\n     *\n     * @see #clear(int)\n     */\n    public final void clear()\n    {\n        for (int i \u003d 0; i \u003c fields.length; ) {\n            stamp[i] \u003d fields[i] \u003d 0; // UNSET \u003d\u003d 0\n            isSet[i++] \u003d false;\n        }\n        areAllFieldsSet \u003d areFieldsSet \u003d false;\n        isTimeSet \u003d false;\n    }\n\n    /**\n     * Sets the given calendar field value and the time value\n     * (millisecond offset from the \u003ca href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e) of\n     * this \u003ccode\u003eCalendar\u003c/code\u003e undefined. This means that {@link\n     * #isSet(int) isSet(field)} will return \u003ccode\u003efalse\u003c/code\u003e, and\n     * the date and time calculations will treat the field as if it\n     * had never been set. A \u003ccode\u003eCalendar\u003c/code\u003e implementation\n     * class may use the field\u0027s specific default value for date and\n     * time calculations.\n     *\n     * \u003cp\u003eThe {@link #HOUR_OF_DAY}, {@link #HOUR} and {@link #AM_PM}\n     * fields are handled independently and the \u003ca\n     * href\u003d\"#time_resolution\"\u003ethe resolution rule for the time of\n     * day\u003c/a\u003e is applied. Clearing one of the fields doesn\u0027t reset\n     * the hour of day value of this \u003ccode\u003eCalendar\u003c/code\u003e. Use {@link\n     * #set(int,int) set(Calendar.HOUR_OF_DAY, 0)} to reset the hour\n     * value.\n     *\n     * @param field the calendar field to be cleared.\n     * @see #clear()\n     */\n    public final void clear(int field)\n    {\n        fields[field] \u003d 0;\n        stamp[field] \u003d UNSET;\n        isSet[field] \u003d false;\n\n        areAllFieldsSet \u003d areFieldsSet \u003d false;\n        isTimeSet \u003d false;\n    }\n\n    /**\n     * Determines if the given calendar field has a value set,\n     * including cases that the value has been set by internal fields\n     * calculations triggered by a \u003ccode\u003eget\u003c/code\u003e method call.\n     *\n     * @param field the calendar field to test\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the given calendar field has a value set;\n     * \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     */\n    public final boolean isSet(int field)\n    {\n        return stamp[field] !\u003d UNSET;\n    }\n\n    /**\n     * Returns the string representation of the calendar\n     * \u003ccode\u003efield\u003c/code\u003e value in the given \u003ccode\u003estyle\u003c/code\u003e and\n     * \u003ccode\u003elocale\u003c/code\u003e.  If no string representation is\n     * applicable, \u003ccode\u003enull\u003c/code\u003e is returned. This method calls\n     * {@link Calendar#get(int) get(field)} to get the calendar\n     * \u003ccode\u003efield\u003c/code\u003e value if the string representation is\n     * applicable to the given calendar \u003ccode\u003efield\u003c/code\u003e.\n     *\n     * \u003cp\u003eFor example, if this \u003ccode\u003eCalendar\u003c/code\u003e is a\n     * \u003ccode\u003eGregorianCalendar\u003c/code\u003e and its date is 2005-01-01, then\n     * the string representation of the {@link #MONTH} field would be\n     * \"January\" in the long style in an English locale or \"Jan\" in\n     * the short style. However, no string representation would be\n     * available for the {@link #DAY_OF_MONTH} field, and this method\n     * would return \u003ccode\u003enull\u003c/code\u003e.\n     *\n     * \u003cp\u003eThe default implementation supports the calendar fields for\n     * which a {@link DateFormatSymbols} has names in the given\n     * \u003ccode\u003elocale\u003c/code\u003e.\n     *\n     * @param field\n     *        the calendar field for which the string representation\n     *        is returned\n     * @param style\n     *        the style applied to the string representation; one of {@link\n     *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},\n     *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},\n     *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}.\n     * @param locale\n     *        the locale for the string representation\n     *        (any calendar types specified by {@code locale} are ignored)\n     * @return the string representation of the given\n     *        {@code field} in the given {@code style}, or\n     *        {@code null} if no string representation is\n     *        applicable.\n     * @exception IllegalArgumentException\n     *        if {@code field} or {@code style} is invalid,\n     *        or if this {@code Calendar} is non-lenient and any\n     *        of the calendar fields have invalid values\n     * @exception NullPointerException\n     *        if {@code locale} is null\n     * @since 1.6\n     */\n    public String getDisplayName(int field, int style, Locale locale) {\n        if (!checkDisplayNameParams(field, style, SHORT, NARROW_FORMAT, locale,\n                            ERA_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {\n            return null;\n        }\n\n        String calendarType \u003d getCalendarType();\n        int fieldValue \u003d get(field);\n        // the standalone/narrow styles and short era are supported only through\n        // CalendarNameProviders.\n        if (isStandaloneStyle(style) || isNarrowFormatStyle(style) ||\n            field \u003d\u003d ERA \u0026\u0026 (style \u0026 SHORT) \u003d\u003d SHORT) {\n            String val \u003d CalendarDataUtility.retrieveFieldValueName(calendarType,\n                                                                    field, fieldValue,\n                                                                    style, locale);\n            // Perform fallback here to follow the CLDR rules\n            if (val \u003d\u003d null) {\n                if (isNarrowFormatStyle(style)) {\n                    val \u003d CalendarDataUtility.retrieveFieldValueName(calendarType,\n                                                                     field, fieldValue,\n                                                                     toStandaloneStyle(style),\n                                                                     locale);\n                } else if (isStandaloneStyle(style)) {\n                    val \u003d CalendarDataUtility.retrieveFieldValueName(calendarType,\n                                                                     field, fieldValue,\n                                                                     getBaseStyle(style),\n                                                                     locale);\n                }\n            }\n            return val;\n        }\n\n        DateFormatSymbols symbols \u003d DateFormatSymbols.getInstance(locale);\n        String[] strings \u003d getFieldStrings(field, style, symbols);\n        if (strings !\u003d null) {\n            if (fieldValue \u003c strings.length) {\n                return strings[fieldValue];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns a {@code Map} containing all names of the calendar\n     * {@code field} in the given {@code style} and\n     * {@code locale} and their corresponding field values. For\n     * example, if this {@code Calendar} is a {@link\n     * GregorianCalendar}, the returned map would contain \"Jan\" to\n     * {@link #JANUARY}, \"Feb\" to {@link #FEBRUARY}, and so on, in the\n     * {@linkplain #SHORT short} style in an English locale.\n     *\n     * \u003cp\u003eNarrow names may not be unique due to use of single characters,\n     * such as \"S\" for Sunday and Saturday. In that case narrow names are not\n     * included in the returned {@code Map}.\n     *\n     * \u003cp\u003eThe values of other calendar fields may be taken into\n     * account to determine a set of display names. For example, if\n     * this {@code Calendar} is a lunisolar calendar system and\n     * the year value given by the {@link #YEAR} field has a leap\n     * month, this method would return month names containing the leap\n     * month name, and month names are mapped to their values specific\n     * for the year.\n     *\n     * \u003cp\u003eThe default implementation supports display names contained in\n     * a {@link DateFormatSymbols}. For example, if {@code field}\n     * is {@link #MONTH} and {@code style} is {@link\n     * #ALL_STYLES}, this method returns a {@code Map} containing\n     * all strings returned by {@link DateFormatSymbols#getShortMonths()}\n     * and {@link DateFormatSymbols#getMonths()}.\n     *\n     * @param field\n     *        the calendar field for which the display names are returned\n     * @param style\n     *        the style applied to the string representation; one of {@link\n     *        #SHORT_FORMAT} ({@link #SHORT}), {@link #SHORT_STANDALONE},\n     *        {@link #LONG_FORMAT} ({@link #LONG}), {@link #LONG_STANDALONE},\n     *        {@link #NARROW_FORMAT}, or {@link #NARROW_STANDALONE}\n     * @param locale\n     *        the locale for the display names\n     * @return a {@code Map} containing all display names in\n     *        {@code style} and {@code locale} and their\n     *        field values, or {@code null} if no display names\n     *        are defined for {@code field}\n     * @exception IllegalArgumentException\n     *        if {@code field} or {@code style} is invalid,\n     *        or if this {@code Calendar} is non-lenient and any\n     *        of the calendar fields have invalid values\n     * @exception NullPointerException\n     *        if {@code locale} is null\n     * @since 1.6\n     */\n    public Map\u003cString, Integer\u003e getDisplayNames(int field, int style, Locale locale) {\n        if (!checkDisplayNameParams(field, style, ALL_STYLES, NARROW_FORMAT, locale,\n                                    ERA_MASK|MONTH_MASK|DAY_OF_WEEK_MASK|AM_PM_MASK)) {\n            return null;\n        }\n\n        String calendarType \u003d getCalendarType();\n        if (style \u003d\u003d ALL_STYLES || isStandaloneStyle(style) || isNarrowFormatStyle(style) ||\n            field \u003d\u003d ERA \u0026\u0026 (style \u0026 SHORT) \u003d\u003d SHORT) {\n            Map\u003cString, Integer\u003e map;\n            map \u003d CalendarDataUtility.retrieveFieldValueNames(calendarType, field, style, locale);\n\n            // Perform fallback here to follow the CLDR rules\n            if (map \u003d\u003d null) {\n                if (isNarrowFormatStyle(style)) {\n                    map \u003d CalendarDataUtility.retrieveFieldValueNames(calendarType, field,\n                                                                      toStandaloneStyle(style), locale);\n                } else if (style !\u003d ALL_STYLES) {\n                    map \u003d CalendarDataUtility.retrieveFieldValueNames(calendarType, field,\n                                                                      getBaseStyle(style), locale);\n                }\n            }\n            return map;\n        }\n\n        // SHORT or LONG\n        return getDisplayNamesImpl(field, style, locale);\n    }\n\n    private Map\u003cString,Integer\u003e getDisplayNamesImpl(int field, int style, Locale locale) {\n        DateFormatSymbols symbols \u003d DateFormatSymbols.getInstance(locale);\n        String[] strings \u003d getFieldStrings(field, style, symbols);\n        if (strings !\u003d null) {\n            Map\u003cString,Integer\u003e names \u003d new HashMap\u003c\u003e();\n            for (int i \u003d 0; i \u003c strings.length; i++) {\n                if (strings[i].isEmpty()) {\n                    continue;\n                }\n                names.put(strings[i], i);\n            }\n            return names;\n        }\n        return null;\n    }\n\n    boolean checkDisplayNameParams(int field, int style, int minStyle, int maxStyle,\n                                   Locale locale, int fieldMask) {\n        int baseStyle \u003d getBaseStyle(style); // Ignore the standalone mask\n        if (field \u003c 0 || field \u003e\u003d fields.length ||\n            baseStyle \u003c minStyle || baseStyle \u003e maxStyle || baseStyle \u003d\u003d 3) {\n            throw new IllegalArgumentException();\n        }\n        if (locale \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        return isFieldSet(fieldMask, field);\n    }\n\n    private String[] getFieldStrings(int field, int style, DateFormatSymbols symbols) {\n        int baseStyle \u003d getBaseStyle(style); // ignore the standalone mask\n\n        // DateFormatSymbols doesn\u0027t support any narrow names.\n        if (baseStyle \u003d\u003d NARROW_FORMAT) {\n            return null;\n        }\n\n        String[] strings \u003d null;\n        switch (field) {\n        case ERA:\n            strings \u003d symbols.getEras();\n            break;\n\n        case MONTH:\n            strings \u003d (baseStyle \u003d\u003d LONG) ? symbols.getMonths() : symbols.getShortMonths();\n            break;\n\n        case DAY_OF_WEEK:\n            strings \u003d (baseStyle \u003d\u003d LONG) ? symbols.getWeekdays() : symbols.getShortWeekdays();\n            break;\n\n        case AM_PM:\n            strings \u003d symbols.getAmPmStrings();\n            break;\n        }\n        return strings;\n    }\n\n    /**\n     * Fills in any unset fields in the calendar fields. First, the {@link\n     * #computeTime()} method is called if the time value (millisecond offset\n     * from the \u003ca href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e) has not been calculated from\n     * calendar field values. Then, the {@link #computeFields()} method is\n     * called to calculate all calendar field values.\n     */\n    protected void complete()\n    {\n        if (!isTimeSet) {\n            updateTime();\n        }\n        if (!areFieldsSet || !areAllFieldsSet) {\n            computeFields(); // fills in unset fields\n            areAllFieldsSet \u003d areFieldsSet \u003d true;\n        }\n    }\n\n    /**\n     * Returns whether the value of the specified calendar field has been set\n     * externally by calling one of the setter methods rather than by the\n     * internal time calculation.\n     *\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the field has been set externally,\n     * \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @exception IndexOutOfBoundsException if the specified\n     *                \u003ccode\u003efield\u003c/code\u003e is out of range\n     *               (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * @see #selectFields()\n     * @see #setFieldsComputed(int)\n     */\n    final boolean isExternallySet(int field) {\n        return stamp[field] \u003e\u003d MINIMUM_USER_STAMP;\n    }\n\n    /**\n     * Returns a field mask (bit mask) indicating all calendar fields that\n     * have the state of externally or internally set.\n     *\n     * @return a bit mask indicating set state fields\n     */\n    final int getSetStateFields() {\n        int mask \u003d 0;\n        for (int i \u003d 0; i \u003c fields.length; i++) {\n            if (stamp[i] !\u003d UNSET) {\n                mask |\u003d 1 \u003c\u003c i;\n            }\n        }\n        return mask;\n    }\n\n    /**\n     * Sets the state of the specified calendar fields to\n     * \u003cem\u003ecomputed\u003c/em\u003e. This state means that the specified calendar fields\n     * have valid values that have been set by internal time calculation\n     * rather than by calling one of the setter methods.\n     *\n     * @param fieldMask the field to be marked as computed.\n     * @exception IndexOutOfBoundsException if the specified\n     *                \u003ccode\u003efield\u003c/code\u003e is out of range\n     *               (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * @see #isExternallySet(int)\n     * @see #selectFields()\n     */\n    final void setFieldsComputed(int fieldMask) {\n        if (fieldMask \u003d\u003d ALL_FIELDS) {\n            for (int i \u003d 0; i \u003c fields.length; i++) {\n                stamp[i] \u003d COMPUTED;\n                isSet[i] \u003d true;\n            }\n            areFieldsSet \u003d areAllFieldsSet \u003d true;\n        } else {\n            for (int i \u003d 0; i \u003c fields.length; i++) {\n                if ((fieldMask \u0026 1) \u003d\u003d 1) {\n                    stamp[i] \u003d COMPUTED;\n                    isSet[i] \u003d true;\n                } else {\n                    if (areAllFieldsSet \u0026\u0026 !isSet[i]) {\n                        areAllFieldsSet \u003d false;\n                    }\n                }\n                fieldMask \u003e\u003e\u003e\u003d 1;\n            }\n        }\n    }\n\n    /**\n     * Sets the state of the calendar fields that are \u003cem\u003enot\u003c/em\u003e specified\n     * by \u003ccode\u003efieldMask\u003c/code\u003e to \u003cem\u003eunset\u003c/em\u003e. If \u003ccode\u003efieldMask\u003c/code\u003e\n     * specifies all the calendar fields, then the state of this\n     * \u003ccode\u003eCalendar\u003c/code\u003e becomes that all the calendar fields are in sync\n     * with the time value (millisecond offset from the Epoch).\n     *\n     * @param fieldMask the field mask indicating which calendar fields are in\n     * sync with the time value.\n     * @exception IndexOutOfBoundsException if the specified\n     *                \u003ccode\u003efield\u003c/code\u003e is out of range\n     *               (\u003ccode\u003efield \u0026lt; 0 || field \u0026gt;\u003d FIELD_COUNT\u003c/code\u003e).\n     * @see #isExternallySet(int)\n     * @see #selectFields()\n     */\n    final void setFieldsNormalized(int fieldMask) {\n        if (fieldMask !\u003d ALL_FIELDS) {\n            for (int i \u003d 0; i \u003c fields.length; i++) {\n                if ((fieldMask \u0026 1) \u003d\u003d 0) {\n                    stamp[i] \u003d fields[i] \u003d 0; // UNSET \u003d\u003d 0\n                    isSet[i] \u003d false;\n                }\n                fieldMask \u003e\u003e\u003d 1;\n            }\n        }\n\n        // Some or all of the fields are in sync with the\n        // milliseconds, but the stamp values are not normalized yet.\n        areFieldsSet \u003d true;\n        areAllFieldsSet \u003d false;\n    }\n\n    /**\n     * Returns whether the calendar fields are partially in sync with the time\n     * value or fully in sync but not stamp values are not normalized yet.\n     */\n    final boolean isPartiallyNormalized() {\n        return areFieldsSet \u0026\u0026 !areAllFieldsSet;\n    }\n\n    /**\n     * Returns whether the calendar fields are fully in sync with the time\n     * value.\n     */\n    final boolean isFullyNormalized() {\n        return areFieldsSet \u0026\u0026 areAllFieldsSet;\n    }\n\n    /**\n     * Marks this Calendar as not sync\u0027d.\n     */\n    final void setUnnormalized() {\n        areFieldsSet \u003d areAllFieldsSet \u003d false;\n    }\n\n    /**\n     * Returns whether the specified \u003ccode\u003efield\u003c/code\u003e is on in the\n     * \u003ccode\u003efieldMask\u003c/code\u003e.\n     */\n    static boolean isFieldSet(int fieldMask, int field) {\n        return (fieldMask \u0026 (1 \u003c\u003c field)) !\u003d 0;\n    }\n\n    /**\n     * Returns a field mask indicating which calendar field values\n     * to be used to calculate the time value. The calendar fields are\n     * returned as a bit mask, each bit of which corresponds to a field, i.e.,\n     * the mask value of \u003ccode\u003efield\u003c/code\u003e is \u003ccode\u003e(1 \u0026lt;\u0026lt;\n     * field)\u003c/code\u003e. For example, 0x26 represents the \u003ccode\u003eYEAR\u003c/code\u003e,\n     * \u003ccode\u003eMONTH\u003c/code\u003e, and \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e fields (i.e., 0x26 is\n     * equal to\n     * \u003ccode\u003e(1\u0026lt;\u0026lt;YEAR)|(1\u0026lt;\u0026lt;MONTH)|(1\u0026lt;\u0026lt;DAY_OF_MONTH))\u003c/code\u003e.\n     *\n     * \u003cp\u003eThis method supports the calendar fields resolution as described in\n     * the class description. If the bit mask for a given field is on and its\n     * field has not been set (i.e., \u003ccode\u003eisSet(field)\u003c/code\u003e is\n     * \u003ccode\u003efalse\u003c/code\u003e), then the default value of the field has to be\n     * used, which case means that the field has been selected because the\n     * selected combination involves the field.\n     *\n     * @return a bit mask of selected fields\n     * @see #isExternallySet(int)\n     */\n    final int selectFields() {\n        // This implementation has been taken from the GregorianCalendar class.\n\n        // The YEAR field must always be used regardless of its SET\n        // state because YEAR is a mandatory field to determine the date\n        // and the default value (EPOCH_YEAR) may change through the\n        // normalization process.\n        int fieldMask \u003d YEAR_MASK;\n\n        if (stamp[ERA] !\u003d UNSET) {\n            fieldMask |\u003d ERA_MASK;\n        }\n        // Find the most recent group of fields specifying the day within\n        // the year.  These may be any of the following combinations:\n        //   MONTH + DAY_OF_MONTH\n        //   MONTH + WEEK_OF_MONTH + DAY_OF_WEEK\n        //   MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK\n        //   DAY_OF_YEAR\n        //   WEEK_OF_YEAR + DAY_OF_WEEK\n        // We look for the most recent of the fields in each group to determine\n        // the age of the group.  For groups involving a week-related field such\n        // as WEEK_OF_MONTH, DAY_OF_WEEK_IN_MONTH, or WEEK_OF_YEAR, both the\n        // week-related field and the DAY_OF_WEEK must be set for the group as a\n        // whole to be considered.  (See bug 4153860 - liu 7/24/98.)\n        int dowStamp \u003d stamp[DAY_OF_WEEK];\n        int monthStamp \u003d stamp[MONTH];\n        int domStamp \u003d stamp[DAY_OF_MONTH];\n        int womStamp \u003d aggregateStamp(stamp[WEEK_OF_MONTH], dowStamp);\n        int dowimStamp \u003d aggregateStamp(stamp[DAY_OF_WEEK_IN_MONTH], dowStamp);\n        int doyStamp \u003d stamp[DAY_OF_YEAR];\n        int woyStamp \u003d aggregateStamp(stamp[WEEK_OF_YEAR], dowStamp);\n\n        int bestStamp \u003d domStamp;\n        if (womStamp \u003e bestStamp) {\n            bestStamp \u003d womStamp;\n        }\n        if (dowimStamp \u003e bestStamp) {\n            bestStamp \u003d dowimStamp;\n        }\n        if (doyStamp \u003e bestStamp) {\n            bestStamp \u003d doyStamp;\n        }\n        if (woyStamp \u003e bestStamp) {\n            bestStamp \u003d woyStamp;\n        }\n\n        /* No complete combination exists.  Look for WEEK_OF_MONTH,\n         * DAY_OF_WEEK_IN_MONTH, or WEEK_OF_YEAR alone.  Treat DAY_OF_WEEK alone\n         * as DAY_OF_WEEK_IN_MONTH.\n         */\n        if (bestStamp \u003d\u003d UNSET) {\n            womStamp \u003d stamp[WEEK_OF_MONTH];\n            dowimStamp \u003d Math.max(stamp[DAY_OF_WEEK_IN_MONTH], dowStamp);\n            woyStamp \u003d stamp[WEEK_OF_YEAR];\n            bestStamp \u003d Math.max(Math.max(womStamp, dowimStamp), woyStamp);\n\n            /* Treat MONTH alone or no fields at all as DAY_OF_MONTH.  This may\n             * result in bestStamp \u003d domStamp \u003d UNSET if no fields are set,\n             * which indicates DAY_OF_MONTH.\n             */\n            if (bestStamp \u003d\u003d UNSET) {\n                bestStamp \u003d domStamp \u003d monthStamp;\n            }\n        }\n\n        if (bestStamp \u003d\u003d domStamp ||\n           (bestStamp \u003d\u003d womStamp \u0026\u0026 stamp[WEEK_OF_MONTH] \u003e\u003d stamp[WEEK_OF_YEAR]) ||\n           (bestStamp \u003d\u003d dowimStamp \u0026\u0026 stamp[DAY_OF_WEEK_IN_MONTH] \u003e\u003d stamp[WEEK_OF_YEAR])) {\n            fieldMask |\u003d MONTH_MASK;\n            if (bestStamp \u003d\u003d domStamp) {\n                fieldMask |\u003d DAY_OF_MONTH_MASK;\n            } else {\n                assert (bestStamp \u003d\u003d womStamp || bestStamp \u003d\u003d dowimStamp);\n                if (dowStamp !\u003d UNSET) {\n                    fieldMask |\u003d DAY_OF_WEEK_MASK;\n                }\n                if (womStamp \u003d\u003d dowimStamp) {\n                    // When they are equal, give the priority to\n                    // WEEK_OF_MONTH for compatibility.\n                    if (stamp[WEEK_OF_MONTH] \u003e\u003d stamp[DAY_OF_WEEK_IN_MONTH]) {\n                        fieldMask |\u003d WEEK_OF_MONTH_MASK;\n                    } else {\n                        fieldMask |\u003d DAY_OF_WEEK_IN_MONTH_MASK;\n                    }\n                } else {\n                    if (bestStamp \u003d\u003d womStamp) {\n                        fieldMask |\u003d WEEK_OF_MONTH_MASK;\n                    } else {\n                        assert (bestStamp \u003d\u003d dowimStamp);\n                        if (stamp[DAY_OF_WEEK_IN_MONTH] !\u003d UNSET) {\n                            fieldMask |\u003d DAY_OF_WEEK_IN_MONTH_MASK;\n                        }\n                    }\n                }\n            }\n        } else {\n            assert (bestStamp \u003d\u003d doyStamp || bestStamp \u003d\u003d woyStamp ||\n                    bestStamp \u003d\u003d UNSET);\n            if (bestStamp \u003d\u003d doyStamp) {\n                fieldMask |\u003d DAY_OF_YEAR_MASK;\n            } else {\n                assert (bestStamp \u003d\u003d woyStamp);\n                if (dowStamp !\u003d UNSET) {\n                    fieldMask |\u003d DAY_OF_WEEK_MASK;\n                }\n                fieldMask |\u003d WEEK_OF_YEAR_MASK;\n            }\n        }\n\n        // Find the best set of fields specifying the time of day.  There\n        // are only two possibilities here; the HOUR_OF_DAY or the\n        // AM_PM and the HOUR.\n        int hourOfDayStamp \u003d stamp[HOUR_OF_DAY];\n        int hourStamp \u003d aggregateStamp(stamp[HOUR], stamp[AM_PM]);\n        bestStamp \u003d (hourStamp \u003e hourOfDayStamp) ? hourStamp : hourOfDayStamp;\n\n        // if bestStamp is still UNSET, then take HOUR or AM_PM. (See 4846659)\n        if (bestStamp \u003d\u003d UNSET) {\n            bestStamp \u003d Math.max(stamp[HOUR], stamp[AM_PM]);\n        }\n\n        // Hours\n        if (bestStamp !\u003d UNSET) {\n            if (bestStamp \u003d\u003d hourOfDayStamp) {\n                fieldMask |\u003d HOUR_OF_DAY_MASK;\n            } else {\n                fieldMask |\u003d HOUR_MASK;\n                if (stamp[AM_PM] !\u003d UNSET) {\n                    fieldMask |\u003d AM_PM_MASK;\n                }\n            }\n        }\n        if (stamp[MINUTE] !\u003d UNSET) {\n            fieldMask |\u003d MINUTE_MASK;\n        }\n        if (stamp[SECOND] !\u003d UNSET) {\n            fieldMask |\u003d SECOND_MASK;\n        }\n        if (stamp[MILLISECOND] !\u003d UNSET) {\n            fieldMask |\u003d MILLISECOND_MASK;\n        }\n        if (stamp[ZONE_OFFSET] \u003e\u003d MINIMUM_USER_STAMP) {\n                fieldMask |\u003d ZONE_OFFSET_MASK;\n        }\n        if (stamp[DST_OFFSET] \u003e\u003d MINIMUM_USER_STAMP) {\n            fieldMask |\u003d DST_OFFSET_MASK;\n        }\n\n        return fieldMask;\n    }\n\n    int getBaseStyle(int style) {\n        return style \u0026 ~STANDALONE_MASK;\n    }\n\n    private int toStandaloneStyle(int style) {\n        return style | STANDALONE_MASK;\n    }\n\n    private boolean isStandaloneStyle(int style) {\n        return (style \u0026 STANDALONE_MASK) !\u003d 0;\n    }\n\n    private boolean isNarrowStyle(int style) {\n        return style \u003d\u003d NARROW_FORMAT || style \u003d\u003d NARROW_STANDALONE;\n    }\n\n    private boolean isNarrowFormatStyle(int style) {\n        return style \u003d\u003d NARROW_FORMAT;\n    }\n\n    /**\n     * Returns the pseudo-time-stamp for two fields, given their\n     * individual pseudo-time-stamps.  If either of the fields\n     * is unset, then the aggregate is unset.  Otherwise, the\n     * aggregate is the later of the two stamps.\n     */\n    private static int aggregateStamp(int stamp_a, int stamp_b) {\n        if (stamp_a \u003d\u003d UNSET || stamp_b \u003d\u003d UNSET) {\n            return UNSET;\n        }\n        return (stamp_a \u003e stamp_b) ? stamp_a : stamp_b;\n    }\n\n    /**\n     * Returns an unmodifiable {@code Set} containing all calendar types\n     * supported by {@code Calendar} in the runtime environment. The available\n     * calendar types can be used for the \u003ca\n     * href\u003d\"Locale.html#def_locale_extension\"\u003eUnicode locale extensions\u003c/a\u003e.\n     * The {@code Set} returned contains at least {@code \"gregory\"}. The\n     * calendar types don\u0027t include aliases, such as {@code \"gregorian\"} for\n     * {@code \"gregory\"}.\n     *\n     * @return an unmodifiable {@code Set} containing all available calendar types\n     * @since 1.8\n     * @see #getCalendarType()\n     * @see Calendar.Builder#setCalendarType(String)\n     * @see Locale#getUnicodeLocaleType(String)\n     */\n    public static Set\u003cString\u003e getAvailableCalendarTypes() {\n        return AvailableCalendarTypes.SET;\n    }\n\n    private static class AvailableCalendarTypes {\n        private static final Set\u003cString\u003e SET;\n        static {\n            Set\u003cString\u003e set \u003d new HashSet\u003c\u003e(3);\n            set.add(\"gregory\");\n            set.add(\"buddhist\");\n            set.add(\"japanese\");\n            SET \u003d Collections.unmodifiableSet(set);\n        }\n        private AvailableCalendarTypes() {\n        }\n    }\n\n    /**\n     * Returns the calendar type of this {@code Calendar}. Calendar types are\n     * defined by the \u003cem\u003eUnicode Locale Data Markup Language (LDML)\u003c/em\u003e\n     * specification.\n     *\n     * \u003cp\u003eThe default implementation of this method returns the class name of\n     * this {@code Calendar} instance. Any subclasses that implement\n     * LDML-defined calendar systems should override this method to return\n     * appropriate calendar types.\n     *\n     * @return the LDML-defined calendar type or the class name of this\n     *         {@code Calendar} instance\n     * @since 1.8\n     * @see \u003ca href\u003d\"Locale.html#def_extensions\"\u003eLocale extensions\u003c/a\u003e\n     * @see Locale.Builder#setLocale(Locale)\n     * @see Locale.Builder#setUnicodeLocaleKeyword(String, String)\n     */\n    public String getCalendarType() {\n        return this.getClass().getName();\n    }\n\n    /**\n     * Compares this \u003ccode\u003eCalendar\u003c/code\u003e to the specified\n     * \u003ccode\u003eObject\u003c/code\u003e.  The result is \u003ccode\u003etrue\u003c/code\u003e if and only if\n     * the argument is a \u003ccode\u003eCalendar\u003c/code\u003e object of the same calendar\n     * system that represents the same time value (millisecond offset from the\n     * \u003ca href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e) under the same\n     * \u003ccode\u003eCalendar\u003c/code\u003e parameters as this object.\n     *\n     * \u003cp\u003eThe \u003ccode\u003eCalendar\u003c/code\u003e parameters are the values represented\n     * by the \u003ccode\u003eisLenient\u003c/code\u003e, \u003ccode\u003egetFirstDayOfWeek\u003c/code\u003e,\n     * \u003ccode\u003egetMinimalDaysInFirstWeek\u003c/code\u003e and \u003ccode\u003egetTimeZone\u003c/code\u003e\n     * methods. If there is any difference in those parameters\n     * between the two \u003ccode\u003eCalendar\u003c/code\u003es, this method returns\n     * \u003ccode\u003efalse\u003c/code\u003e.\n     *\n     * \u003cp\u003eUse the {@link #compareTo(Calendar) compareTo} method to\n     * compare only the time values.\n     *\n     * @param obj the object to compare with.\n     * @return \u003ccode\u003etrue\u003c/code\u003e if this object is equal to \u003ccode\u003eobj\u003c/code\u003e;\n     * \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     */\n    @SuppressWarnings(\"EqualsWhichDoesntCheckParameterClass\")\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        try {\n            Calendar that \u003d (Calendar)obj;\n            return compareTo(getMillisOf(that)) \u003d\u003d 0 \u0026\u0026\n                lenient \u003d\u003d that.lenient \u0026\u0026\n                firstDayOfWeek \u003d\u003d that.firstDayOfWeek \u0026\u0026\n                minimalDaysInFirstWeek \u003d\u003d that.minimalDaysInFirstWeek \u0026\u0026\n                (zone instanceof ZoneInfo ?\n                    zone.equals(that.zone) :\n                    zone.equals(that.getTimeZone()));\n        } catch (Exception e) {\n            // Note: GregorianCalendar.computeTime throws\n            // IllegalArgumentException if the ERA value is invalid\n            // even it\u0027s in lenient mode.\n        }\n        return false;\n    }\n\n    /**\n     * Returns a hash code for this calendar.\n     *\n     * @return a hash code value for this object.\n     * @since 1.2\n     */\n    @Override\n    public int hashCode() {\n        // \u0027otheritems\u0027 represents the hash code for the previous versions.\n        int otheritems \u003d (lenient ? 1 : 0)\n            | (firstDayOfWeek \u003c\u003c 1)\n            | (minimalDaysInFirstWeek \u003c\u003c 4)\n            | (zone.hashCode() \u003c\u003c 7);\n        long t \u003d getMillisOf(this);\n        return (int) t ^ (int)(t \u003e\u003e 32) ^ otheritems;\n    }\n\n    /**\n     * Returns whether this \u003ccode\u003eCalendar\u003c/code\u003e represents a time\n     * before the time represented by the specified\n     * \u003ccode\u003eObject\u003c/code\u003e. This method is equivalent to:\n     * \u003cpre\u003e{@code\n     *         compareTo(when) \u003c 0\n     * }\u003c/pre\u003e\n     * if and only if \u003ccode\u003ewhen\u003c/code\u003e is a \u003ccode\u003eCalendar\u003c/code\u003e\n     * instance. Otherwise, the method returns \u003ccode\u003efalse\u003c/code\u003e.\n     *\n     * @param when the \u003ccode\u003eObject\u003c/code\u003e to be compared\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the time of this\n     * \u003ccode\u003eCalendar\u003c/code\u003e is before the time represented by\n     * \u003ccode\u003ewhen\u003c/code\u003e; \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @see     #compareTo(Calendar)\n     */\n    public boolean before(Object when) {\n        return when instanceof Calendar\n            \u0026\u0026 compareTo((Calendar)when) \u003c 0;\n    }\n\n    /**\n     * Returns whether this \u003ccode\u003eCalendar\u003c/code\u003e represents a time\n     * after the time represented by the specified\n     * \u003ccode\u003eObject\u003c/code\u003e. This method is equivalent to:\n     * \u003cpre\u003e{@code\n     *         compareTo(when) \u003e 0\n     * }\u003c/pre\u003e\n     * if and only if \u003ccode\u003ewhen\u003c/code\u003e is a \u003ccode\u003eCalendar\u003c/code\u003e\n     * instance. Otherwise, the method returns \u003ccode\u003efalse\u003c/code\u003e.\n     *\n     * @param when the \u003ccode\u003eObject\u003c/code\u003e to be compared\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the time of this \u003ccode\u003eCalendar\u003c/code\u003e is\n     * after the time represented by \u003ccode\u003ewhen\u003c/code\u003e; \u003ccode\u003efalse\u003c/code\u003e\n     * otherwise.\n     * @see     #compareTo(Calendar)\n     */\n    public boolean after(Object when) {\n        return when instanceof Calendar\n            \u0026\u0026 compareTo((Calendar)when) \u003e 0;\n    }\n\n    /**\n     * Compares the time values (millisecond offsets from the \u003ca\n     * href\u003d\"#Epoch\"\u003eEpoch\u003c/a\u003e) represented by two\n     * \u003ccode\u003eCalendar\u003c/code\u003e objects.\n     *\n     * @param anotherCalendar the \u003ccode\u003eCalendar\u003c/code\u003e to be compared.\n     * @return the value \u003ccode\u003e0\u003c/code\u003e if the time represented by the argument\n     * is equal to the time represented by this \u003ccode\u003eCalendar\u003c/code\u003e; a value\n     * less than \u003ccode\u003e0\u003c/code\u003e if the time of this \u003ccode\u003eCalendar\u003c/code\u003e is\n     * before the time represented by the argument; and a value greater than\n     * \u003ccode\u003e0\u003c/code\u003e if the time of this \u003ccode\u003eCalendar\u003c/code\u003e is after the\n     * time represented by the argument.\n     * @exception NullPointerException if the specified \u003ccode\u003eCalendar\u003c/code\u003e is\n     *            \u003ccode\u003enull\u003c/code\u003e.\n     * @exception IllegalArgumentException if the time value of the\n     * specified \u003ccode\u003eCalendar\u003c/code\u003e object can\u0027t be obtained due to\n     * any invalid calendar values.\n     * @since   1.5\n     */\n    @Override\n    public int compareTo(Calendar anotherCalendar) {\n        return compareTo(getMillisOf(anotherCalendar));\n    }\n\n    /**\n     * Adds or subtracts the specified amount of time to the given calendar field,\n     * based on the calendar\u0027s rules. For example, to subtract 5 days from\n     * the current time of the calendar, you can achieve it by calling:\n     * \u003cp\u003e\u003ccode\u003eadd(Calendar.DAY_OF_MONTH, -5)\u003c/code\u003e.\n     *\n     * @param field the calendar field.\n     * @param amount the amount of date or time to be added to the field.\n     * @see #roll(int,int)\n     * @see #set(int,int)\n     */\n    public abstract void add(int field, int amount);\n\n    /**\n     * Adds or subtracts (up/down) a single unit of time on the given time\n     * field without changing larger fields. For example, to roll the current\n     * date up by one day, you can achieve it by calling:\n     * \u003cp\u003eroll(Calendar.DATE, true).\n     * When rolling on the year or Calendar.YEAR field, it will roll the year\n     * value in the range between 1 and the value returned by calling\n     * \u003ccode\u003egetMaximum(Calendar.YEAR)\u003c/code\u003e.\n     * When rolling on the month or Calendar.MONTH field, other fields like\n     * date might conflict and, need to be changed. For instance,\n     * rolling the month on the date 01/31/96 will result in 02/29/96.\n     * When rolling on the hour-in-day or Calendar.HOUR_OF_DAY field, it will\n     * roll the hour value in the range between 0 and 23, which is zero-based.\n     *\n     * @param field the time field.\n     * @param up indicates if the value of the specified time field is to be\n     * rolled up or rolled down. Use true if rolling up, false otherwise.\n     * @see Calendar#add(int,int)\n     * @see Calendar#set(int,int)\n     */\n    public abstract void roll(int field, boolean up);\n\n    /**\n     * Adds the specified (signed) amount to the specified calendar field\n     * without changing larger fields.  A negative amount means to roll\n     * down.\n     *\n     * \u003cp\u003eNOTE:  This default implementation on \u003ccode\u003eCalendar\u003c/code\u003e just repeatedly calls the\n     * version of {@link #roll(int,boolean) roll()} that rolls by one unit.  This may not\n     * always do the right thing.  For example, if the \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e field is 31,\n     * rolling through February will leave it set to 28.  The \u003ccode\u003eGregorianCalendar\u003c/code\u003e\n     * version of this function takes care of this problem.  Other subclasses\n     * should also provide overrides of this function that do the right thing.\n     *\n     * @param field the calendar field.\n     * @param amount the signed amount to add to the calendar \u003ccode\u003efield\u003c/code\u003e.\n     * @since 1.2\n     * @see #roll(int,boolean)\n     * @see #add(int,int)\n     * @see #set(int,int)\n     */\n    public void roll(int field, int amount)\n    {\n        while (amount \u003e 0) {\n            roll(field, true);\n            amount--;\n        }\n        while (amount \u003c 0) {\n            roll(field, false);\n            amount++;\n        }\n    }\n\n    /**\n     * Sets the time zone with the given time zone value.\n     *\n     * @param value the given time zone.\n     */\n    public void setTimeZone(TimeZone value)\n    {\n        zone \u003d value;\n        sharedZone \u003d false;\n        /* Recompute the fields from the time using the new zone.  This also\n         * works if isTimeSet is false (after a call to set()).  In that case\n         * the time will be computed from the fields using the new zone, then\n         * the fields will get recomputed from that.  Consider the sequence of\n         * calls: cal.setTimeZone(EST); cal.set(HOUR, 1); cal.setTimeZone(PST).\n         * Is cal set to 1 o\u0027clock EST or 1 o\u0027clock PST?  Answer: PST.  More\n         * generally, a call to setTimeZone() affects calls to set() BEFORE AND\n         * AFTER it up to the next call to complete().\n         */\n        areAllFieldsSet \u003d areFieldsSet \u003d false;\n    }\n\n    /**\n     * Gets the time zone.\n     *\n     * @return the time zone object associated with this calendar.\n     */\n    public TimeZone getTimeZone()\n    {\n        // If the TimeZone object is shared by other Calendar instances, then\n        // create a clone.\n        if (sharedZone) {\n            zone \u003d (TimeZone) zone.clone();\n            sharedZone \u003d false;\n        }\n        return zone;\n    }\n\n    /**\n     * Returns the time zone (without cloning).\n     */\n    TimeZone getZone() {\n        return zone;\n    }\n\n    /**\n     * Sets the sharedZone flag to \u003ccode\u003eshared\u003c/code\u003e.\n     */\n    void setZoneShared(boolean shared) {\n        sharedZone \u003d shared;\n    }\n\n    /**\n     * Specifies whether or not date/time interpretation is to be lenient.  With\n     * lenient interpretation, a date such as \"February 942, 1996\" will be\n     * treated as being equivalent to the 941st day after February 1, 1996.\n     * With strict (non-lenient) interpretation, such dates will cause an exception to be\n     * thrown. The default is lenient.\n     *\n     * @param lenient \u003ccode\u003etrue\u003c/code\u003e if the lenient mode is to be turned\n     * on; \u003ccode\u003efalse\u003c/code\u003e if it is to be turned off.\n     * @see #isLenient()\n     * @see java.text.DateFormat#setLenient\n     */\n    public void setLenient(boolean lenient)\n    {\n        this.lenient \u003d lenient;\n    }\n\n    /**\n     * Tells whether date/time interpretation is to be lenient.\n     *\n     * @return \u003ccode\u003etrue\u003c/code\u003e if the interpretation mode of this calendar is lenient;\n     * \u003ccode\u003efalse\u003c/code\u003e otherwise.\n     * @see #setLenient(boolean)\n     */\n    public boolean isLenient()\n    {\n        return lenient;\n    }\n\n    /**\n     * Sets what the first day of the week is; e.g., \u003ccode\u003eSUNDAY\u003c/code\u003e in the U.S.,\n     * \u003ccode\u003eMONDAY\u003c/code\u003e in France.\n     *\n     * @param value the given first day of the week.\n     * @see #getFirstDayOfWeek()\n     * @see #getMinimalDaysInFirstWeek()\n     */\n    public void setFirstDayOfWeek(int value)\n    {\n        if (firstDayOfWeek \u003d\u003d value) {\n            return;\n        }\n        firstDayOfWeek \u003d value;\n        invalidateWeekFields();\n    }\n\n    /**\n     * Gets what the first day of the week is; e.g., \u003ccode\u003eSUNDAY\u003c/code\u003e in the U.S.,\n     * \u003ccode\u003eMONDAY\u003c/code\u003e in France.\n     *\n     * @return the first day of the week.\n     * @see #setFirstDayOfWeek(int)\n     * @see #getMinimalDaysInFirstWeek()\n     */\n    public int getFirstDayOfWeek()\n    {\n        return firstDayOfWeek;\n    }\n\n    /**\n     * Sets what the minimal days required in the first week of the year are;\n     * For example, if the first week is defined as one that contains the first\n     * day of the first month of a year, call this method with value 1. If it\n     * must be a full week, use value 7.\n     *\n     * @param value the given minimal days required in the first week\n     * of the year.\n     * @see #getMinimalDaysInFirstWeek()\n     */\n    public void setMinimalDaysInFirstWeek(int value)\n    {\n        if (minimalDaysInFirstWeek \u003d\u003d value) {\n            return;\n        }\n        minimalDaysInFirstWeek \u003d value;\n        invalidateWeekFields();\n    }\n\n    /**\n     * Gets what the minimal days required in the first week of the year are;\n     * e.g., if the first week is defined as one that contains the first day\n     * of the first month of a year, this method returns 1. If\n     * the minimal days required must be a full week, this method\n     * returns 7.\n     *\n     * @return the minimal days required in the first week of the year.\n     * @see #setMinimalDaysInFirstWeek(int)\n     */\n    public int getMinimalDaysInFirstWeek()\n    {\n        return minimalDaysInFirstWeek;\n    }\n\n    /**\n     * Returns whether this {@code Calendar} supports week dates.\n     *\n     * \u003cp\u003eThe default implementation of this method returns {@code false}.\n     *\n     * @return {@code true} if this {@code Calendar} supports week dates;\n     *         {@code false} otherwise.\n     * @see #getWeekYear()\n     * @see #setWeekDate(int,int,int)\n     * @see #getWeeksInWeekYear()\n     * @since 1.7\n     */\n    public boolean isWeekDateSupported() {\n        return false;\n    }\n\n    /**\n     * Returns the week year represented by this {@code Calendar}. The\n     * week year is in sync with the week cycle. The {@linkplain\n     * #getFirstDayOfWeek() first day of the first week} is the first\n     * day of the week year.\n     *\n     * \u003cp\u003eThe default implementation of this method throws an\n     * {@link UnsupportedOperationException}.\n     *\n     * @return the week year of this {@code Calendar}\n     * @exception UnsupportedOperationException\n     *            if any week year numbering isn\u0027t supported\n     *            in this {@code Calendar}.\n     * @see #isWeekDateSupported()\n     * @see #getFirstDayOfWeek()\n     * @see #getMinimalDaysInFirstWeek()\n     * @since 1.7\n     */\n    public int getWeekYear() {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Sets the date of this {@code Calendar} with the given date\n     * specifiers - week year, week of year, and day of week.\n     *\n     * \u003cp\u003eUnlike the {@code set} method, all of the calendar fields\n     * and {@code time} values are calculated upon return.\n     *\n     * \u003cp\u003eIf {@code weekOfYear} is out of the valid week-of-year range\n     * in {@code weekYear}, the {@code weekYear} and {@code\n     * weekOfYear} values are adjusted in lenient mode, or an {@code\n     * IllegalArgumentException} is thrown in non-lenient mode.\n     *\n     * \u003cp\u003eThe default implementation of this method throws an\n     * {@code UnsupportedOperationException}.\n     *\n     * @param weekYear   the week year\n     * @param weekOfYear the week number based on {@code weekYear}\n     * @param dayOfWeek  the day of week value: one of the constants\n     *                   for the {@link #DAY_OF_WEEK} field: {@link\n     *                   #SUNDAY}, ..., {@link #SATURDAY}.\n     * @exception IllegalArgumentException\n     *            if any of the given date specifiers is invalid\n     *            or any of the calendar fields are inconsistent\n     *            with the given date specifiers in non-lenient mode\n     * @exception UnsupportedOperationException\n     *            if any week year numbering isn\u0027t supported in this\n     *            {@code Calendar}.\n     * @see #isWeekDateSupported()\n     * @see #getFirstDayOfWeek()\n     * @see #getMinimalDaysInFirstWeek()\n     * @since 1.7\n     */\n    public void setWeekDate(int weekYear, int weekOfYear, int dayOfWeek) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Returns the number of weeks in the week year represented by this\n     * {@code Calendar}.\n     *\n     * \u003cp\u003eThe default implementation of this method throws an\n     * {@code UnsupportedOperationException}.\n     *\n     * @return the number of weeks in the week year.\n     * @exception UnsupportedOperationException\n     *            if any week year numbering isn\u0027t supported in this\n     *            {@code Calendar}.\n     * @see #WEEK_OF_YEAR\n     * @see #isWeekDateSupported()\n     * @see #getWeekYear()\n     * @see #getActualMaximum(int)\n     * @since 1.7\n     */\n    public int getWeeksInWeekYear() {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Returns the minimum value for the given calendar field of this\n     * \u003ccode\u003eCalendar\u003c/code\u003e instance. The minimum value is defined as\n     * the smallest value returned by the {@link #get(int) get} method\n     * for any possible time value.  The minimum value depends on\n     * calendar system specific parameters of the instance.\n     *\n     * @param field the calendar field.\n     * @return the minimum value for the given calendar field.\n     * @see #getMaximum(int)\n     * @see #getGreatestMinimum(int)\n     * @see #getLeastMaximum(int)\n     * @see #getActualMinimum(int)\n     * @see #getActualMaximum(int)\n     */\n    public abstract int getMinimum(int field);\n\n    /**\n     * Returns the maximum value for the given calendar field of this\n     * \u003ccode\u003eCalendar\u003c/code\u003e instance. The maximum value is defined as\n     * the largest value returned by the {@link #get(int) get} method\n     * for any possible time value. The maximum value depends on\n     * calendar system specific parameters of the instance.\n     *\n     * @param field the calendar field.\n     * @return the maximum value for the given calendar field.\n     * @see #getMinimum(int)\n     * @see #getGreatestMinimum(int)\n     * @see #getLeastMaximum(int)\n     * @see #getActualMinimum(int)\n     * @see #getActualMaximum(int)\n     */\n    public abstract int getMaximum(int field);\n\n    /**\n     * Returns the highest minimum value for the given calendar field\n     * of this \u003ccode\u003eCalendar\u003c/code\u003e instance. The highest minimum\n     * value is defined as the largest value returned by {@link\n     * #getActualMinimum(int)} for any possible time value. The\n     * greatest minimum value depends on calendar system specific\n     * parameters of the instance.\n     *\n     * @param field the calendar field.\n     * @return the highest minimum value for the given calendar field.\n     * @see #getMinimum(int)\n     * @see #getMaximum(int)\n     * @see #getLeastMaximum(int)\n     * @see #getActualMinimum(int)\n     * @see #getActualMaximum(int)\n     */\n    public abstract int getGreatestMinimum(int field);\n\n    /**\n     * Returns the lowest maximum value for the given calendar field\n     * of this \u003ccode\u003eCalendar\u003c/code\u003e instance. The lowest maximum\n     * value is defined as the smallest value returned by {@link\n     * #getActualMaximum(int)} for any possible time value. The least\n     * maximum value depends on calendar system specific parameters of\n     * the instance. For example, a \u003ccode\u003eCalendar\u003c/code\u003e for the\n     * Gregorian calendar system returns 28 for the\n     * \u003ccode\u003eDAY_OF_MONTH\u003c/code\u003e field, because the 28th is the last\n     * day of the shortest month of this calendar, February in a\n     * common year.\n     *\n     * @param field the calendar field.\n     * @return the lowest maximum value for the given calendar field.\n     * @see #getMinimum(int)\n     * @see #getMaximum(int)\n     * @see #getGreatestMinimum(int)\n     * @see #getActualMinimum(int)\n     * @see #getActualMaximum(int)\n     */\n    public abstract int getLeastMaximum(int field);\n\n    /**\n     * Returns the minimum value that the specified calendar field\n     * could have, given the time value of this \u003ccode\u003eCalendar\u003c/code\u003e.\n     *\n     * \u003cp\u003eThe default implementation of this method uses an iterative\n     * algorithm to determine the actual minimum value for the\n     * calendar field. Subclasses should, if possible, override this\n     * with a more efficient implementation - in many cases, they can\n     * simply return \u003ccode\u003egetMinimum()\u003c/code\u003e.\n     *\n     * @param field the calendar field\n     * @return the minimum of the given calendar field for the time\n     * value of this \u003ccode\u003eCalendar\u003c/code\u003e\n     * @see #getMinimum(int)\n     * @see #getMaximum(int)\n     * @see #getGreatestMinimum(int)\n     * @see #getLeastMaximum(int)\n     * @see #getActualMaximum(int)\n     * @since 1.2\n     */\n    public int getActualMinimum(int field) {\n        int fieldValue \u003d getGreatestMinimum(field);\n        int endValue \u003d getMinimum(field);\n\n        // if we know that the minimum value is always the same, just return it\n        if (fieldValue \u003d\u003d endValue) {\n            return fieldValue;\n        }\n\n        // clone the calendar so we don\u0027t mess with the real one, and set it to\n        // accept anything for the field values\n        Calendar work \u003d (Calendar)this.clone();\n        work.setLenient(true);\n\n        // now try each value from getLeastMaximum() to getMaximum() one by one until\n        // we get a value that normalizes to another value.  The last value that\n        // normalizes to itself is the actual minimum for the current date\n        int result \u003d fieldValue;\n\n        do {\n            work.set(field, fieldValue);\n            if (work.get(field) !\u003d fieldValue) {\n                break;\n            } else {\n                result \u003d fieldValue;\n                fieldValue--;\n            }\n        } while (fieldValue \u003e\u003d endValue);\n\n        return result;\n    }\n\n    /**\n     * Returns the maximum value that the specified calendar field\n     * could have, given the time value of this\n     * \u003ccode\u003eCalendar\u003c/code\u003e. For example, the actual maximum value of\n     * the \u003ccode\u003eMONTH\u003c/code\u003e field is 12 in some years, and 13 in\n     * other years in the Hebrew calendar system.\n     *\n     * \u003cp\u003eThe default implementation of this method uses an iterative\n     * algorithm to determine the actual maximum value for the\n     * calendar field. Subclasses should, if possible, override this\n     * with a more efficient implementation.\n     *\n     * @param field the calendar field\n     * @return the maximum of the given calendar field for the time\n     * value of this \u003ccode\u003eCalendar\u003c/code\u003e\n     * @see #getMinimum(int)\n     * @see #getMaximum(int)\n     * @see #getGreatestMinimum(int)\n     * @see #getLeastMaximum(int)\n     * @see #getActualMinimum(int)\n     * @since 1.2\n     */\n    public int getActualMaximum(int field) {\n        int fieldValue \u003d getLeastMaximum(field);\n        int endValue \u003d getMaximum(field);\n\n        // if we know that the maximum value is always the same, just return it.\n        if (fieldValue \u003d\u003d endValue) {\n            return fieldValue;\n        }\n\n        // clone the calendar so we don\u0027t mess with the real one, and set it to\n        // accept anything for the field values.\n        Calendar work \u003d (Calendar)this.clone();\n        work.setLenient(true);\n\n        // if we\u0027re counting weeks, set the day of the week to Sunday.  We know the\n        // last week of a month or year will contain the first day of the week.\n        if (field \u003d\u003d WEEK_OF_YEAR || field \u003d\u003d WEEK_OF_MONTH) {\n            work.set(DAY_OF_WEEK, firstDayOfWeek);\n        }\n\n        // now try each value from getLeastMaximum() to getMaximum() one by one until\n        // we get a value that normalizes to another value.  The last value that\n        // normalizes to itself is the actual maximum for the current date\n        int result \u003d fieldValue;\n\n        do {\n            work.set(field, fieldValue);\n            if (work.get(field) !\u003d fieldValue) {\n                break;\n            } else {\n                result \u003d fieldValue;\n                fieldValue++;\n            }\n        } while (fieldValue \u003c\u003d endValue);\n\n        return result;\n    }\n\n    /**\n     * Creates and returns a copy of this object.\n     *\n     * @return a copy of this object.\n     */\n    @Override\n    public Object clone()\n    {\n        try {\n            Calendar other \u003d (Calendar) super.clone();\n\n            other.fields \u003d new int[FIELD_COUNT];\n            other.isSet \u003d new boolean[FIELD_COUNT];\n            other.stamp \u003d new int[FIELD_COUNT];\n            for (int i \u003d 0; i \u003c FIELD_COUNT; i++) {\n                other.fields[i] \u003d fields[i];\n                other.stamp[i] \u003d stamp[i];\n                other.isSet[i] \u003d isSet[i];\n            }\n            other.zone \u003d (TimeZone) zone.clone();\n            return other;\n        }\n        catch (CloneNotSupportedException e) {\n            // this shouldn\u0027t happen, since we are Cloneable\n            throw new InternalError(e);\n        }\n    }\n\n    private static final String[] FIELD_NAME \u003d {\n        \"ERA\", \"YEAR\", \"MONTH\", \"WEEK_OF_YEAR\", \"WEEK_OF_MONTH\", \"DAY_OF_MONTH\",\n        \"DAY_OF_YEAR\", \"DAY_OF_WEEK\", \"DAY_OF_WEEK_IN_MONTH\", \"AM_PM\", \"HOUR\",\n        \"HOUR_OF_DAY\", \"MINUTE\", \"SECOND\", \"MILLISECOND\", \"ZONE_OFFSET\",\n        \"DST_OFFSET\"\n    };\n\n    /**\n     * Returns the name of the specified calendar field.\n     *\n     * @param field the calendar field\n     * @return the calendar field name\n     * @exception IndexOutOfBoundsException if \u003ccode\u003efield\u003c/code\u003e is negative,\n     * equal to or greater than {@code FIELD_COUNT}.\n     */\n    static String getFieldName(int field) {\n        return FIELD_NAME[field];\n    }\n\n    /**\n     * Return a string representation of this calendar. This method\n     * is intended to be used only for debugging purposes, and the\n     * format of the returned string may vary between implementations.\n     * The returned string may be empty but may not be \u003ccode\u003enull\u003c/code\u003e.\n     *\n     * @return  a string representation of this calendar.\n     */\n    @Override\n    public String toString() {\n        // NOTE: BuddhistCalendar.toString() interprets the string\n        // produced by this method so that the Gregorian year number\n        // is substituted by its B.E. year value. It relies on\n        // \"...,YEAR\u003d\u003cyear\u003e,...\" or \"...,YEAR\u003d?,...\".\n        StringBuilder buffer \u003d new StringBuilder(800);\n        buffer.append(getClass().getName()).append(\u0027[\u0027);\n        appendValue(buffer, \"time\", isTimeSet, time);\n        buffer.append(\",areFieldsSet\u003d\").append(areFieldsSet);\n        buffer.append(\",areAllFieldsSet\u003d\").append(areAllFieldsSet);\n        buffer.append(\",lenient\u003d\").append(lenient);\n        buffer.append(\",zone\u003d\").append(zone);\n        appendValue(buffer, \",firstDayOfWeek\", true, (long) firstDayOfWeek);\n        appendValue(buffer, \",minimalDaysInFirstWeek\", true, (long) minimalDaysInFirstWeek);\n        for (int i \u003d 0; i \u003c FIELD_COUNT; ++i) {\n            buffer.append(\u0027,\u0027);\n            appendValue(buffer, FIELD_NAME[i], isSet(i), (long) fields[i]);\n        }\n        buffer.append(\u0027]\u0027);\n        return buffer.toString();\n    }\n\n    // \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003dprivates\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n    private static void appendValue(StringBuilder sb, String item, boolean valid, long value) {\n        sb.append(item).append(\u0027\u003d\u0027);\n        if (valid) {\n            sb.append(value);\n        } else {\n            sb.append(\u0027?\u0027);\n        }\n    }\n\n    /**\n     * Both firstDayOfWeek and minimalDaysInFirstWeek are locale-dependent.\n     * They are used to figure out the week count for a specific date for\n     * a given locale. These must be set when a Calendar is constructed.\n     * @param desiredLocale the given locale.\n     */\n    private void setWeekCountData(Locale desiredLocale)\n    {\n        /* try to get the Locale data from the cache */\n        int[] data \u003d cachedLocaleData.get(desiredLocale);\n        if (data \u003d\u003d null) {  /* cache miss */\n            data \u003d new int[2];\n            data[0] \u003d CalendarDataUtility.retrieveFirstDayOfWeek(desiredLocale);\n            data[1] \u003d CalendarDataUtility.retrieveMinimalDaysInFirstWeek(desiredLocale);\n            cachedLocaleData.putIfAbsent(desiredLocale, data);\n        }\n        firstDayOfWeek \u003d data[0];\n        minimalDaysInFirstWeek \u003d data[1];\n    }\n\n    /**\n     * Recomputes the time and updates the status fields isTimeSet\n     * and areFieldsSet.  Callers should check isTimeSet and only\n     * call this method if isTimeSet is false.\n     */\n    private void updateTime() {\n        computeTime();\n        // The areFieldsSet and areAllFieldsSet values are no longer\n        // controlled here (as of 1.5).\n        isTimeSet \u003d true;\n    }\n\n    private int compareTo(long t) {\n        long thisTime \u003d getMillisOf(this);\n        return (thisTime \u003e t) ? 1 : (thisTime \u003d\u003d t) ? 0 : -1;\n    }\n\n    private static long getMillisOf(Calendar calendar) {\n        if (calendar.isTimeSet) {\n            return calendar.time;\n        }\n        Calendar cal \u003d (Calendar) calendar.clone();\n        cal.setLenient(true);\n        return cal.getTimeInMillis();\n    }\n\n    /**\n     * Adjusts the stamp[] values before nextStamp overflow. nextStamp\n     * is set to the next stamp value upon the return.\n     */\n    private void adjustStamp() {\n        int max \u003d MINIMUM_USER_STAMP;\n        int newStamp \u003d MINIMUM_USER_STAMP;\n\n        for (;;) {\n            int min \u003d Integer.MAX_VALUE;\n            for (int v : stamp) {\n                if (v \u003e\u003d newStamp \u0026\u0026 min \u003e v) {\n                    min \u003d v;\n                }\n                if (max \u003c v) {\n                    max \u003d v;\n                }\n            }\n            if (max !\u003d min \u0026\u0026 min \u003d\u003d Integer.MAX_VALUE) {\n                break;\n            }\n            for (int i \u003d 0; i \u003c stamp.length; i++) {\n                if (stamp[i] \u003d\u003d min) {\n                    stamp[i] \u003d newStamp;\n                }\n            }\n            newStamp++;\n            if (min \u003d\u003d max) {\n                break;\n            }\n        }\n        nextStamp \u003d newStamp;\n    }\n\n    /**\n     * Sets the WEEK_OF_MONTH and WEEK_OF_YEAR fields to new values with the\n     * new parameter value if they have been calculated internally.\n     */\n    private void invalidateWeekFields()\n    {\n        if (stamp[WEEK_OF_MONTH] !\u003d COMPUTED \u0026\u0026\n            stamp[WEEK_OF_YEAR] !\u003d COMPUTED) {\n            return;\n        }\n\n        // We have to check the new values of these fields after changing\n        // firstDayOfWeek and/or minimalDaysInFirstWeek. If the field values\n        // have been changed, then set the new values. (4822110)\n        Calendar cal \u003d (Calendar) clone();\n        cal.setLenient(true);\n        cal.clear(WEEK_OF_MONTH);\n        cal.clear(WEEK_OF_YEAR);\n\n        if (stamp[WEEK_OF_MONTH] \u003d\u003d COMPUTED) {\n            int weekOfMonth \u003d cal.get(WEEK_OF_MONTH);\n            if (fields[WEEK_OF_MONTH] !\u003d weekOfMonth) {\n                fields[WEEK_OF_MONTH] \u003d weekOfMonth;\n            }\n        }\n\n        if (stamp[WEEK_OF_YEAR] \u003d\u003d COMPUTED) {\n            int weekOfYear \u003d cal.get(WEEK_OF_YEAR);\n            if (fields[WEEK_OF_YEAR] !\u003d weekOfYear) {\n                fields[WEEK_OF_YEAR] \u003d weekOfYear;\n            }\n        }\n    }\n\n    /**\n     * Save the state of this object to a stream (i.e., serialize it).\n     *\n     * Ideally, \u003ccode\u003eCalendar\u003c/code\u003e would only write out its state data and\n     * the current time, and not write any field data out, such as\n     * \u003ccode\u003efields[]\u003c/code\u003e, \u003ccode\u003eisTimeSet\u003c/code\u003e, \u003ccode\u003eareFieldsSet\u003c/code\u003e,\n     * and \u003ccode\u003eisSet[]\u003c/code\u003e.  \u003ccode\u003enextStamp\u003c/code\u003e also should not be part\n     * of the persistent state. Unfortunately, this didn\u0027t happen before JDK 1.1\n     * shipped. To be compatible with JDK 1.1, we will always have to write out\n     * the field values and state flags.  However, \u003ccode\u003enextStamp\u003c/code\u003e can be\n     * removed from the serialization stream; this will probably happen in the\n     * near future.\n     */\n    private synchronized void writeObject(ObjectOutputStream stream)\n         throws IOException\n    {\n        // Try to compute the time correctly, for the future (stream\n        // version 2) in which we don\u0027t write out fields[] or isSet[].\n        if (!isTimeSet) {\n            try {\n                updateTime();\n            }\n            catch (IllegalArgumentException e) {}\n        }\n\n        // If this Calendar has a ZoneInfo, save it and set a\n        // SimpleTimeZone equivalent (as a single DST schedule) for\n        // backward compatibility.\n        TimeZone savedZone \u003d null;\n        if (zone instanceof ZoneInfo) {\n            SimpleTimeZone stz \u003d ((ZoneInfo)zone).getLastRuleInstance();\n            if (stz \u003d\u003d null) {\n                stz \u003d new SimpleTimeZone(zone.getRawOffset(), zone.getID());\n            }\n            savedZone \u003d zone;\n            zone \u003d stz;\n        }\n\n        // Write out the 1.1 FCS object.\n        stream.defaultWriteObject();\n\n        // Write out the ZoneInfo object\n        // 4802409: we write out even if it is null, a temporary workaround\n        // the real fix for bug 4844924 in corba-iiop\n        stream.writeObject(savedZone);\n        if (savedZone !\u003d null) {\n            zone \u003d savedZone;\n        }\n    }\n\n    private static class CalendarAccessControlContext {\n        private static final AccessControlContext INSTANCE;\n        static {\n            RuntimePermission perm \u003d new RuntimePermission(\"accessClassInPackage.sun.util.calendar\");\n            PermissionCollection perms \u003d perm.newPermissionCollection();\n            perms.add(perm);\n            INSTANCE \u003d new AccessControlContext(new ProtectionDomain[] {\n                                                    new ProtectionDomain(null, perms)\n                                                });\n        }\n        private CalendarAccessControlContext() {\n        }\n    }\n\n    /**\n     * Reconstitutes this object from a stream (i.e., deserialize it).\n     */\n    private void readObject(ObjectInputStream stream)\n         throws IOException, ClassNotFoundException\n    {\n        final ObjectInputStream input \u003d stream;\n        input.defaultReadObject();\n\n        stamp \u003d new int[FIELD_COUNT];\n\n        // Starting with version 2 (not implemented yet), we expect that\n        // fields[], isSet[], isTimeSet, and areFieldsSet may not be\n        // streamed out anymore.  We expect \u0027time\u0027 to be correct.\n        if (serialVersionOnStream \u003e\u003d 2)\n        {\n            isTimeSet \u003d true;\n            if (fields \u003d\u003d null) {\n                fields \u003d new int[FIELD_COUNT];\n            }\n            if (isSet \u003d\u003d null) {\n                isSet \u003d new boolean[FIELD_COUNT];\n            }\n        }\n        else if (serialVersionOnStream \u003e\u003d 0)\n        {\n            for (int i\u003d0; i\u003cFIELD_COUNT; ++i) {\n                stamp[i] \u003d isSet[i] ? COMPUTED : UNSET;\n            }\n        }\n\n        serialVersionOnStream \u003d currentSerialVersion;\n\n        // If there\u0027s a ZoneInfo object, use it for zone.\n        ZoneInfo zi \u003d null;\n        try {\n            zi \u003d AccessController.doPrivileged(\n                    new PrivilegedExceptionAction\u003c\u003e() {\n                        @Override\n                        public ZoneInfo run() throws Exception {\n                            return (ZoneInfo) input.readObject();\n                        }\n                    },\n                    CalendarAccessControlContext.INSTANCE);\n        } catch (PrivilegedActionException pae) {\n            Exception e \u003d pae.getException();\n            if (!(e instanceof OptionalDataException)) {\n                if (e instanceof RuntimeException) {\n                    throw (RuntimeException) e;\n                } else if (e instanceof IOException) {\n                    throw (IOException) e;\n                } else if (e instanceof ClassNotFoundException) {\n                    throw (ClassNotFoundException) e;\n                }\n                throw new RuntimeException(e);\n            }\n        }\n        if (zi !\u003d null) {\n            zone \u003d zi;\n        }\n\n        // If the deserialized object has a SimpleTimeZone, try to\n        // replace it with a ZoneInfo equivalent (as of 1.4) in order\n        // to be compatible with the SimpleTimeZone-based\n        // implementation as much as possible.\n        if (zone instanceof SimpleTimeZone) {\n            String id \u003d zone.getID();\n            TimeZone tz \u003d TimeZone.getTimeZone(id);\n            if (tz !\u003d null \u0026\u0026 tz.hasSameRules(zone) \u0026\u0026 tz.getID().equals(id)) {\n                zone \u003d tz;\n            }\n        }\n    }\n\n    /**\n     * Converts this object to an {@link Instant}.\n     * \u003cp\u003e\n     * The conversion creates an {@code Instant} that represents the\n     * same point on the time-line as this {@code Calendar}.\n     *\n     * @return the instant representing the same point on the time-line\n     * @since 1.8\n     */\n    public final Instant toInstant() {\n        return Instant.ofEpochMilli(getTimeInMillis());\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/util/Calendar.java
	at java.base/java.net.URI.create(URI.java:883)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:137)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:135)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:617)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:614)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:1040)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/util/Calendar.java
	at java.base/java.net.URI$Parser.fail(URI.java:2913)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3084)
	at java.base/java.net.URI$Parser.parse(URI.java:3120)
	at java.base/java.net.URI.<init>(URI.java:600)
	at java.base/java.net.URI.create(URI.java:881)
	... 21 more

Jun 02, 2022 8:48:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-11.0.14/lib/src.zip%21/java.base/java/util/Calendar.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/util/Calendar.java
	at java.base/java.net.URI.create(URI.java:883)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:137)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:135)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:617)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:614)
	at scala.meta.internal.metals.MetalsLanguageServer.didClose(MetalsLanguageServer.scala:1209)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-11.0.14/lib/src.zip!/java.base/java/util/Calendar.java
	at java.base/java.net.URI$Parser.fail(URI.java:2913)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3084)
	at java.base/java.net.URI$Parser.parse(URI.java:3120)
	at java.base/java.net.URI.<init>(URI.java:600)
	at java.base/java.net.URI.create(URI.java:881)
	... 21 more

2022.06.02 20:48:13 INFO  compiling root (1 scala source)
2022.06.02 20:48:13 INFO  time: compiled root in 54ms
2022.06.02 20:50:13 INFO  compiling root (1 scala source)
2022.06.02 20:50:13 INFO  time: compiled root in 70ms
2022.06.02 20:50:39 INFO  compiling root (1 scala source)
2022.06.02 20:50:39 INFO  time: compiled root in 70ms
2022.06.02 20:50:46 INFO  compiling root (1 scala source)
2022.06.02 20:50:46 INFO  time: compiled root in 71ms
2022.06.02 20:51:00 INFO  compiling root (1 scala source)
2022.06.02 20:51:00 INFO  time: compiled root in 67ms
2022.06.02 20:51:11 INFO  compiling root (1 scala source)
2022.06.02 20:51:11 INFO  time: compiled root in 60ms
2022.06.02 20:51:16 INFO  compiling root (1 scala source)
2022.06.02 20:51:16 INFO  time: compiled root in 0.15s
2022.06.02 20:51:57 INFO  compiling root (1 scala source)
2022.06.02 20:51:57 INFO  time: compiled root in 0.17s
2022.06.02 20:52:48 INFO  compiling root (1 scala source)
2022.06.02 20:52:48 INFO  time: compiled root in 0.28s
2022.06.02 20:53:35 INFO  compiling root (1 scala source)
2022.06.02 20:53:35 INFO  time: compiled root in 0.15s
2022.06.02 20:53:40 INFO  compiling root (1 scala source)
2022.06.02 20:53:40 INFO  time: compiled root in 0.14s
2022.06.02 20:55:59 INFO  compiling root (1 scala source)
2022.06.02 20:55:59 INFO  time: compiled root in 0.16s
2022.06.02 20:56:36 INFO  compiling root (1 scala source)
2022.06.02 20:56:36 INFO  time: compiled root in 0.15s
2022.06.02 20:56:45 INFO  compiling root (1 scala source)
2022.06.02 20:56:45 INFO  time: compiled root in 0.15s
2022.06.02 20:57:01 INFO  compiling root (1 scala source)
2022.06.02 20:57:01 INFO  time: compiled root in 0.15s
2022.06.02 20:57:17 INFO  compiling root (1 scala source)
2022.06.02 20:57:17 INFO  time: compiled root in 0.14s
2022.06.02 20:57:46 INFO  compiling root (1 scala source)
2022.06.02 20:57:46 INFO  time: compiled root in 0.14s
2022.06.02 20:57:54 INFO  compiling root (1 scala source)
2022.06.02 20:57:54 INFO  time: compiled root in 0.15s
2022.06.02 20:58:12 INFO  compiling root (1 scala source)
2022.06.02 20:58:12 INFO  time: compiled root in 0.2s
2022.06.02 20:58:14 INFO  compiling root (1 scala source)
2022.06.02 20:58:14 INFO  time: compiled root in 0.14s
2022.06.02 20:59:16 INFO  compiling root (1 scala source)
2022.06.02 20:59:16 INFO  time: compiled root in 0.14s
2022.06.02 21:00:08 INFO  compiling root (1 scala source)
2022.06.02 21:00:08 INFO  time: compiled root in 0.14s
2022.06.02 21:00:37 INFO  compiling root (1 scala source)
2022.06.02 21:00:37 INFO  time: compiled root in 0.15s
2022.06.02 21:02:11 INFO  compiling root (1 scala source)
2022.06.02 21:02:11 INFO  time: compiled root in 0.14s
2022.06.02 21:02:13 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:35 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:41 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:42 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:47 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:50 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:51 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:52 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:53 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:55 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:56 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:56 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:58 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:02:58 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:00 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:00 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:01 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:02 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:05 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:06 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:07 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:161:8: stale bloop error: Found:    Unit
Required: Int
      })
       ^
2022.06.02 21:03:07 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:161:8: stale bloop error: Found:    Unit
Required: Int
      })
       ^
2022.06.02 21:03:07 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:161:8: stale bloop error: Found:    Unit
Required: Int
      })
       ^
2022.06.02 21:03:08 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:161:8: stale bloop error: Found:    Unit
Required: Int
      })
       ^
2022.06.02 21:03:08 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:08 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:09 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:10 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:12 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:13 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:14 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:14 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:15 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:15 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:16 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:18 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:19 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:20 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:21 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:21 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:22 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:22 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:24 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:25 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:30 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:31 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:03:31 INFO  compiling root (1 scala source)
2022.06.02 21:03:31 INFO  time: compiled root in 0.15s
2022.06.02 21:03:34 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:12 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:12 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:14 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:14 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:16 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:18 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:19 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:20 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:21 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:22 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:22 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:24 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:24 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:24 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:24 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:25 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:28 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:28 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:30 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:31 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:32 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:32 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:33 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:34 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:35 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:35 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:36 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:37 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:38 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:39 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:40 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:41 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:42 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:42 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:45 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:45 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:46 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:46 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:47 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:50 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:50 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:51 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:52 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:55 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:55 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:57 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:04:58 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:00 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:00 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:01 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:02 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:02 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:05 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:06 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:06 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:06 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:06 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:07 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:18 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:19 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:19 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:19 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:20 INFO  compiling root (1 scala source)
2022.06.02 21:05:20 INFO  time: compiled root in 0.16s
2022.06.02 21:05:21 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:21 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:21 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:22 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:29 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:30 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:31 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:33 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:34 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:34 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:35 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:35 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:35 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:36 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:37 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:37 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:37 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:38 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:38 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:38 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:38 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:38 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:38 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:38 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:38 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:40 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:41 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:41 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:41 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:42 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:46 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:47 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:48 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:48 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:48 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:48 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:48 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:51 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:52 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:54 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:54 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:55 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:56 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:57 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:57 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:57 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:56 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:57 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:59 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:05:59 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:01 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:02 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:02 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:06 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:07 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:08 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:07 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:08 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:09 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:08 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:10 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:11 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:12 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:13 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:14 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:14 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:16 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:18 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:19 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:21 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:23 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:23 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:24 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:28 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:28 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:29 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:30 INFO  compiling root (1 scala source)
2022.06.02 21:06:30 INFO  time: compiled root in 0.17s
2022.06.02 21:06:32 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:35 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:47 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:49 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:177:8: stale bloop error: Found:    Unit
Required: Int
      })
       ^
2022.06.02 21:06:49 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:177:8: stale bloop error: Found:    Unit
Required: Int
      })
       ^
2022.06.02 21:06:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:50 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:50 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:53 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:54 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:56 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:06:57 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:00 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:04 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:04 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:05 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:37 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:38 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:40 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:46 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:50 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:51 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:52 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:53 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:54 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:57 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:07:58 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:00 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:05 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:05 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:06 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:10 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:10 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:11 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:13 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:14 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:15 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:15 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:19 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:20 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:20 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:22 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:08:22 INFO  compiling root (1 scala source)
2022.06.02 21:08:22 INFO  time: compiled root in 0.16s
2022.06.02 21:10:05 INFO  compiling root (1 scala source)
2022.06.02 21:10:05 INFO  time: compiled root in 0.15s
2022.06.02 21:10:16 INFO  compiling root (1 scala source)
2022.06.02 21:10:16 INFO  time: compiled root in 0.14s
2022.06.02 21:10:37 INFO  compiling root (1 scala source)
2022.06.02 21:10:37 INFO  time: compiled root in 0.15s
2022.06.02 21:12:25 INFO  compiling root (1 scala source)
2022.06.02 21:12:25 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:12:25 INFO  time: compiled root in 0.15s
2022.06.02 21:12:59 INFO  compiling root (1 scala source)
2022.06.02 21:12:59 INFO  time: compiled root in 73ms
2022.06.02 21:13:31 INFO  compiling root (1 scala source)
2022.06.02 21:13:31 INFO  time: compiled root in 0.14s
2022.06.02 21:13:52 INFO  compiling root (1 scala source)
2022.06.02 21:13:52 INFO  time: compiled root in 63ms
2022.06.02 21:13:54 INFO  compiling root (1 scala source)
2022.06.02 21:13:54 INFO  time: compiled root in 0.15s
2022.06.02 21:14:20 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:14:20 INFO  compiling root (1 scala source)
2022.06.02 21:14:20 INFO  time: compiled root in 0.15s
2022.06.02 21:14:47 INFO  compiling root (1 scala source)
2022.06.02 21:14:47 INFO  time: compiled root in 0.15s
2022.06.02 21:15:22 INFO  compiling root (1 scala source)
2022.06.02 21:15:22 INFO  time: compiled root in 0.14s
2022.06.02 21:15:56 INFO  compiling root (1 scala source)
2022.06.02 21:15:56 INFO  time: compiled root in 0.15s
2022.06.02 21:16:07 INFO  compiling root (1 scala source)
2022.06.02 21:16:07 INFO  time: compiled root in 0.15s
2022.06.02 21:16:44 INFO  compiling root (1 scala source)
2022.06.02 21:16:44 INFO  time: compiled root in 0.14s
2022.06.02 21:16:57 INFO  compiling root (1 scala source)
2022.06.02 21:16:57 INFO  time: compiled root in 0.15s
2022.06.02 21:18:22 INFO  compiling root (1 scala source)
2022.06.02 21:18:22 INFO  time: compiled root in 70ms
2022.06.02 21:18:55 INFO  compiling root (1 scala source)
2022.06.02 21:18:55 INFO  time: compiled root in 0.2s
2022.06.02 21:19:13 INFO  compiling root (1 scala source)
2022.06.02 21:19:13 INFO  time: compiled root in 0.23s
2022.06.02 21:19:20 INFO  compiling root (1 scala source)
2022.06.02 21:19:20 INFO  time: compiled root in 0.21s
2022.06.02 21:19:50 INFO  compiling root (1 scala source)
2022.06.02 21:19:50 INFO  time: compiled root in 0.19s
2022.06.02 21:20:01 INFO  compiling root (1 scala source)
2022.06.02 21:20:01 INFO  time: compiled root in 0.16s
2022.06.02 21:20:22 INFO  compiling root (1 scala source)
2022.06.02 21:20:22 INFO  time: compiled root in 0.15s
2022.06.02 21:20:36 INFO  compiling root (1 scala source)
2022.06.02 21:20:36 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:20:36 INFO  time: compiled root in 0.15s
2022.06.02 21:20:44 INFO  compiling root (1 scala source)
2022.06.02 21:20:44 INFO  time: compiled root in 0.15s
2022.06.02 21:21:27 INFO  compiling root (1 scala source)
2022.06.02 21:21:27 INFO  time: compiled root in 0.15s
2022.06.02 21:21:34 INFO  compiling root (1 scala source)
2022.06.02 21:21:34 INFO  time: compiled root in 0.15s
2022.06.02 21:22:33 INFO  compiling root (1 scala source)
2022.06.02 21:22:33 INFO  time: compiled root in 0.14s
2022.06.02 21:24:20 INFO  compiling root (1 scala source)
2022.06.02 21:24:20 INFO  time: compiled root in 0.14s
2022.06.02 21:25:08 INFO  compiling root (1 scala source)
2022.06.02 21:25:08 INFO  time: compiled root in 0.14s
2022.06.02 21:25:45 INFO  compiling root (1 scala source)
2022.06.02 21:25:45 INFO  time: compiled root in 0.14s
2022.06.02 21:26:06 INFO  compiling root (1 scala source)
2022.06.02 21:26:06 INFO  time: compiled root in 0.15s
2022.06.02 21:26:39 INFO  compiling root (1 scala source)
2022.06.02 21:26:39 INFO  time: compiled root in 0.14s
2022.06.02 21:27:59 INFO  compiling root (1 scala source)
2022.06.02 21:27:59 INFO  time: compiled root in 0.16s
2022.06.02 21:28:04 INFO  compiling root (1 scala source)
2022.06.02 21:28:04 INFO  time: compiled root in 0.15s
2022.06.02 21:28:07 INFO  compiling root (1 scala source)
2022.06.02 21:28:07 INFO  time: compiled root in 0.15s
2022.06.02 21:29:41 INFO  compiling root (1 scala source)
2022.06.02 21:29:41 INFO  time: compiled root in 0.15s
2022.06.02 21:29:55 INFO  compiling root (1 scala source)
2022.06.02 21:29:55 INFO  time: compiled root in 0.14s
2022.06.02 21:30:03 INFO  compiling root (1 scala source)
2022.06.02 21:30:03 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.02 21:30:03 INFO  time: compiled root in 0.14s
2022.06.02 21:30:12 INFO  compiling root (1 scala source)
2022.06.02 21:30:12 INFO  time: compiled root in 0.14s
2022.06.02 21:30:48 INFO  compiling root (1 scala source)
2022.06.02 21:30:48 INFO  time: compiled root in 0.14s
2022.06.02 21:31:00 INFO  compiling root (1 scala source)
2022.06.02 21:31:00 INFO  time: compiled root in 0.14s
2022.06.02 21:31:23 INFO  compiling root (1 scala source)
2022.06.02 21:31:23 INFO  time: compiled root in 0.14s
2022.06.02 21:31:26 INFO  compiling root (1 scala source)
2022.06.02 21:31:26 INFO  time: compiled root in 0.15s
2022.06.02 21:32:02 INFO  compiling root (1 scala source)
2022.06.02 21:32:02 INFO  time: compiled root in 0.14s
2022.06.02 21:32:12 INFO  compiling root (1 scala source)
2022.06.02 21:32:12 INFO  time: compiled root in 0.14s
2022.06.02 21:33:55 INFO  compiling root (1 scala source)
2022.06.02 21:33:55 INFO  time: compiled root in 71ms
2022.06.02 21:34:07 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:147:7: stale bloop error: 'then' expected, but '.' found
      .tail
      ^
2022.06.02 21:34:07 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:188:3: stale bloop error: expression expected but eof found
  
  ^
2022.06.02 21:34:07 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:144:8: stale bloop error: postfix operator `args` needs to be enabled
by making the implicit value scala.language.postfixOps visible.
----
This can be achieved by adding the import clause 'import scala.language.postfixOps'
or by setting the compiler option -language:postfixOps.
See the Scaladoc for value scala.language.postfixOps for a discussion
why the feature needs to be explicitly enabled.
    if argc > 2
       ^^^^^^^^
2022.06.02 21:34:07 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:147:7: stale bloop error: 'then' expected, but '.' found
      .tail
      ^
2022.06.02 21:34:07 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:188:3: stale bloop error: expression expected but eof found
  
  ^
2022.06.02 21:34:07 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:144:8: stale bloop error: postfix operator `args` needs to be enabled
by making the implicit value scala.language.postfixOps visible.
----
This can be achieved by adding the import clause 'import scala.language.postfixOps'
or by setting the compiler option -language:postfixOps.
See the Scaladoc for value scala.language.postfixOps for a discussion
why the feature needs to be explicitly enabled.
    if argc > 2
       ^^^^^^^^
2022.06.02 21:35:40 INFO  compiling root (1 scala source)
2022.06.02 21:35:40 INFO  time: compiled root in 62ms
2022.06.02 21:35:47 INFO  compiling root (1 scala source)
2022.06.02 21:35:47 INFO  time: compiled root in 63ms
2022.06.02 21:35:52 INFO  compiling root (1 scala source)
2022.06.02 21:35:52 INFO  time: compiled root in 60ms
2022.06.02 21:36:12 INFO  compiling root (1 scala source)
2022.06.02 21:36:12 INFO  time: compiled root in 0.14s
2022.06.02 21:36:27 INFO  compiling root (1 scala source)
2022.06.02 21:36:27 INFO  time: compiled root in 0.15s
2022.06.02 21:36:55 INFO  compiling root (1 scala source)
2022.06.02 21:36:55 INFO  time: compiled root in 0.14s
2022.06.02 21:37:10 INFO  compiling root (1 scala source)
2022.06.02 21:37:10 INFO  time: compiled root in 0.14s
2022.06.02 21:37:29 INFO  compiling root (1 scala source)
2022.06.02 21:37:29 INFO  time: compiled root in 0.14s
2022.06.02 21:37:48 INFO  compiling root (1 scala source)
2022.06.02 21:37:48 INFO  time: compiled root in 0.15s
Jun 02, 2022 9:38:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21225
2022.06.02 21:38:35 INFO  compiling root (1 scala source)
2022.06.02 21:38:35 INFO  time: compiled root in 77ms
2022.06.02 21:38:49 INFO  compiling root (1 scala source)
2022.06.02 21:38:49 INFO  time: compiled root in 65ms
2022.06.02 21:39:30 INFO  compiling root (1 scala source)
2022.06.02 21:39:30 INFO  time: compiled root in 65ms
2022.06.02 21:39:49 INFO  compiling root (1 scala source)
2022.06.02 21:39:49 INFO  time: compiled root in 0.14s
2022.06.02 21:40:09 INFO  compiling root (1 scala source)
2022.06.02 21:40:09 INFO  time: compiled root in 69ms
2022.06.02 21:42:27 INFO  compiling root (1 scala source)
2022.06.02 21:42:27 INFO  time: compiled root in 72ms
2022.06.02 21:42:36 INFO  compiling root (1 scala source)
2022.06.02 21:42:36 INFO  time: compiled root in 61ms
2022.06.02 21:43:00 INFO  compiling root (1 scala source)
2022.06.02 21:43:00 INFO  time: compiled root in 61ms
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:38: stale bloop error: expression expected but override found
  val pattern(startMonth, endMonth) = 
                                     ^
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:7: stale bloop error: Ambiguous overload. The overloaded alternatives of method unapplySeq in class Regex with types
 (m: scala.util.matching.Regex.Match): Option[List[String]]
 (s: CharSequence): Option[List[String]]
both match arguments (Null)
  val pattern(startMonth, endMonth) = 
      ^^^^^^^
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:3: stale bloop error: Recursive value $2$ needs type
  val pattern(startMonth, endMonth) = 
  ^
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:38: stale bloop error: expression expected but override found
  val pattern(startMonth, endMonth) = 
                                     ^
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:7: stale bloop error: Ambiguous overload. The overloaded alternatives of method unapplySeq in class Regex with types
 (m: scala.util.matching.Regex.Match): Option[List[String]]
 (s: CharSequence): Option[List[String]]
both match arguments (Null)
  val pattern(startMonth, endMonth) = 
      ^^^^^^^
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:3: stale bloop error: Recursive value $2$ needs type
  val pattern(startMonth, endMonth) = 
  ^
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:38: stale bloop error: expression expected but override found
  val pattern(startMonth, endMonth) = 
                                     ^
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:7: stale bloop error: Ambiguous overload. The overloaded alternatives of method unapplySeq in class Regex with types
 (m: scala.util.matching.Regex.Match): Option[List[String]]
 (s: CharSequence): Option[List[String]]
both match arguments (Null)
  val pattern(startMonth, endMonth) = 
      ^^^^^^^
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:3: stale bloop error: Recursive value $2$ needs type
  val pattern(startMonth, endMonth) = 
  ^
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:38: stale bloop error: expression expected but override found
  val pattern(startMonth, endMonth) = 
                                     ^
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:7: stale bloop error: Ambiguous overload. The overloaded alternatives of method unapplySeq in class Regex with types
 (m: scala.util.matching.Regex.Match): Option[List[String]]
 (s: CharSequence): Option[List[String]]
both match arguments (Null)
  val pattern(startMonth, endMonth) = 
      ^^^^^^^
2022.06.03 09:29:23 INFO  file:///C:/Users/DenisYamunaque/Documents/ADENTIS/adentis/src/main/scala/Main.scala:100:3: stale bloop error: Recursive value $2$ needs type
  val pattern(startMonth, endMonth) = 
  ^
2022.06.03 09:29:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.03 09:29:27 INFO  Connected to Build server: Bloop v1.5.0
2022.06.03 09:29:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\project\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.03 09:29:27 INFO  compiling root (1 scala source)
2022.06.03 09:29:28 INFO  time: indexed workspace in 1.59s
2022.06.03 09:29:28 INFO  compiling root (1 scala source)
2022.06.03 09:29:29 INFO  time: compiled root in 1.21s
Jun 03, 2022 9:30:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:37)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:32)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.lineLength$1(Position.scala:57)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:60)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionPositionLspInverse.toMeta(MtagsEnrichments.scala:179)
	at scala.meta.internal.parsing.Trees.$anonfun$findLastEnclosingAt$4(Trees.scala:76)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.Trees.findLastEnclosingAt(Trees.scala:75)
	at scala.meta.internal.metals.codeactions.PatternMatchRefactor.contribute(PatternMatchRefactor.scala:96)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:64)
	at scala.meta.internal.metals.CodeActionProvider$$anonfun$1.applyOrElse(CodeActionProvider.scala:63)
	at scala.collection.immutable.List.collect(List.scala:275)
	at scala.meta.internal.metals.CodeActionProvider.codeActions(CodeActionProvider.scala:63)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeAction$1(MetalsLanguageServer.scala:1639)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLanguageServer.codeAction(MetalsLanguageServer.scala:1638)
	... 15 more

2022.06.03 11:02:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.03 11:02:27 INFO  Connected to Build server: Bloop v1.5.0
2022.06.03 11:02:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\project\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.03 11:02:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\project\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.03 11:02:27 INFO  compiling root (1 scala source)
2022.06.03 11:02:27 INFO  time: Imported build in 0.11s
2022.06.03 11:02:29 INFO  time: indexed workspace in 1.62s
2022.06.03 11:02:29 INFO  compiling root (1 scala source)
2022.06.03 11:02:30 INFO  time: compiled root in 1.1s
2022.06.03 11:02:45 INFO  compiling root (1 scala source)
2022.06.03 11:02:45 INFO  time: compiled root in 93ms
2022.06.03 11:03:28 INFO  compiling root (1 scala source)
2022.06.03 11:03:28 INFO  time: compiled root in 0.25s
2022.06.03 11:03:43 INFO  shutting down Metals
2022.06.03 11:03:43 INFO  Shut down connection with build server.
2022.06.03 11:03:43 INFO  Shut down connection with build server.
2022.06.03 11:05:21 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at c:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\lsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\lsp.trace.json
2022.06.03 11:05:23 INFO  logging to file C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\metals.log
2022.06.03 11:05:23 INFO  Started: Metals version 0.11.5 in workspace 'C:\Users\DenisYamunaque\Documents\ADENTIS\adentis' for client Visual Studio Code 1.67.2.
2022.06.03 11:05:26 INFO  time: initialize in 3.5s
2022.06.03 11:05:26 WARN  Flyway upgrade recommended: H2 2.1.212 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.1.210.
2022.06.03 11:05:27 INFO  Attempting to connect to the build server...
2022.06.03 11:05:27 INFO  skipping build import with status 'Installed'
2022.06.03 11:05:34 INFO  no build target found for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala. Using presentation compiler with project's scala-library version: 3.1.2
2022.06.03 11:05:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.03 11:05:36 INFO  Attempting to connect to the build server...
2022.06.03 11:05:36 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\project\.metals\bsp.trace.json or C:\Users\DenisYamunaque\AppData\Local\scalameta\metals\cache\bsp.trace.json
2022.06.03 11:05:36 INFO  time: Connected to build server in 9.28s
2022.06.03 11:05:36 INFO  Connected to Build server: Bloop v1.5.0
2022.06.03 11:05:36 INFO  time: Imported build in 0.21s
2022.06.03 11:05:38 INFO  time: code lens generation in 8.79s
2022.06.03 11:05:40 INFO  time: indexed workspace in 3.85s
Jun 03, 2022 11:07:22 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 81
2022.06.03 11:07:42 INFO  compiling root (1 scala source)
2022.06.03 11:07:45 INFO  time: compiled root in 2.42s
2022.06.03 11:07:54 INFO  compiling root (1 scala source)
2022.06.03 11:07:56 INFO  time: compiled root in 1.33s
Jun 03, 2022 11:07:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 191
Jun 03, 2022 11:08:07 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 206
2022.06.03 11:08:25 INFO  compiling root (1 scala source)
2022.06.03 11:08:25 INFO  time: compiled root in 0.33s
2022.06.03 11:09:16 INFO  compiling root (1 scala source)
2022.06.03 11:09:17 INFO  time: compiled root in 1.12s
2022.06.03 11:10:02 INFO  compiling root (1 scala source)
2022.06.03 11:10:02 INFO  time: compiled root in 0.47s
2022.06.03 11:10:14 INFO  compiling root (1 scala source)
2022.06.03 11:10:14 INFO  time: compiled root in 0.66s
2022.06.03 11:11:13 INFO  compiling root (1 scala source)
2022.06.03 11:11:13 INFO  time: compiled root in 0.23s
2022.06.03 11:11:17 INFO  compiling root (1 scala source)
2022.06.03 11:11:17 INFO  time: compiled root in 0.31s
2022.06.03 11:11:20 INFO  compiling root (1 scala source)
2022.06.03 11:11:20 INFO  time: compiled root in 0.45s
2022.06.03 11:11:32 INFO  compiling root (1 scala source)
2022.06.03 11:11:32 INFO  time: compiled root in 0.46s
2022.06.03 11:12:34 INFO  compiling root (1 scala source)
2022.06.03 11:12:34 INFO  time: compiled root in 0.48s
Jun 03, 2022 11:12:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 985
2022.06.03 11:12:44 INFO  compiling root (1 scala source)
2022.06.03 11:12:44 INFO  time: compiled root in 0.47s
Jun 03, 2022 11:12:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 990
2022.06.03 11:13:02 INFO  compiling root (1 scala source)
2022.06.03 11:13:02 INFO  time: compiled root in 0.38s
2022.06.03 11:13:16 INFO  compiling root (1 scala source)
2022.06.03 11:13:16 INFO  time: compiled root in 0.36s
2022.06.03 11:14:16 INFO  compiling root (1 scala source)
2022.06.03 11:14:16 INFO  time: compiled root in 0.37s
2022.06.03 11:14:44 INFO  compiling root (1 scala source)
2022.06.03 11:14:44 INFO  time: compiled root in 0.18s
2022.06.03 11:15:28 INFO  compiling root (1 scala source)
2022.06.03 11:15:28 INFO  time: compiled root in 0.48s
2022.06.03 11:15:50 INFO  compiling root (1 scala source)
2022.06.03 11:15:50 INFO  time: compiled root in 0.36s
2022.06.03 11:16:00 INFO  compiling root (1 scala source)
2022.06.03 11:16:00 INFO  time: compiled root in 0.35s
2022.06.03 11:16:27 INFO  compiling root (1 scala source)
2022.06.03 11:16:27 INFO  time: compiled root in 0.38s
2022.06.03 11:16:35 INFO  compiling root (1 scala source)
2022.06.03 11:16:35 INFO  time: compiled root in 0.36s
2022.06.03 11:17:27 INFO  compiling root (1 scala source)
2022.06.03 11:17:27 INFO  time: compiled root in 0.37s
2022.06.03 11:19:29 INFO  compiling root (1 scala source)
2022.06.03 11:19:29 INFO  time: compiled root in 0.31s
2022.06.03 11:19:43 INFO  compiling root (1 scala source)
2022.06.03 11:19:43 INFO  time: compiled root in 0.31s
2022.06.03 11:19:51 INFO  compiling root (1 scala source)
2022.06.03 11:19:51 INFO  time: compiled root in 0.29s
2022.06.03 11:20:05 INFO  compiling root (1 scala source)
2022.06.03 11:20:05 INFO  time: compiled root in 0.27s
2022.06.03 11:20:09 INFO  compiling root (1 scala source)
2022.06.03 11:20:09 INFO  time: compiled root in 0.27s
2022.06.03 11:20:17 INFO  compiling root (1 scala source)
2022.06.03 11:20:17 INFO  time: compiled root in 0.12s
2022.06.03 11:20:24 INFO  compiling root (1 scala source)
2022.06.03 11:20:24 INFO  time: compiled root in 0.11s
2022.06.03 11:20:26 INFO  compiling root (1 scala source)
2022.06.03 11:20:26 INFO  time: compiled root in 0.12s
2022.06.03 11:20:28 INFO  compiling root (1 scala source)
2022.06.03 11:20:28 INFO  time: compiled root in 0.11s
2022.06.03 11:20:38 INFO  compiling root (1 scala source)
2022.06.03 11:20:38 INFO  time: compiled root in 0.12s
2022.06.03 11:20:40 INFO  compiling root (1 scala source)
2022.06.03 11:20:40 INFO  time: compiled root in 0.27s
2022.06.03 11:20:43 INFO  compiling root (1 scala source)
2022.06.03 11:20:43 INFO  time: compiled root in 0.31s
2022.06.03 11:20:52 INFO  compiling root (1 scala source)
2022.06.03 11:20:52 INFO  time: compiled root in 0.3s
2022.06.03 11:21:05 INFO  compiling root (1 scala source)
2022.06.03 11:21:05 INFO  time: compiled root in 0.25s
2022.06.03 11:21:24 INFO  compiling root (1 scala source)
2022.06.03 11:21:24 INFO  time: compiled root in 0.29s
2022.06.03 11:21:31 INFO  compiling root (1 scala source)
2022.06.03 11:21:31 INFO  time: compiled root in 0.25s
2022.06.03 11:21:33 INFO  compiling root (1 scala source)
2022.06.03 11:21:33 INFO  time: compiled root in 0.29s
2022.06.03 11:23:33 INFO  compiling root (1 scala source)
2022.06.03 11:23:33 INFO  time: compiled root in 0.31s
2022.06.03 11:23:45 INFO  compiling root (1 scala source)
2022.06.03 11:23:45 INFO  time: compiled root in 0.27s
2022.06.03 11:23:58 INFO  compiling root (1 scala source)
2022.06.03 11:23:59 INFO  time: compiled root in 1.45s
2022.06.03 11:32:11 INFO  compiling root (1 scala source)
2022.06.03 11:32:11 INFO  time: compiled root in 0.68s
2022.06.03 11:33:23 INFO  compiling root (1 scala source)
2022.06.03 11:33:23 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:23 INFO  time: compiled root in 0.15s
2022.06.03 11:33:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:27 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:28 INFO  compiling root (1 scala source)
2022.06.03 11:33:28 INFO  time: compiled root in 0.33s
2022.06.03 11:33:31 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:33 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:35 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:35 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:36 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:36 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:37 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:36 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:37 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:39 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:40 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:41 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:46 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:46 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:47 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:47 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:48 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:52 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:53 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:54 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:55 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:55 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:33:59 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:00 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:01 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:01 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:04 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:04 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:06 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:06 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:07 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:07 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:09 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:09 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:10 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:10 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:09 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:11 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:14 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:14 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:14 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:15 INFO  compiling root (1 scala source)
2022.06.03 11:34:15 INFO  time: compiled root in 0.23s
2022.06.03 11:34:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:33 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:46 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:34:49 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:16 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:16 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:16 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:17 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:19 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:20 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:21 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:23 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:24 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:24 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:24 INFO  compiling root (1 scala source)
2022.06.03 11:35:24 INFO  time: compiled root in 0.14s
2022.06.03 11:35:26 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:28 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:30 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:30 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:30 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:30 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:33 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:33 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:42 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:42 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:43 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:45 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:45 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:45 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:45 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:44 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:35:46 INFO  compiling root (1 scala source)
2022.06.03 11:35:46 INFO  time: compiled root in 0.49s
2022.06.03 11:37:00 INFO  compiling root (1 scala source)
2022.06.03 11:37:00 INFO  time: compiled root in 0.26s
2022.06.03 11:37:11 INFO  compiling root (1 scala source)
2022.06.03 11:37:11 INFO  time: compiled root in 0.46s
2022.06.03 11:37:36 INFO  compiling root (1 scala source)
2022.06.03 11:37:36 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:37:36 INFO  time: compiled root in 0.38s
Jun 03, 2022 11:38:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3101
2022.06.03 11:39:01 INFO  compiling root (1 scala source)
2022.06.03 11:39:01 INFO  time: compiled root in 0.35s
2022.06.03 11:40:27 INFO  compiling root (1 scala source)
2022.06.03 11:40:27 INFO  time: compiled root in 0.34s
2022.06.03 11:40:52 INFO  compiling root (1 scala source)
2022.06.03 11:40:52 INFO  time: compiled root in 0.34s
2022.06.03 11:41:25 INFO  compiling root (1 scala source)
2022.06.03 11:41:25 INFO  time: compiled root in 0.35s
2022.06.03 11:41:45 WARN  Could not load snapshot text for C:\Users\DenisYamunaque\Documents\ADENTIS\adentis\src\main\scala\Main.scala
2022.06.03 11:41:45 INFO  compiling root (1 scala source)
2022.06.03 11:41:45 INFO  time: compiled root in 0.33s
